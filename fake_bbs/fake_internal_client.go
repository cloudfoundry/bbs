// Code generated by counterfeiter. DO NOT EDIT.
package fake_bbs

import (
	"sync"
	"time"

	"code.cloudfoundry.org/bbs"
	"code.cloudfoundry.org/bbs/events"
	"code.cloudfoundry.org/bbs/models"
	lager "code.cloudfoundry.org/lager/v3"
)

type FakeInternalClient struct {
	ActualLRPGroupByProcessGuidAndIndexStub        func(lager.Logger, string, string, int) (*models.ActualLRPGroup, error)
	actualLRPGroupByProcessGuidAndIndexMutex       sync.RWMutex
	actualLRPGroupByProcessGuidAndIndexArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 int
	}
	actualLRPGroupByProcessGuidAndIndexReturns struct {
		result1 *models.ActualLRPGroup
		result2 error
	}
	actualLRPGroupByProcessGuidAndIndexReturnsOnCall map[int]struct {
		result1 *models.ActualLRPGroup
		result2 error
	}
	ActualLRPGroupsStub        func(lager.Logger, string, models.ActualLRPFilter) ([]*models.ActualLRPGroup, error)
	actualLRPGroupsMutex       sync.RWMutex
	actualLRPGroupsArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 models.ActualLRPFilter
	}
	actualLRPGroupsReturns struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	actualLRPGroupsReturnsOnCall map[int]struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	ActualLRPGroupsByProcessGuidStub        func(lager.Logger, string, string) ([]*models.ActualLRPGroup, error)
	actualLRPGroupsByProcessGuidMutex       sync.RWMutex
	actualLRPGroupsByProcessGuidArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}
	actualLRPGroupsByProcessGuidReturns struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	actualLRPGroupsByProcessGuidReturnsOnCall map[int]struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}
	ActualLRPsStub        func(lager.Logger, string, models.ActualLRPFilter) ([]*models.ActualLRP, error)
	actualLRPsMutex       sync.RWMutex
	actualLRPsArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 models.ActualLRPFilter
	}
	actualLRPsReturns struct {
		result1 []*models.ActualLRP
		result2 error
	}
	actualLRPsReturnsOnCall map[int]struct {
		result1 []*models.ActualLRP
		result2 error
	}
	CancelTaskStub        func(lager.Logger, string, string) error
	cancelTaskMutex       sync.RWMutex
	cancelTaskArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}
	cancelTaskReturns struct {
		result1 error
	}
	cancelTaskReturnsOnCall map[int]struct {
		result1 error
	}
	CellsStub        func(lager.Logger, string) ([]*models.CellPresence, error)
	cellsMutex       sync.RWMutex
	cellsArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	cellsReturns struct {
		result1 []*models.CellPresence
		result2 error
	}
	cellsReturnsOnCall map[int]struct {
		result1 []*models.CellPresence
		result2 error
	}
	ClaimActualLRPStub        func(lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey) error
	claimActualLRPMutex       sync.RWMutex
	claimActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
	}
	claimActualLRPReturns struct {
		result1 error
	}
	claimActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	CompleteTaskStub        func(lager.Logger, string, string, string, bool, string, string) error
	completeTaskMutex       sync.RWMutex
	completeTaskArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 string
		arg5 bool
		arg6 string
		arg7 string
	}
	completeTaskReturns struct {
		result1 error
	}
	completeTaskReturnsOnCall map[int]struct {
		result1 error
	}
	CrashActualLRPStub        func(lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) error
	crashActualLRPMutex       sync.RWMutex
	crashActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
		arg5 string
	}
	crashActualLRPReturns struct {
		result1 error
	}
	crashActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteTaskStub        func(lager.Logger, string, string) error
	deleteTaskMutex       sync.RWMutex
	deleteTaskArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}
	deleteTaskReturns struct {
		result1 error
	}
	deleteTaskReturnsOnCall map[int]struct {
		result1 error
	}
	DesireLRPStub        func(lager.Logger, string, *models.DesiredLRP) error
	desireLRPMutex       sync.RWMutex
	desireLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.DesiredLRP
	}
	desireLRPReturns struct {
		result1 error
	}
	desireLRPReturnsOnCall map[int]struct {
		result1 error
	}
	DesireTaskStub        func(lager.Logger, string, string, string, *models.TaskDefinition) error
	desireTaskMutex       sync.RWMutex
	desireTaskArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 string
		arg5 *models.TaskDefinition
	}
	desireTaskReturns struct {
		result1 error
	}
	desireTaskReturnsOnCall map[int]struct {
		result1 error
	}
	DesiredLRPByProcessGuidStub        func(lager.Logger, string, string) (*models.DesiredLRP, error)
	desiredLRPByProcessGuidMutex       sync.RWMutex
	desiredLRPByProcessGuidArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}
	desiredLRPByProcessGuidReturns struct {
		result1 *models.DesiredLRP
		result2 error
	}
	desiredLRPByProcessGuidReturnsOnCall map[int]struct {
		result1 *models.DesiredLRP
		result2 error
	}
	DesiredLRPRoutingInfosStub        func(lager.Logger, string, models.DesiredLRPFilter) ([]*models.DesiredLRP, error)
	desiredLRPRoutingInfosMutex       sync.RWMutex
	desiredLRPRoutingInfosArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 models.DesiredLRPFilter
	}
	desiredLRPRoutingInfosReturns struct {
		result1 []*models.DesiredLRP
		result2 error
	}
	desiredLRPRoutingInfosReturnsOnCall map[int]struct {
		result1 []*models.DesiredLRP
		result2 error
	}
	DesiredLRPSchedulingInfoByProcessGuidStub        func(lager.Logger, string, string) (*models.DesiredLRPSchedulingInfo, error)
	desiredLRPSchedulingInfoByProcessGuidMutex       sync.RWMutex
	desiredLRPSchedulingInfoByProcessGuidArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}
	desiredLRPSchedulingInfoByProcessGuidReturns struct {
		result1 *models.DesiredLRPSchedulingInfo
		result2 error
	}
	desiredLRPSchedulingInfoByProcessGuidReturnsOnCall map[int]struct {
		result1 *models.DesiredLRPSchedulingInfo
		result2 error
	}
	DesiredLRPSchedulingInfosStub        func(lager.Logger, string, models.DesiredLRPFilter) ([]*models.DesiredLRPSchedulingInfo, error)
	desiredLRPSchedulingInfosMutex       sync.RWMutex
	desiredLRPSchedulingInfosArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 models.DesiredLRPFilter
	}
	desiredLRPSchedulingInfosReturns struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}
	desiredLRPSchedulingInfosReturnsOnCall map[int]struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}
	DesiredLRPsStub        func(lager.Logger, string, models.DesiredLRPFilter) ([]*models.DesiredLRP, error)
	desiredLRPsMutex       sync.RWMutex
	desiredLRPsArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 models.DesiredLRPFilter
	}
	desiredLRPsReturns struct {
		result1 []*models.DesiredLRP
		result2 error
	}
	desiredLRPsReturnsOnCall map[int]struct {
		result1 []*models.DesiredLRP
		result2 error
	}
	DomainsStub        func(lager.Logger, string) ([]string, error)
	domainsMutex       sync.RWMutex
	domainsArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	domainsReturns struct {
		result1 []string
		result2 error
	}
	domainsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	EvacuateClaimedActualLRPStub        func(lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey) (bool, error)
	evacuateClaimedActualLRPMutex       sync.RWMutex
	evacuateClaimedActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
	}
	evacuateClaimedActualLRPReturns struct {
		result1 bool
		result2 error
	}
	evacuateClaimedActualLRPReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	EvacuateCrashedActualLRPStub        func(lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) (bool, error)
	evacuateCrashedActualLRPMutex       sync.RWMutex
	evacuateCrashedActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
		arg5 string
	}
	evacuateCrashedActualLRPReturns struct {
		result1 bool
		result2 error
	}
	evacuateCrashedActualLRPReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	EvacuateRunningActualLRPStub        func(lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo, []*models.ActualLRPInternalRoute, map[string]string, bool, string) (bool, error)
	evacuateRunningActualLRPMutex       sync.RWMutex
	evacuateRunningActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
		arg5 *models.ActualLRPNetInfo
		arg6 []*models.ActualLRPInternalRoute
		arg7 map[string]string
		arg8 bool
		arg9 string
	}
	evacuateRunningActualLRPReturns struct {
		result1 bool
		result2 error
	}
	evacuateRunningActualLRPReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	EvacuateStoppedActualLRPStub        func(lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey) (bool, error)
	evacuateStoppedActualLRPMutex       sync.RWMutex
	evacuateStoppedActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
	}
	evacuateStoppedActualLRPReturns struct {
		result1 bool
		result2 error
	}
	evacuateStoppedActualLRPReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	FailActualLRPStub        func(lager.Logger, string, *models.ActualLRPKey, string) error
	failActualLRPMutex       sync.RWMutex
	failActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
		arg4 string
	}
	failActualLRPReturns struct {
		result1 error
	}
	failActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	FailTaskStub        func(lager.Logger, string, string, string) error
	failTaskMutex       sync.RWMutex
	failTaskArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 string
	}
	failTaskReturns struct {
		result1 error
	}
	failTaskReturnsOnCall map[int]struct {
		result1 error
	}
	PingStub        func(lager.Logger, string) bool
	pingMutex       sync.RWMutex
	pingArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	pingReturns struct {
		result1 bool
	}
	pingReturnsOnCall map[int]struct {
		result1 bool
	}
	RejectTaskStub        func(lager.Logger, string, string, string) error
	rejectTaskMutex       sync.RWMutex
	rejectTaskArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 string
	}
	rejectTaskReturns struct {
		result1 error
	}
	rejectTaskReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveActualLRPStub        func(lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey) error
	removeActualLRPMutex       sync.RWMutex
	removeActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
	}
	removeActualLRPReturns struct {
		result1 error
	}
	removeActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveDesiredLRPStub        func(lager.Logger, string, string) error
	removeDesiredLRPMutex       sync.RWMutex
	removeDesiredLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}
	removeDesiredLRPReturns struct {
		result1 error
	}
	removeDesiredLRPReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveEvacuatingActualLRPStub        func(lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey) error
	removeEvacuatingActualLRPMutex       sync.RWMutex
	removeEvacuatingActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
	}
	removeEvacuatingActualLRPReturns struct {
		result1 error
	}
	removeEvacuatingActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	ResolvingTaskStub        func(lager.Logger, string, string) error
	resolvingTaskMutex       sync.RWMutex
	resolvingTaskArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}
	resolvingTaskReturns struct {
		result1 error
	}
	resolvingTaskReturnsOnCall map[int]struct {
		result1 error
	}
	RetireActualLRPStub        func(lager.Logger, string, *models.ActualLRPKey) error
	retireActualLRPMutex       sync.RWMutex
	retireActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
	}
	retireActualLRPReturns struct {
		result1 error
	}
	retireActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	StartActualLRPStub        func(lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo, []*models.ActualLRPInternalRoute, map[string]string, bool, string) error
	startActualLRPMutex       sync.RWMutex
	startActualLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
		arg5 *models.ActualLRPNetInfo
		arg6 []*models.ActualLRPInternalRoute
		arg7 map[string]string
		arg8 bool
		arg9 string
	}
	startActualLRPReturns struct {
		result1 error
	}
	startActualLRPReturnsOnCall map[int]struct {
		result1 error
	}
	StartTaskStub        func(lager.Logger, string, string, string) (bool, error)
	startTaskMutex       sync.RWMutex
	startTaskArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 string
	}
	startTaskReturns struct {
		result1 bool
		result2 error
	}
	startTaskReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	SubscribeToEventsStub        func(lager.Logger) (events.EventSource, error)
	subscribeToEventsMutex       sync.RWMutex
	subscribeToEventsArgsForCall []struct {
		arg1 lager.Logger
	}
	subscribeToEventsReturns struct {
		result1 events.EventSource
		result2 error
	}
	subscribeToEventsReturnsOnCall map[int]struct {
		result1 events.EventSource
		result2 error
	}
	SubscribeToEventsByCellIDStub        func(lager.Logger, string) (events.EventSource, error)
	subscribeToEventsByCellIDMutex       sync.RWMutex
	subscribeToEventsByCellIDArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	subscribeToEventsByCellIDReturns struct {
		result1 events.EventSource
		result2 error
	}
	subscribeToEventsByCellIDReturnsOnCall map[int]struct {
		result1 events.EventSource
		result2 error
	}
	SubscribeToInstanceEventsStub        func(lager.Logger) (events.EventSource, error)
	subscribeToInstanceEventsMutex       sync.RWMutex
	subscribeToInstanceEventsArgsForCall []struct {
		arg1 lager.Logger
	}
	subscribeToInstanceEventsReturns struct {
		result1 events.EventSource
		result2 error
	}
	subscribeToInstanceEventsReturnsOnCall map[int]struct {
		result1 events.EventSource
		result2 error
	}
	SubscribeToInstanceEventsByCellIDStub        func(lager.Logger, string) (events.EventSource, error)
	subscribeToInstanceEventsByCellIDMutex       sync.RWMutex
	subscribeToInstanceEventsByCellIDArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	subscribeToInstanceEventsByCellIDReturns struct {
		result1 events.EventSource
		result2 error
	}
	subscribeToInstanceEventsByCellIDReturnsOnCall map[int]struct {
		result1 events.EventSource
		result2 error
	}
	SubscribeToTaskEventsStub        func(lager.Logger) (events.EventSource, error)
	subscribeToTaskEventsMutex       sync.RWMutex
	subscribeToTaskEventsArgsForCall []struct {
		arg1 lager.Logger
	}
	subscribeToTaskEventsReturns struct {
		result1 events.EventSource
		result2 error
	}
	subscribeToTaskEventsReturnsOnCall map[int]struct {
		result1 events.EventSource
		result2 error
	}
	TaskByGuidStub        func(lager.Logger, string, string) (*models.Task, error)
	taskByGuidMutex       sync.RWMutex
	taskByGuidArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}
	taskByGuidReturns struct {
		result1 *models.Task
		result2 error
	}
	taskByGuidReturnsOnCall map[int]struct {
		result1 *models.Task
		result2 error
	}
	TasksStub        func(lager.Logger, string) ([]*models.Task, error)
	tasksMutex       sync.RWMutex
	tasksArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
	}
	tasksReturns struct {
		result1 []*models.Task
		result2 error
	}
	tasksReturnsOnCall map[int]struct {
		result1 []*models.Task
		result2 error
	}
	TasksByCellIDStub        func(lager.Logger, string, string) ([]*models.Task, error)
	tasksByCellIDMutex       sync.RWMutex
	tasksByCellIDArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}
	tasksByCellIDReturns struct {
		result1 []*models.Task
		result2 error
	}
	tasksByCellIDReturnsOnCall map[int]struct {
		result1 []*models.Task
		result2 error
	}
	TasksByDomainStub        func(lager.Logger, string, string) ([]*models.Task, error)
	tasksByDomainMutex       sync.RWMutex
	tasksByDomainArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}
	tasksByDomainReturns struct {
		result1 []*models.Task
		result2 error
	}
	tasksByDomainReturnsOnCall map[int]struct {
		result1 []*models.Task
		result2 error
	}
	TasksWithFilterStub        func(lager.Logger, string, models.TaskFilter) ([]*models.Task, error)
	tasksWithFilterMutex       sync.RWMutex
	tasksWithFilterArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 models.TaskFilter
	}
	tasksWithFilterReturns struct {
		result1 []*models.Task
		result2 error
	}
	tasksWithFilterReturnsOnCall map[int]struct {
		result1 []*models.Task
		result2 error
	}
	UpdateDesiredLRPStub        func(lager.Logger, string, string, *models.DesiredLRPUpdate) error
	updateDesiredLRPMutex       sync.RWMutex
	updateDesiredLRPArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 *models.DesiredLRPUpdate
	}
	updateDesiredLRPReturns struct {
		result1 error
	}
	updateDesiredLRPReturnsOnCall map[int]struct {
		result1 error
	}
	UpsertDomainStub        func(lager.Logger, string, string, time.Duration) error
	upsertDomainMutex       sync.RWMutex
	upsertDomainArgsForCall []struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 time.Duration
	}
	upsertDomainReturns struct {
		result1 error
	}
	upsertDomainReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeInternalClient) ActualLRPGroupByProcessGuidAndIndex(arg1 lager.Logger, arg2 string, arg3 string, arg4 int) (*models.ActualLRPGroup, error) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Lock()
	ret, specificReturn := fake.actualLRPGroupByProcessGuidAndIndexReturnsOnCall[len(fake.actualLRPGroupByProcessGuidAndIndexArgsForCall)]
	fake.actualLRPGroupByProcessGuidAndIndexArgsForCall = append(fake.actualLRPGroupByProcessGuidAndIndexArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 int
	}{arg1, arg2, arg3, arg4})
	stub := fake.ActualLRPGroupByProcessGuidAndIndexStub
	fakeReturns := fake.actualLRPGroupByProcessGuidAndIndexReturns
	fake.recordInvocation("ActualLRPGroupByProcessGuidAndIndex", []interface{}{arg1, arg2, arg3, arg4})
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) ActualLRPGroupByProcessGuidAndIndexCallCount() int {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	return len(fake.actualLRPGroupByProcessGuidAndIndexArgsForCall)
}

func (fake *FakeInternalClient) ActualLRPGroupByProcessGuidAndIndexCalls(stub func(lager.Logger, string, string, int) (*models.ActualLRPGroup, error)) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Lock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.Unlock()
	fake.ActualLRPGroupByProcessGuidAndIndexStub = stub
}

func (fake *FakeInternalClient) ActualLRPGroupByProcessGuidAndIndexArgsForCall(i int) (lager.Logger, string, string, int) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	argsForCall := fake.actualLRPGroupByProcessGuidAndIndexArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInternalClient) ActualLRPGroupByProcessGuidAndIndexReturns(result1 *models.ActualLRPGroup, result2 error) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Lock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.Unlock()
	fake.ActualLRPGroupByProcessGuidAndIndexStub = nil
	fake.actualLRPGroupByProcessGuidAndIndexReturns = struct {
		result1 *models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ActualLRPGroupByProcessGuidAndIndexReturnsOnCall(i int, result1 *models.ActualLRPGroup, result2 error) {
	fake.actualLRPGroupByProcessGuidAndIndexMutex.Lock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.Unlock()
	fake.ActualLRPGroupByProcessGuidAndIndexStub = nil
	if fake.actualLRPGroupByProcessGuidAndIndexReturnsOnCall == nil {
		fake.actualLRPGroupByProcessGuidAndIndexReturnsOnCall = make(map[int]struct {
			result1 *models.ActualLRPGroup
			result2 error
		})
	}
	fake.actualLRPGroupByProcessGuidAndIndexReturnsOnCall[i] = struct {
		result1 *models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ActualLRPGroups(arg1 lager.Logger, arg2 string, arg3 models.ActualLRPFilter) ([]*models.ActualLRPGroup, error) {
	fake.actualLRPGroupsMutex.Lock()
	ret, specificReturn := fake.actualLRPGroupsReturnsOnCall[len(fake.actualLRPGroupsArgsForCall)]
	fake.actualLRPGroupsArgsForCall = append(fake.actualLRPGroupsArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 models.ActualLRPFilter
	}{arg1, arg2, arg3})
	stub := fake.ActualLRPGroupsStub
	fakeReturns := fake.actualLRPGroupsReturns
	fake.recordInvocation("ActualLRPGroups", []interface{}{arg1, arg2, arg3})
	fake.actualLRPGroupsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) ActualLRPGroupsCallCount() int {
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	return len(fake.actualLRPGroupsArgsForCall)
}

func (fake *FakeInternalClient) ActualLRPGroupsCalls(stub func(lager.Logger, string, models.ActualLRPFilter) ([]*models.ActualLRPGroup, error)) {
	fake.actualLRPGroupsMutex.Lock()
	defer fake.actualLRPGroupsMutex.Unlock()
	fake.ActualLRPGroupsStub = stub
}

func (fake *FakeInternalClient) ActualLRPGroupsArgsForCall(i int) (lager.Logger, string, models.ActualLRPFilter) {
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	argsForCall := fake.actualLRPGroupsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) ActualLRPGroupsReturns(result1 []*models.ActualLRPGroup, result2 error) {
	fake.actualLRPGroupsMutex.Lock()
	defer fake.actualLRPGroupsMutex.Unlock()
	fake.ActualLRPGroupsStub = nil
	fake.actualLRPGroupsReturns = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ActualLRPGroupsReturnsOnCall(i int, result1 []*models.ActualLRPGroup, result2 error) {
	fake.actualLRPGroupsMutex.Lock()
	defer fake.actualLRPGroupsMutex.Unlock()
	fake.ActualLRPGroupsStub = nil
	if fake.actualLRPGroupsReturnsOnCall == nil {
		fake.actualLRPGroupsReturnsOnCall = make(map[int]struct {
			result1 []*models.ActualLRPGroup
			result2 error
		})
	}
	fake.actualLRPGroupsReturnsOnCall[i] = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ActualLRPGroupsByProcessGuid(arg1 lager.Logger, arg2 string, arg3 string) ([]*models.ActualLRPGroup, error) {
	fake.actualLRPGroupsByProcessGuidMutex.Lock()
	ret, specificReturn := fake.actualLRPGroupsByProcessGuidReturnsOnCall[len(fake.actualLRPGroupsByProcessGuidArgsForCall)]
	fake.actualLRPGroupsByProcessGuidArgsForCall = append(fake.actualLRPGroupsByProcessGuidArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ActualLRPGroupsByProcessGuidStub
	fakeReturns := fake.actualLRPGroupsByProcessGuidReturns
	fake.recordInvocation("ActualLRPGroupsByProcessGuid", []interface{}{arg1, arg2, arg3})
	fake.actualLRPGroupsByProcessGuidMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) ActualLRPGroupsByProcessGuidCallCount() int {
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	return len(fake.actualLRPGroupsByProcessGuidArgsForCall)
}

func (fake *FakeInternalClient) ActualLRPGroupsByProcessGuidCalls(stub func(lager.Logger, string, string) ([]*models.ActualLRPGroup, error)) {
	fake.actualLRPGroupsByProcessGuidMutex.Lock()
	defer fake.actualLRPGroupsByProcessGuidMutex.Unlock()
	fake.ActualLRPGroupsByProcessGuidStub = stub
}

func (fake *FakeInternalClient) ActualLRPGroupsByProcessGuidArgsForCall(i int) (lager.Logger, string, string) {
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	argsForCall := fake.actualLRPGroupsByProcessGuidArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) ActualLRPGroupsByProcessGuidReturns(result1 []*models.ActualLRPGroup, result2 error) {
	fake.actualLRPGroupsByProcessGuidMutex.Lock()
	defer fake.actualLRPGroupsByProcessGuidMutex.Unlock()
	fake.ActualLRPGroupsByProcessGuidStub = nil
	fake.actualLRPGroupsByProcessGuidReturns = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ActualLRPGroupsByProcessGuidReturnsOnCall(i int, result1 []*models.ActualLRPGroup, result2 error) {
	fake.actualLRPGroupsByProcessGuidMutex.Lock()
	defer fake.actualLRPGroupsByProcessGuidMutex.Unlock()
	fake.ActualLRPGroupsByProcessGuidStub = nil
	if fake.actualLRPGroupsByProcessGuidReturnsOnCall == nil {
		fake.actualLRPGroupsByProcessGuidReturnsOnCall = make(map[int]struct {
			result1 []*models.ActualLRPGroup
			result2 error
		})
	}
	fake.actualLRPGroupsByProcessGuidReturnsOnCall[i] = struct {
		result1 []*models.ActualLRPGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ActualLRPs(arg1 lager.Logger, arg2 string, arg3 models.ActualLRPFilter) ([]*models.ActualLRP, error) {
	fake.actualLRPsMutex.Lock()
	ret, specificReturn := fake.actualLRPsReturnsOnCall[len(fake.actualLRPsArgsForCall)]
	fake.actualLRPsArgsForCall = append(fake.actualLRPsArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 models.ActualLRPFilter
	}{arg1, arg2, arg3})
	stub := fake.ActualLRPsStub
	fakeReturns := fake.actualLRPsReturns
	fake.recordInvocation("ActualLRPs", []interface{}{arg1, arg2, arg3})
	fake.actualLRPsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) ActualLRPsCallCount() int {
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	return len(fake.actualLRPsArgsForCall)
}

func (fake *FakeInternalClient) ActualLRPsCalls(stub func(lager.Logger, string, models.ActualLRPFilter) ([]*models.ActualLRP, error)) {
	fake.actualLRPsMutex.Lock()
	defer fake.actualLRPsMutex.Unlock()
	fake.ActualLRPsStub = stub
}

func (fake *FakeInternalClient) ActualLRPsArgsForCall(i int) (lager.Logger, string, models.ActualLRPFilter) {
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	argsForCall := fake.actualLRPsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) ActualLRPsReturns(result1 []*models.ActualLRP, result2 error) {
	fake.actualLRPsMutex.Lock()
	defer fake.actualLRPsMutex.Unlock()
	fake.ActualLRPsStub = nil
	fake.actualLRPsReturns = struct {
		result1 []*models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ActualLRPsReturnsOnCall(i int, result1 []*models.ActualLRP, result2 error) {
	fake.actualLRPsMutex.Lock()
	defer fake.actualLRPsMutex.Unlock()
	fake.ActualLRPsStub = nil
	if fake.actualLRPsReturnsOnCall == nil {
		fake.actualLRPsReturnsOnCall = make(map[int]struct {
			result1 []*models.ActualLRP
			result2 error
		})
	}
	fake.actualLRPsReturnsOnCall[i] = struct {
		result1 []*models.ActualLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) CancelTask(arg1 lager.Logger, arg2 string, arg3 string) error {
	fake.cancelTaskMutex.Lock()
	ret, specificReturn := fake.cancelTaskReturnsOnCall[len(fake.cancelTaskArgsForCall)]
	fake.cancelTaskArgsForCall = append(fake.cancelTaskArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.CancelTaskStub
	fakeReturns := fake.cancelTaskReturns
	fake.recordInvocation("CancelTask", []interface{}{arg1, arg2, arg3})
	fake.cancelTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInternalClient) CancelTaskCallCount() int {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	return len(fake.cancelTaskArgsForCall)
}

func (fake *FakeInternalClient) CancelTaskCalls(stub func(lager.Logger, string, string) error) {
	fake.cancelTaskMutex.Lock()
	defer fake.cancelTaskMutex.Unlock()
	fake.CancelTaskStub = stub
}

func (fake *FakeInternalClient) CancelTaskArgsForCall(i int) (lager.Logger, string, string) {
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	argsForCall := fake.cancelTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) CancelTaskReturns(result1 error) {
	fake.cancelTaskMutex.Lock()
	defer fake.cancelTaskMutex.Unlock()
	fake.CancelTaskStub = nil
	fake.cancelTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) CancelTaskReturnsOnCall(i int, result1 error) {
	fake.cancelTaskMutex.Lock()
	defer fake.cancelTaskMutex.Unlock()
	fake.CancelTaskStub = nil
	if fake.cancelTaskReturnsOnCall == nil {
		fake.cancelTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) Cells(arg1 lager.Logger, arg2 string) ([]*models.CellPresence, error) {
	fake.cellsMutex.Lock()
	ret, specificReturn := fake.cellsReturnsOnCall[len(fake.cellsArgsForCall)]
	fake.cellsArgsForCall = append(fake.cellsArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	stub := fake.CellsStub
	fakeReturns := fake.cellsReturns
	fake.recordInvocation("Cells", []interface{}{arg1, arg2})
	fake.cellsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) CellsCallCount() int {
	fake.cellsMutex.RLock()
	defer fake.cellsMutex.RUnlock()
	return len(fake.cellsArgsForCall)
}

func (fake *FakeInternalClient) CellsCalls(stub func(lager.Logger, string) ([]*models.CellPresence, error)) {
	fake.cellsMutex.Lock()
	defer fake.cellsMutex.Unlock()
	fake.CellsStub = stub
}

func (fake *FakeInternalClient) CellsArgsForCall(i int) (lager.Logger, string) {
	fake.cellsMutex.RLock()
	defer fake.cellsMutex.RUnlock()
	argsForCall := fake.cellsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) CellsReturns(result1 []*models.CellPresence, result2 error) {
	fake.cellsMutex.Lock()
	defer fake.cellsMutex.Unlock()
	fake.CellsStub = nil
	fake.cellsReturns = struct {
		result1 []*models.CellPresence
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) CellsReturnsOnCall(i int, result1 []*models.CellPresence, result2 error) {
	fake.cellsMutex.Lock()
	defer fake.cellsMutex.Unlock()
	fake.CellsStub = nil
	if fake.cellsReturnsOnCall == nil {
		fake.cellsReturnsOnCall = make(map[int]struct {
			result1 []*models.CellPresence
			result2 error
		})
	}
	fake.cellsReturnsOnCall[i] = struct {
		result1 []*models.CellPresence
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) ClaimActualLRP(arg1 lager.Logger, arg2 string, arg3 *models.ActualLRPKey, arg4 *models.ActualLRPInstanceKey) error {
	fake.claimActualLRPMutex.Lock()
	ret, specificReturn := fake.claimActualLRPReturnsOnCall[len(fake.claimActualLRPArgsForCall)]
	fake.claimActualLRPArgsForCall = append(fake.claimActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3, arg4})
	stub := fake.ClaimActualLRPStub
	fakeReturns := fake.claimActualLRPReturns
	fake.recordInvocation("ClaimActualLRP", []interface{}{arg1, arg2, arg3, arg4})
	fake.claimActualLRPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInternalClient) ClaimActualLRPCallCount() int {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	return len(fake.claimActualLRPArgsForCall)
}

func (fake *FakeInternalClient) ClaimActualLRPCalls(stub func(lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey) error) {
	fake.claimActualLRPMutex.Lock()
	defer fake.claimActualLRPMutex.Unlock()
	fake.ClaimActualLRPStub = stub
}

func (fake *FakeInternalClient) ClaimActualLRPArgsForCall(i int) (lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	argsForCall := fake.claimActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInternalClient) ClaimActualLRPReturns(result1 error) {
	fake.claimActualLRPMutex.Lock()
	defer fake.claimActualLRPMutex.Unlock()
	fake.ClaimActualLRPStub = nil
	fake.claimActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) ClaimActualLRPReturnsOnCall(i int, result1 error) {
	fake.claimActualLRPMutex.Lock()
	defer fake.claimActualLRPMutex.Unlock()
	fake.ClaimActualLRPStub = nil
	if fake.claimActualLRPReturnsOnCall == nil {
		fake.claimActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.claimActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) CompleteTask(arg1 lager.Logger, arg2 string, arg3 string, arg4 string, arg5 bool, arg6 string, arg7 string) error {
	fake.completeTaskMutex.Lock()
	ret, specificReturn := fake.completeTaskReturnsOnCall[len(fake.completeTaskArgsForCall)]
	fake.completeTaskArgsForCall = append(fake.completeTaskArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 string
		arg5 bool
		arg6 string
		arg7 string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	stub := fake.CompleteTaskStub
	fakeReturns := fake.completeTaskReturns
	fake.recordInvocation("CompleteTask", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.completeTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInternalClient) CompleteTaskCallCount() int {
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	return len(fake.completeTaskArgsForCall)
}

func (fake *FakeInternalClient) CompleteTaskCalls(stub func(lager.Logger, string, string, string, bool, string, string) error) {
	fake.completeTaskMutex.Lock()
	defer fake.completeTaskMutex.Unlock()
	fake.CompleteTaskStub = stub
}

func (fake *FakeInternalClient) CompleteTaskArgsForCall(i int) (lager.Logger, string, string, string, bool, string, string) {
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	argsForCall := fake.completeTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeInternalClient) CompleteTaskReturns(result1 error) {
	fake.completeTaskMutex.Lock()
	defer fake.completeTaskMutex.Unlock()
	fake.CompleteTaskStub = nil
	fake.completeTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) CompleteTaskReturnsOnCall(i int, result1 error) {
	fake.completeTaskMutex.Lock()
	defer fake.completeTaskMutex.Unlock()
	fake.CompleteTaskStub = nil
	if fake.completeTaskReturnsOnCall == nil {
		fake.completeTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.completeTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) CrashActualLRP(arg1 lager.Logger, arg2 string, arg3 *models.ActualLRPKey, arg4 *models.ActualLRPInstanceKey, arg5 string) error {
	fake.crashActualLRPMutex.Lock()
	ret, specificReturn := fake.crashActualLRPReturnsOnCall[len(fake.crashActualLRPArgsForCall)]
	fake.crashActualLRPArgsForCall = append(fake.crashActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.CrashActualLRPStub
	fakeReturns := fake.crashActualLRPReturns
	fake.recordInvocation("CrashActualLRP", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.crashActualLRPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInternalClient) CrashActualLRPCallCount() int {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	return len(fake.crashActualLRPArgsForCall)
}

func (fake *FakeInternalClient) CrashActualLRPCalls(stub func(lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) error) {
	fake.crashActualLRPMutex.Lock()
	defer fake.crashActualLRPMutex.Unlock()
	fake.CrashActualLRPStub = stub
}

func (fake *FakeInternalClient) CrashActualLRPArgsForCall(i int) (lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) {
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	argsForCall := fake.crashActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeInternalClient) CrashActualLRPReturns(result1 error) {
	fake.crashActualLRPMutex.Lock()
	defer fake.crashActualLRPMutex.Unlock()
	fake.CrashActualLRPStub = nil
	fake.crashActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) CrashActualLRPReturnsOnCall(i int, result1 error) {
	fake.crashActualLRPMutex.Lock()
	defer fake.crashActualLRPMutex.Unlock()
	fake.CrashActualLRPStub = nil
	if fake.crashActualLRPReturnsOnCall == nil {
		fake.crashActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.crashActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) DeleteTask(arg1 lager.Logger, arg2 string, arg3 string) error {
	fake.deleteTaskMutex.Lock()
	ret, specificReturn := fake.deleteTaskReturnsOnCall[len(fake.deleteTaskArgsForCall)]
	fake.deleteTaskArgsForCall = append(fake.deleteTaskArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.DeleteTaskStub
	fakeReturns := fake.deleteTaskReturns
	fake.recordInvocation("DeleteTask", []interface{}{arg1, arg2, arg3})
	fake.deleteTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInternalClient) DeleteTaskCallCount() int {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	return len(fake.deleteTaskArgsForCall)
}

func (fake *FakeInternalClient) DeleteTaskCalls(stub func(lager.Logger, string, string) error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = stub
}

func (fake *FakeInternalClient) DeleteTaskArgsForCall(i int) (lager.Logger, string, string) {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	argsForCall := fake.deleteTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) DeleteTaskReturns(result1 error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = nil
	fake.deleteTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) DeleteTaskReturnsOnCall(i int, result1 error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = nil
	if fake.deleteTaskReturnsOnCall == nil {
		fake.deleteTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) DesireLRP(arg1 lager.Logger, arg2 string, arg3 *models.DesiredLRP) error {
	fake.desireLRPMutex.Lock()
	ret, specificReturn := fake.desireLRPReturnsOnCall[len(fake.desireLRPArgsForCall)]
	fake.desireLRPArgsForCall = append(fake.desireLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.DesiredLRP
	}{arg1, arg2, arg3})
	stub := fake.DesireLRPStub
	fakeReturns := fake.desireLRPReturns
	fake.recordInvocation("DesireLRP", []interface{}{arg1, arg2, arg3})
	fake.desireLRPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInternalClient) DesireLRPCallCount() int {
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	return len(fake.desireLRPArgsForCall)
}

func (fake *FakeInternalClient) DesireLRPCalls(stub func(lager.Logger, string, *models.DesiredLRP) error) {
	fake.desireLRPMutex.Lock()
	defer fake.desireLRPMutex.Unlock()
	fake.DesireLRPStub = stub
}

func (fake *FakeInternalClient) DesireLRPArgsForCall(i int) (lager.Logger, string, *models.DesiredLRP) {
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	argsForCall := fake.desireLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) DesireLRPReturns(result1 error) {
	fake.desireLRPMutex.Lock()
	defer fake.desireLRPMutex.Unlock()
	fake.DesireLRPStub = nil
	fake.desireLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) DesireLRPReturnsOnCall(i int, result1 error) {
	fake.desireLRPMutex.Lock()
	defer fake.desireLRPMutex.Unlock()
	fake.DesireLRPStub = nil
	if fake.desireLRPReturnsOnCall == nil {
		fake.desireLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.desireLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) DesireTask(arg1 lager.Logger, arg2 string, arg3 string, arg4 string, arg5 *models.TaskDefinition) error {
	fake.desireTaskMutex.Lock()
	ret, specificReturn := fake.desireTaskReturnsOnCall[len(fake.desireTaskArgsForCall)]
	fake.desireTaskArgsForCall = append(fake.desireTaskArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 string
		arg5 *models.TaskDefinition
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.DesireTaskStub
	fakeReturns := fake.desireTaskReturns
	fake.recordInvocation("DesireTask", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.desireTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInternalClient) DesireTaskCallCount() int {
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	return len(fake.desireTaskArgsForCall)
}

func (fake *FakeInternalClient) DesireTaskCalls(stub func(lager.Logger, string, string, string, *models.TaskDefinition) error) {
	fake.desireTaskMutex.Lock()
	defer fake.desireTaskMutex.Unlock()
	fake.DesireTaskStub = stub
}

func (fake *FakeInternalClient) DesireTaskArgsForCall(i int) (lager.Logger, string, string, string, *models.TaskDefinition) {
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	argsForCall := fake.desireTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeInternalClient) DesireTaskReturns(result1 error) {
	fake.desireTaskMutex.Lock()
	defer fake.desireTaskMutex.Unlock()
	fake.DesireTaskStub = nil
	fake.desireTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) DesireTaskReturnsOnCall(i int, result1 error) {
	fake.desireTaskMutex.Lock()
	defer fake.desireTaskMutex.Unlock()
	fake.DesireTaskStub = nil
	if fake.desireTaskReturnsOnCall == nil {
		fake.desireTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.desireTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) DesiredLRPByProcessGuid(arg1 lager.Logger, arg2 string, arg3 string) (*models.DesiredLRP, error) {
	fake.desiredLRPByProcessGuidMutex.Lock()
	ret, specificReturn := fake.desiredLRPByProcessGuidReturnsOnCall[len(fake.desiredLRPByProcessGuidArgsForCall)]
	fake.desiredLRPByProcessGuidArgsForCall = append(fake.desiredLRPByProcessGuidArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.DesiredLRPByProcessGuidStub
	fakeReturns := fake.desiredLRPByProcessGuidReturns
	fake.recordInvocation("DesiredLRPByProcessGuid", []interface{}{arg1, arg2, arg3})
	fake.desiredLRPByProcessGuidMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) DesiredLRPByProcessGuidCallCount() int {
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	return len(fake.desiredLRPByProcessGuidArgsForCall)
}

func (fake *FakeInternalClient) DesiredLRPByProcessGuidCalls(stub func(lager.Logger, string, string) (*models.DesiredLRP, error)) {
	fake.desiredLRPByProcessGuidMutex.Lock()
	defer fake.desiredLRPByProcessGuidMutex.Unlock()
	fake.DesiredLRPByProcessGuidStub = stub
}

func (fake *FakeInternalClient) DesiredLRPByProcessGuidArgsForCall(i int) (lager.Logger, string, string) {
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	argsForCall := fake.desiredLRPByProcessGuidArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) DesiredLRPByProcessGuidReturns(result1 *models.DesiredLRP, result2 error) {
	fake.desiredLRPByProcessGuidMutex.Lock()
	defer fake.desiredLRPByProcessGuidMutex.Unlock()
	fake.DesiredLRPByProcessGuidStub = nil
	fake.desiredLRPByProcessGuidReturns = struct {
		result1 *models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesiredLRPByProcessGuidReturnsOnCall(i int, result1 *models.DesiredLRP, result2 error) {
	fake.desiredLRPByProcessGuidMutex.Lock()
	defer fake.desiredLRPByProcessGuidMutex.Unlock()
	fake.DesiredLRPByProcessGuidStub = nil
	if fake.desiredLRPByProcessGuidReturnsOnCall == nil {
		fake.desiredLRPByProcessGuidReturnsOnCall = make(map[int]struct {
			result1 *models.DesiredLRP
			result2 error
		})
	}
	fake.desiredLRPByProcessGuidReturnsOnCall[i] = struct {
		result1 *models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesiredLRPRoutingInfos(arg1 lager.Logger, arg2 string, arg3 models.DesiredLRPFilter) ([]*models.DesiredLRP, error) {
	fake.desiredLRPRoutingInfosMutex.Lock()
	ret, specificReturn := fake.desiredLRPRoutingInfosReturnsOnCall[len(fake.desiredLRPRoutingInfosArgsForCall)]
	fake.desiredLRPRoutingInfosArgsForCall = append(fake.desiredLRPRoutingInfosArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 models.DesiredLRPFilter
	}{arg1, arg2, arg3})
	stub := fake.DesiredLRPRoutingInfosStub
	fakeReturns := fake.desiredLRPRoutingInfosReturns
	fake.recordInvocation("DesiredLRPRoutingInfos", []interface{}{arg1, arg2, arg3})
	fake.desiredLRPRoutingInfosMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) DesiredLRPRoutingInfosCallCount() int {
	fake.desiredLRPRoutingInfosMutex.RLock()
	defer fake.desiredLRPRoutingInfosMutex.RUnlock()
	return len(fake.desiredLRPRoutingInfosArgsForCall)
}

func (fake *FakeInternalClient) DesiredLRPRoutingInfosCalls(stub func(lager.Logger, string, models.DesiredLRPFilter) ([]*models.DesiredLRP, error)) {
	fake.desiredLRPRoutingInfosMutex.Lock()
	defer fake.desiredLRPRoutingInfosMutex.Unlock()
	fake.DesiredLRPRoutingInfosStub = stub
}

func (fake *FakeInternalClient) DesiredLRPRoutingInfosArgsForCall(i int) (lager.Logger, string, models.DesiredLRPFilter) {
	fake.desiredLRPRoutingInfosMutex.RLock()
	defer fake.desiredLRPRoutingInfosMutex.RUnlock()
	argsForCall := fake.desiredLRPRoutingInfosArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) DesiredLRPRoutingInfosReturns(result1 []*models.DesiredLRP, result2 error) {
	fake.desiredLRPRoutingInfosMutex.Lock()
	defer fake.desiredLRPRoutingInfosMutex.Unlock()
	fake.DesiredLRPRoutingInfosStub = nil
	fake.desiredLRPRoutingInfosReturns = struct {
		result1 []*models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesiredLRPRoutingInfosReturnsOnCall(i int, result1 []*models.DesiredLRP, result2 error) {
	fake.desiredLRPRoutingInfosMutex.Lock()
	defer fake.desiredLRPRoutingInfosMutex.Unlock()
	fake.DesiredLRPRoutingInfosStub = nil
	if fake.desiredLRPRoutingInfosReturnsOnCall == nil {
		fake.desiredLRPRoutingInfosReturnsOnCall = make(map[int]struct {
			result1 []*models.DesiredLRP
			result2 error
		})
	}
	fake.desiredLRPRoutingInfosReturnsOnCall[i] = struct {
		result1 []*models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfoByProcessGuid(arg1 lager.Logger, arg2 string, arg3 string) (*models.DesiredLRPSchedulingInfo, error) {
	fake.desiredLRPSchedulingInfoByProcessGuidMutex.Lock()
	ret, specificReturn := fake.desiredLRPSchedulingInfoByProcessGuidReturnsOnCall[len(fake.desiredLRPSchedulingInfoByProcessGuidArgsForCall)]
	fake.desiredLRPSchedulingInfoByProcessGuidArgsForCall = append(fake.desiredLRPSchedulingInfoByProcessGuidArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.DesiredLRPSchedulingInfoByProcessGuidStub
	fakeReturns := fake.desiredLRPSchedulingInfoByProcessGuidReturns
	fake.recordInvocation("DesiredLRPSchedulingInfoByProcessGuid", []interface{}{arg1, arg2, arg3})
	fake.desiredLRPSchedulingInfoByProcessGuidMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfoByProcessGuidCallCount() int {
	fake.desiredLRPSchedulingInfoByProcessGuidMutex.RLock()
	defer fake.desiredLRPSchedulingInfoByProcessGuidMutex.RUnlock()
	return len(fake.desiredLRPSchedulingInfoByProcessGuidArgsForCall)
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfoByProcessGuidCalls(stub func(lager.Logger, string, string) (*models.DesiredLRPSchedulingInfo, error)) {
	fake.desiredLRPSchedulingInfoByProcessGuidMutex.Lock()
	defer fake.desiredLRPSchedulingInfoByProcessGuidMutex.Unlock()
	fake.DesiredLRPSchedulingInfoByProcessGuidStub = stub
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfoByProcessGuidArgsForCall(i int) (lager.Logger, string, string) {
	fake.desiredLRPSchedulingInfoByProcessGuidMutex.RLock()
	defer fake.desiredLRPSchedulingInfoByProcessGuidMutex.RUnlock()
	argsForCall := fake.desiredLRPSchedulingInfoByProcessGuidArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfoByProcessGuidReturns(result1 *models.DesiredLRPSchedulingInfo, result2 error) {
	fake.desiredLRPSchedulingInfoByProcessGuidMutex.Lock()
	defer fake.desiredLRPSchedulingInfoByProcessGuidMutex.Unlock()
	fake.DesiredLRPSchedulingInfoByProcessGuidStub = nil
	fake.desiredLRPSchedulingInfoByProcessGuidReturns = struct {
		result1 *models.DesiredLRPSchedulingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfoByProcessGuidReturnsOnCall(i int, result1 *models.DesiredLRPSchedulingInfo, result2 error) {
	fake.desiredLRPSchedulingInfoByProcessGuidMutex.Lock()
	defer fake.desiredLRPSchedulingInfoByProcessGuidMutex.Unlock()
	fake.DesiredLRPSchedulingInfoByProcessGuidStub = nil
	if fake.desiredLRPSchedulingInfoByProcessGuidReturnsOnCall == nil {
		fake.desiredLRPSchedulingInfoByProcessGuidReturnsOnCall = make(map[int]struct {
			result1 *models.DesiredLRPSchedulingInfo
			result2 error
		})
	}
	fake.desiredLRPSchedulingInfoByProcessGuidReturnsOnCall[i] = struct {
		result1 *models.DesiredLRPSchedulingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfos(arg1 lager.Logger, arg2 string, arg3 models.DesiredLRPFilter) ([]*models.DesiredLRPSchedulingInfo, error) {
	fake.desiredLRPSchedulingInfosMutex.Lock()
	ret, specificReturn := fake.desiredLRPSchedulingInfosReturnsOnCall[len(fake.desiredLRPSchedulingInfosArgsForCall)]
	fake.desiredLRPSchedulingInfosArgsForCall = append(fake.desiredLRPSchedulingInfosArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 models.DesiredLRPFilter
	}{arg1, arg2, arg3})
	stub := fake.DesiredLRPSchedulingInfosStub
	fakeReturns := fake.desiredLRPSchedulingInfosReturns
	fake.recordInvocation("DesiredLRPSchedulingInfos", []interface{}{arg1, arg2, arg3})
	fake.desiredLRPSchedulingInfosMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfosCallCount() int {
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	return len(fake.desiredLRPSchedulingInfosArgsForCall)
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfosCalls(stub func(lager.Logger, string, models.DesiredLRPFilter) ([]*models.DesiredLRPSchedulingInfo, error)) {
	fake.desiredLRPSchedulingInfosMutex.Lock()
	defer fake.desiredLRPSchedulingInfosMutex.Unlock()
	fake.DesiredLRPSchedulingInfosStub = stub
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfosArgsForCall(i int) (lager.Logger, string, models.DesiredLRPFilter) {
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	argsForCall := fake.desiredLRPSchedulingInfosArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfosReturns(result1 []*models.DesiredLRPSchedulingInfo, result2 error) {
	fake.desiredLRPSchedulingInfosMutex.Lock()
	defer fake.desiredLRPSchedulingInfosMutex.Unlock()
	fake.DesiredLRPSchedulingInfosStub = nil
	fake.desiredLRPSchedulingInfosReturns = struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesiredLRPSchedulingInfosReturnsOnCall(i int, result1 []*models.DesiredLRPSchedulingInfo, result2 error) {
	fake.desiredLRPSchedulingInfosMutex.Lock()
	defer fake.desiredLRPSchedulingInfosMutex.Unlock()
	fake.DesiredLRPSchedulingInfosStub = nil
	if fake.desiredLRPSchedulingInfosReturnsOnCall == nil {
		fake.desiredLRPSchedulingInfosReturnsOnCall = make(map[int]struct {
			result1 []*models.DesiredLRPSchedulingInfo
			result2 error
		})
	}
	fake.desiredLRPSchedulingInfosReturnsOnCall[i] = struct {
		result1 []*models.DesiredLRPSchedulingInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesiredLRPs(arg1 lager.Logger, arg2 string, arg3 models.DesiredLRPFilter) ([]*models.DesiredLRP, error) {
	fake.desiredLRPsMutex.Lock()
	ret, specificReturn := fake.desiredLRPsReturnsOnCall[len(fake.desiredLRPsArgsForCall)]
	fake.desiredLRPsArgsForCall = append(fake.desiredLRPsArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 models.DesiredLRPFilter
	}{arg1, arg2, arg3})
	stub := fake.DesiredLRPsStub
	fakeReturns := fake.desiredLRPsReturns
	fake.recordInvocation("DesiredLRPs", []interface{}{arg1, arg2, arg3})
	fake.desiredLRPsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) DesiredLRPsCallCount() int {
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	return len(fake.desiredLRPsArgsForCall)
}

func (fake *FakeInternalClient) DesiredLRPsCalls(stub func(lager.Logger, string, models.DesiredLRPFilter) ([]*models.DesiredLRP, error)) {
	fake.desiredLRPsMutex.Lock()
	defer fake.desiredLRPsMutex.Unlock()
	fake.DesiredLRPsStub = stub
}

func (fake *FakeInternalClient) DesiredLRPsArgsForCall(i int) (lager.Logger, string, models.DesiredLRPFilter) {
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	argsForCall := fake.desiredLRPsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) DesiredLRPsReturns(result1 []*models.DesiredLRP, result2 error) {
	fake.desiredLRPsMutex.Lock()
	defer fake.desiredLRPsMutex.Unlock()
	fake.DesiredLRPsStub = nil
	fake.desiredLRPsReturns = struct {
		result1 []*models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DesiredLRPsReturnsOnCall(i int, result1 []*models.DesiredLRP, result2 error) {
	fake.desiredLRPsMutex.Lock()
	defer fake.desiredLRPsMutex.Unlock()
	fake.DesiredLRPsStub = nil
	if fake.desiredLRPsReturnsOnCall == nil {
		fake.desiredLRPsReturnsOnCall = make(map[int]struct {
			result1 []*models.DesiredLRP
			result2 error
		})
	}
	fake.desiredLRPsReturnsOnCall[i] = struct {
		result1 []*models.DesiredLRP
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) Domains(arg1 lager.Logger, arg2 string) ([]string, error) {
	fake.domainsMutex.Lock()
	ret, specificReturn := fake.domainsReturnsOnCall[len(fake.domainsArgsForCall)]
	fake.domainsArgsForCall = append(fake.domainsArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	stub := fake.DomainsStub
	fakeReturns := fake.domainsReturns
	fake.recordInvocation("Domains", []interface{}{arg1, arg2})
	fake.domainsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) DomainsCallCount() int {
	fake.domainsMutex.RLock()
	defer fake.domainsMutex.RUnlock()
	return len(fake.domainsArgsForCall)
}

func (fake *FakeInternalClient) DomainsCalls(stub func(lager.Logger, string) ([]string, error)) {
	fake.domainsMutex.Lock()
	defer fake.domainsMutex.Unlock()
	fake.DomainsStub = stub
}

func (fake *FakeInternalClient) DomainsArgsForCall(i int) (lager.Logger, string) {
	fake.domainsMutex.RLock()
	defer fake.domainsMutex.RUnlock()
	argsForCall := fake.domainsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) DomainsReturns(result1 []string, result2 error) {
	fake.domainsMutex.Lock()
	defer fake.domainsMutex.Unlock()
	fake.DomainsStub = nil
	fake.domainsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) DomainsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.domainsMutex.Lock()
	defer fake.domainsMutex.Unlock()
	fake.DomainsStub = nil
	if fake.domainsReturnsOnCall == nil {
		fake.domainsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.domainsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateClaimedActualLRP(arg1 lager.Logger, arg2 string, arg3 *models.ActualLRPKey, arg4 *models.ActualLRPInstanceKey) (bool, error) {
	fake.evacuateClaimedActualLRPMutex.Lock()
	ret, specificReturn := fake.evacuateClaimedActualLRPReturnsOnCall[len(fake.evacuateClaimedActualLRPArgsForCall)]
	fake.evacuateClaimedActualLRPArgsForCall = append(fake.evacuateClaimedActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3, arg4})
	stub := fake.EvacuateClaimedActualLRPStub
	fakeReturns := fake.evacuateClaimedActualLRPReturns
	fake.recordInvocation("EvacuateClaimedActualLRP", []interface{}{arg1, arg2, arg3, arg4})
	fake.evacuateClaimedActualLRPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) EvacuateClaimedActualLRPCallCount() int {
	fake.evacuateClaimedActualLRPMutex.RLock()
	defer fake.evacuateClaimedActualLRPMutex.RUnlock()
	return len(fake.evacuateClaimedActualLRPArgsForCall)
}

func (fake *FakeInternalClient) EvacuateClaimedActualLRPCalls(stub func(lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey) (bool, error)) {
	fake.evacuateClaimedActualLRPMutex.Lock()
	defer fake.evacuateClaimedActualLRPMutex.Unlock()
	fake.EvacuateClaimedActualLRPStub = stub
}

func (fake *FakeInternalClient) EvacuateClaimedActualLRPArgsForCall(i int) (lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.evacuateClaimedActualLRPMutex.RLock()
	defer fake.evacuateClaimedActualLRPMutex.RUnlock()
	argsForCall := fake.evacuateClaimedActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInternalClient) EvacuateClaimedActualLRPReturns(result1 bool, result2 error) {
	fake.evacuateClaimedActualLRPMutex.Lock()
	defer fake.evacuateClaimedActualLRPMutex.Unlock()
	fake.EvacuateClaimedActualLRPStub = nil
	fake.evacuateClaimedActualLRPReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateClaimedActualLRPReturnsOnCall(i int, result1 bool, result2 error) {
	fake.evacuateClaimedActualLRPMutex.Lock()
	defer fake.evacuateClaimedActualLRPMutex.Unlock()
	fake.EvacuateClaimedActualLRPStub = nil
	if fake.evacuateClaimedActualLRPReturnsOnCall == nil {
		fake.evacuateClaimedActualLRPReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.evacuateClaimedActualLRPReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateCrashedActualLRP(arg1 lager.Logger, arg2 string, arg3 *models.ActualLRPKey, arg4 *models.ActualLRPInstanceKey, arg5 string) (bool, error) {
	fake.evacuateCrashedActualLRPMutex.Lock()
	ret, specificReturn := fake.evacuateCrashedActualLRPReturnsOnCall[len(fake.evacuateCrashedActualLRPArgsForCall)]
	fake.evacuateCrashedActualLRPArgsForCall = append(fake.evacuateCrashedActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.EvacuateCrashedActualLRPStub
	fakeReturns := fake.evacuateCrashedActualLRPReturns
	fake.recordInvocation("EvacuateCrashedActualLRP", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.evacuateCrashedActualLRPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) EvacuateCrashedActualLRPCallCount() int {
	fake.evacuateCrashedActualLRPMutex.RLock()
	defer fake.evacuateCrashedActualLRPMutex.RUnlock()
	return len(fake.evacuateCrashedActualLRPArgsForCall)
}

func (fake *FakeInternalClient) EvacuateCrashedActualLRPCalls(stub func(lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) (bool, error)) {
	fake.evacuateCrashedActualLRPMutex.Lock()
	defer fake.evacuateCrashedActualLRPMutex.Unlock()
	fake.EvacuateCrashedActualLRPStub = stub
}

func (fake *FakeInternalClient) EvacuateCrashedActualLRPArgsForCall(i int) (lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey, string) {
	fake.evacuateCrashedActualLRPMutex.RLock()
	defer fake.evacuateCrashedActualLRPMutex.RUnlock()
	argsForCall := fake.evacuateCrashedActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeInternalClient) EvacuateCrashedActualLRPReturns(result1 bool, result2 error) {
	fake.evacuateCrashedActualLRPMutex.Lock()
	defer fake.evacuateCrashedActualLRPMutex.Unlock()
	fake.EvacuateCrashedActualLRPStub = nil
	fake.evacuateCrashedActualLRPReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateCrashedActualLRPReturnsOnCall(i int, result1 bool, result2 error) {
	fake.evacuateCrashedActualLRPMutex.Lock()
	defer fake.evacuateCrashedActualLRPMutex.Unlock()
	fake.EvacuateCrashedActualLRPStub = nil
	if fake.evacuateCrashedActualLRPReturnsOnCall == nil {
		fake.evacuateCrashedActualLRPReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.evacuateCrashedActualLRPReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateRunningActualLRP(arg1 lager.Logger, arg2 string, arg3 *models.ActualLRPKey, arg4 *models.ActualLRPInstanceKey, arg5 *models.ActualLRPNetInfo, arg6 []*models.ActualLRPInternalRoute, arg7 map[string]string, arg8 bool, arg9 string) (bool, error) {
	var arg6Copy []*models.ActualLRPInternalRoute
	if arg6 != nil {
		arg6Copy = make([]*models.ActualLRPInternalRoute, len(arg6))
		copy(arg6Copy, arg6)
	}
	fake.evacuateRunningActualLRPMutex.Lock()
	ret, specificReturn := fake.evacuateRunningActualLRPReturnsOnCall[len(fake.evacuateRunningActualLRPArgsForCall)]
	fake.evacuateRunningActualLRPArgsForCall = append(fake.evacuateRunningActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
		arg5 *models.ActualLRPNetInfo
		arg6 []*models.ActualLRPInternalRoute
		arg7 map[string]string
		arg8 bool
		arg9 string
	}{arg1, arg2, arg3, arg4, arg5, arg6Copy, arg7, arg8, arg9})
	stub := fake.EvacuateRunningActualLRPStub
	fakeReturns := fake.evacuateRunningActualLRPReturns
	fake.recordInvocation("EvacuateRunningActualLRP", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6Copy, arg7, arg8, arg9})
	fake.evacuateRunningActualLRPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) EvacuateRunningActualLRPCallCount() int {
	fake.evacuateRunningActualLRPMutex.RLock()
	defer fake.evacuateRunningActualLRPMutex.RUnlock()
	return len(fake.evacuateRunningActualLRPArgsForCall)
}

func (fake *FakeInternalClient) EvacuateRunningActualLRPCalls(stub func(lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo, []*models.ActualLRPInternalRoute, map[string]string, bool, string) (bool, error)) {
	fake.evacuateRunningActualLRPMutex.Lock()
	defer fake.evacuateRunningActualLRPMutex.Unlock()
	fake.EvacuateRunningActualLRPStub = stub
}

func (fake *FakeInternalClient) EvacuateRunningActualLRPArgsForCall(i int) (lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo, []*models.ActualLRPInternalRoute, map[string]string, bool, string) {
	fake.evacuateRunningActualLRPMutex.RLock()
	defer fake.evacuateRunningActualLRPMutex.RUnlock()
	argsForCall := fake.evacuateRunningActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8, argsForCall.arg9
}

func (fake *FakeInternalClient) EvacuateRunningActualLRPReturns(result1 bool, result2 error) {
	fake.evacuateRunningActualLRPMutex.Lock()
	defer fake.evacuateRunningActualLRPMutex.Unlock()
	fake.EvacuateRunningActualLRPStub = nil
	fake.evacuateRunningActualLRPReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateRunningActualLRPReturnsOnCall(i int, result1 bool, result2 error) {
	fake.evacuateRunningActualLRPMutex.Lock()
	defer fake.evacuateRunningActualLRPMutex.Unlock()
	fake.EvacuateRunningActualLRPStub = nil
	if fake.evacuateRunningActualLRPReturnsOnCall == nil {
		fake.evacuateRunningActualLRPReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.evacuateRunningActualLRPReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateStoppedActualLRP(arg1 lager.Logger, arg2 string, arg3 *models.ActualLRPKey, arg4 *models.ActualLRPInstanceKey) (bool, error) {
	fake.evacuateStoppedActualLRPMutex.Lock()
	ret, specificReturn := fake.evacuateStoppedActualLRPReturnsOnCall[len(fake.evacuateStoppedActualLRPArgsForCall)]
	fake.evacuateStoppedActualLRPArgsForCall = append(fake.evacuateStoppedActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3, arg4})
	stub := fake.EvacuateStoppedActualLRPStub
	fakeReturns := fake.evacuateStoppedActualLRPReturns
	fake.recordInvocation("EvacuateStoppedActualLRP", []interface{}{arg1, arg2, arg3, arg4})
	fake.evacuateStoppedActualLRPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) EvacuateStoppedActualLRPCallCount() int {
	fake.evacuateStoppedActualLRPMutex.RLock()
	defer fake.evacuateStoppedActualLRPMutex.RUnlock()
	return len(fake.evacuateStoppedActualLRPArgsForCall)
}

func (fake *FakeInternalClient) EvacuateStoppedActualLRPCalls(stub func(lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey) (bool, error)) {
	fake.evacuateStoppedActualLRPMutex.Lock()
	defer fake.evacuateStoppedActualLRPMutex.Unlock()
	fake.EvacuateStoppedActualLRPStub = stub
}

func (fake *FakeInternalClient) EvacuateStoppedActualLRPArgsForCall(i int) (lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.evacuateStoppedActualLRPMutex.RLock()
	defer fake.evacuateStoppedActualLRPMutex.RUnlock()
	argsForCall := fake.evacuateStoppedActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInternalClient) EvacuateStoppedActualLRPReturns(result1 bool, result2 error) {
	fake.evacuateStoppedActualLRPMutex.Lock()
	defer fake.evacuateStoppedActualLRPMutex.Unlock()
	fake.EvacuateStoppedActualLRPStub = nil
	fake.evacuateStoppedActualLRPReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) EvacuateStoppedActualLRPReturnsOnCall(i int, result1 bool, result2 error) {
	fake.evacuateStoppedActualLRPMutex.Lock()
	defer fake.evacuateStoppedActualLRPMutex.Unlock()
	fake.EvacuateStoppedActualLRPStub = nil
	if fake.evacuateStoppedActualLRPReturnsOnCall == nil {
		fake.evacuateStoppedActualLRPReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.evacuateStoppedActualLRPReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) FailActualLRP(arg1 lager.Logger, arg2 string, arg3 *models.ActualLRPKey, arg4 string) error {
	fake.failActualLRPMutex.Lock()
	ret, specificReturn := fake.failActualLRPReturnsOnCall[len(fake.failActualLRPArgsForCall)]
	fake.failActualLRPArgsForCall = append(fake.failActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.FailActualLRPStub
	fakeReturns := fake.failActualLRPReturns
	fake.recordInvocation("FailActualLRP", []interface{}{arg1, arg2, arg3, arg4})
	fake.failActualLRPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInternalClient) FailActualLRPCallCount() int {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	return len(fake.failActualLRPArgsForCall)
}

func (fake *FakeInternalClient) FailActualLRPCalls(stub func(lager.Logger, string, *models.ActualLRPKey, string) error) {
	fake.failActualLRPMutex.Lock()
	defer fake.failActualLRPMutex.Unlock()
	fake.FailActualLRPStub = stub
}

func (fake *FakeInternalClient) FailActualLRPArgsForCall(i int) (lager.Logger, string, *models.ActualLRPKey, string) {
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	argsForCall := fake.failActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInternalClient) FailActualLRPReturns(result1 error) {
	fake.failActualLRPMutex.Lock()
	defer fake.failActualLRPMutex.Unlock()
	fake.FailActualLRPStub = nil
	fake.failActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) FailActualLRPReturnsOnCall(i int, result1 error) {
	fake.failActualLRPMutex.Lock()
	defer fake.failActualLRPMutex.Unlock()
	fake.FailActualLRPStub = nil
	if fake.failActualLRPReturnsOnCall == nil {
		fake.failActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.failActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) FailTask(arg1 lager.Logger, arg2 string, arg3 string, arg4 string) error {
	fake.failTaskMutex.Lock()
	ret, specificReturn := fake.failTaskReturnsOnCall[len(fake.failTaskArgsForCall)]
	fake.failTaskArgsForCall = append(fake.failTaskArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.FailTaskStub
	fakeReturns := fake.failTaskReturns
	fake.recordInvocation("FailTask", []interface{}{arg1, arg2, arg3, arg4})
	fake.failTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInternalClient) FailTaskCallCount() int {
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	return len(fake.failTaskArgsForCall)
}

func (fake *FakeInternalClient) FailTaskCalls(stub func(lager.Logger, string, string, string) error) {
	fake.failTaskMutex.Lock()
	defer fake.failTaskMutex.Unlock()
	fake.FailTaskStub = stub
}

func (fake *FakeInternalClient) FailTaskArgsForCall(i int) (lager.Logger, string, string, string) {
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	argsForCall := fake.failTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInternalClient) FailTaskReturns(result1 error) {
	fake.failTaskMutex.Lock()
	defer fake.failTaskMutex.Unlock()
	fake.FailTaskStub = nil
	fake.failTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) FailTaskReturnsOnCall(i int, result1 error) {
	fake.failTaskMutex.Lock()
	defer fake.failTaskMutex.Unlock()
	fake.FailTaskStub = nil
	if fake.failTaskReturnsOnCall == nil {
		fake.failTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.failTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) Ping(arg1 lager.Logger, arg2 string) bool {
	fake.pingMutex.Lock()
	ret, specificReturn := fake.pingReturnsOnCall[len(fake.pingArgsForCall)]
	fake.pingArgsForCall = append(fake.pingArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	stub := fake.PingStub
	fakeReturns := fake.pingReturns
	fake.recordInvocation("Ping", []interface{}{arg1, arg2})
	fake.pingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInternalClient) PingCallCount() int {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	return len(fake.pingArgsForCall)
}

func (fake *FakeInternalClient) PingCalls(stub func(lager.Logger, string) bool) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = stub
}

func (fake *FakeInternalClient) PingArgsForCall(i int) (lager.Logger, string) {
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	argsForCall := fake.pingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) PingReturns(result1 bool) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	fake.pingReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeInternalClient) PingReturnsOnCall(i int, result1 bool) {
	fake.pingMutex.Lock()
	defer fake.pingMutex.Unlock()
	fake.PingStub = nil
	if fake.pingReturnsOnCall == nil {
		fake.pingReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.pingReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeInternalClient) RejectTask(arg1 lager.Logger, arg2 string, arg3 string, arg4 string) error {
	fake.rejectTaskMutex.Lock()
	ret, specificReturn := fake.rejectTaskReturnsOnCall[len(fake.rejectTaskArgsForCall)]
	fake.rejectTaskArgsForCall = append(fake.rejectTaskArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.RejectTaskStub
	fakeReturns := fake.rejectTaskReturns
	fake.recordInvocation("RejectTask", []interface{}{arg1, arg2, arg3, arg4})
	fake.rejectTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInternalClient) RejectTaskCallCount() int {
	fake.rejectTaskMutex.RLock()
	defer fake.rejectTaskMutex.RUnlock()
	return len(fake.rejectTaskArgsForCall)
}

func (fake *FakeInternalClient) RejectTaskCalls(stub func(lager.Logger, string, string, string) error) {
	fake.rejectTaskMutex.Lock()
	defer fake.rejectTaskMutex.Unlock()
	fake.RejectTaskStub = stub
}

func (fake *FakeInternalClient) RejectTaskArgsForCall(i int) (lager.Logger, string, string, string) {
	fake.rejectTaskMutex.RLock()
	defer fake.rejectTaskMutex.RUnlock()
	argsForCall := fake.rejectTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInternalClient) RejectTaskReturns(result1 error) {
	fake.rejectTaskMutex.Lock()
	defer fake.rejectTaskMutex.Unlock()
	fake.RejectTaskStub = nil
	fake.rejectTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RejectTaskReturnsOnCall(i int, result1 error) {
	fake.rejectTaskMutex.Lock()
	defer fake.rejectTaskMutex.Unlock()
	fake.RejectTaskStub = nil
	if fake.rejectTaskReturnsOnCall == nil {
		fake.rejectTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.rejectTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RemoveActualLRP(arg1 lager.Logger, arg2 string, arg3 *models.ActualLRPKey, arg4 *models.ActualLRPInstanceKey) error {
	fake.removeActualLRPMutex.Lock()
	ret, specificReturn := fake.removeActualLRPReturnsOnCall[len(fake.removeActualLRPArgsForCall)]
	fake.removeActualLRPArgsForCall = append(fake.removeActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3, arg4})
	stub := fake.RemoveActualLRPStub
	fakeReturns := fake.removeActualLRPReturns
	fake.recordInvocation("RemoveActualLRP", []interface{}{arg1, arg2, arg3, arg4})
	fake.removeActualLRPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInternalClient) RemoveActualLRPCallCount() int {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	return len(fake.removeActualLRPArgsForCall)
}

func (fake *FakeInternalClient) RemoveActualLRPCalls(stub func(lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey) error) {
	fake.removeActualLRPMutex.Lock()
	defer fake.removeActualLRPMutex.Unlock()
	fake.RemoveActualLRPStub = stub
}

func (fake *FakeInternalClient) RemoveActualLRPArgsForCall(i int) (lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	argsForCall := fake.removeActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInternalClient) RemoveActualLRPReturns(result1 error) {
	fake.removeActualLRPMutex.Lock()
	defer fake.removeActualLRPMutex.Unlock()
	fake.RemoveActualLRPStub = nil
	fake.removeActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RemoveActualLRPReturnsOnCall(i int, result1 error) {
	fake.removeActualLRPMutex.Lock()
	defer fake.removeActualLRPMutex.Unlock()
	fake.RemoveActualLRPStub = nil
	if fake.removeActualLRPReturnsOnCall == nil {
		fake.removeActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RemoveDesiredLRP(arg1 lager.Logger, arg2 string, arg3 string) error {
	fake.removeDesiredLRPMutex.Lock()
	ret, specificReturn := fake.removeDesiredLRPReturnsOnCall[len(fake.removeDesiredLRPArgsForCall)]
	fake.removeDesiredLRPArgsForCall = append(fake.removeDesiredLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.RemoveDesiredLRPStub
	fakeReturns := fake.removeDesiredLRPReturns
	fake.recordInvocation("RemoveDesiredLRP", []interface{}{arg1, arg2, arg3})
	fake.removeDesiredLRPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInternalClient) RemoveDesiredLRPCallCount() int {
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	return len(fake.removeDesiredLRPArgsForCall)
}

func (fake *FakeInternalClient) RemoveDesiredLRPCalls(stub func(lager.Logger, string, string) error) {
	fake.removeDesiredLRPMutex.Lock()
	defer fake.removeDesiredLRPMutex.Unlock()
	fake.RemoveDesiredLRPStub = stub
}

func (fake *FakeInternalClient) RemoveDesiredLRPArgsForCall(i int) (lager.Logger, string, string) {
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	argsForCall := fake.removeDesiredLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) RemoveDesiredLRPReturns(result1 error) {
	fake.removeDesiredLRPMutex.Lock()
	defer fake.removeDesiredLRPMutex.Unlock()
	fake.RemoveDesiredLRPStub = nil
	fake.removeDesiredLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RemoveDesiredLRPReturnsOnCall(i int, result1 error) {
	fake.removeDesiredLRPMutex.Lock()
	defer fake.removeDesiredLRPMutex.Unlock()
	fake.RemoveDesiredLRPStub = nil
	if fake.removeDesiredLRPReturnsOnCall == nil {
		fake.removeDesiredLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeDesiredLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RemoveEvacuatingActualLRP(arg1 lager.Logger, arg2 string, arg3 *models.ActualLRPKey, arg4 *models.ActualLRPInstanceKey) error {
	fake.removeEvacuatingActualLRPMutex.Lock()
	ret, specificReturn := fake.removeEvacuatingActualLRPReturnsOnCall[len(fake.removeEvacuatingActualLRPArgsForCall)]
	fake.removeEvacuatingActualLRPArgsForCall = append(fake.removeEvacuatingActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
	}{arg1, arg2, arg3, arg4})
	stub := fake.RemoveEvacuatingActualLRPStub
	fakeReturns := fake.removeEvacuatingActualLRPReturns
	fake.recordInvocation("RemoveEvacuatingActualLRP", []interface{}{arg1, arg2, arg3, arg4})
	fake.removeEvacuatingActualLRPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInternalClient) RemoveEvacuatingActualLRPCallCount() int {
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	return len(fake.removeEvacuatingActualLRPArgsForCall)
}

func (fake *FakeInternalClient) RemoveEvacuatingActualLRPCalls(stub func(lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey) error) {
	fake.removeEvacuatingActualLRPMutex.Lock()
	defer fake.removeEvacuatingActualLRPMutex.Unlock()
	fake.RemoveEvacuatingActualLRPStub = stub
}

func (fake *FakeInternalClient) RemoveEvacuatingActualLRPArgsForCall(i int) (lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey) {
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	argsForCall := fake.removeEvacuatingActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInternalClient) RemoveEvacuatingActualLRPReturns(result1 error) {
	fake.removeEvacuatingActualLRPMutex.Lock()
	defer fake.removeEvacuatingActualLRPMutex.Unlock()
	fake.RemoveEvacuatingActualLRPStub = nil
	fake.removeEvacuatingActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RemoveEvacuatingActualLRPReturnsOnCall(i int, result1 error) {
	fake.removeEvacuatingActualLRPMutex.Lock()
	defer fake.removeEvacuatingActualLRPMutex.Unlock()
	fake.RemoveEvacuatingActualLRPStub = nil
	if fake.removeEvacuatingActualLRPReturnsOnCall == nil {
		fake.removeEvacuatingActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeEvacuatingActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) ResolvingTask(arg1 lager.Logger, arg2 string, arg3 string) error {
	fake.resolvingTaskMutex.Lock()
	ret, specificReturn := fake.resolvingTaskReturnsOnCall[len(fake.resolvingTaskArgsForCall)]
	fake.resolvingTaskArgsForCall = append(fake.resolvingTaskArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ResolvingTaskStub
	fakeReturns := fake.resolvingTaskReturns
	fake.recordInvocation("ResolvingTask", []interface{}{arg1, arg2, arg3})
	fake.resolvingTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInternalClient) ResolvingTaskCallCount() int {
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	return len(fake.resolvingTaskArgsForCall)
}

func (fake *FakeInternalClient) ResolvingTaskCalls(stub func(lager.Logger, string, string) error) {
	fake.resolvingTaskMutex.Lock()
	defer fake.resolvingTaskMutex.Unlock()
	fake.ResolvingTaskStub = stub
}

func (fake *FakeInternalClient) ResolvingTaskArgsForCall(i int) (lager.Logger, string, string) {
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	argsForCall := fake.resolvingTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) ResolvingTaskReturns(result1 error) {
	fake.resolvingTaskMutex.Lock()
	defer fake.resolvingTaskMutex.Unlock()
	fake.ResolvingTaskStub = nil
	fake.resolvingTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) ResolvingTaskReturnsOnCall(i int, result1 error) {
	fake.resolvingTaskMutex.Lock()
	defer fake.resolvingTaskMutex.Unlock()
	fake.ResolvingTaskStub = nil
	if fake.resolvingTaskReturnsOnCall == nil {
		fake.resolvingTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resolvingTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RetireActualLRP(arg1 lager.Logger, arg2 string, arg3 *models.ActualLRPKey) error {
	fake.retireActualLRPMutex.Lock()
	ret, specificReturn := fake.retireActualLRPReturnsOnCall[len(fake.retireActualLRPArgsForCall)]
	fake.retireActualLRPArgsForCall = append(fake.retireActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
	}{arg1, arg2, arg3})
	stub := fake.RetireActualLRPStub
	fakeReturns := fake.retireActualLRPReturns
	fake.recordInvocation("RetireActualLRP", []interface{}{arg1, arg2, arg3})
	fake.retireActualLRPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInternalClient) RetireActualLRPCallCount() int {
	fake.retireActualLRPMutex.RLock()
	defer fake.retireActualLRPMutex.RUnlock()
	return len(fake.retireActualLRPArgsForCall)
}

func (fake *FakeInternalClient) RetireActualLRPCalls(stub func(lager.Logger, string, *models.ActualLRPKey) error) {
	fake.retireActualLRPMutex.Lock()
	defer fake.retireActualLRPMutex.Unlock()
	fake.RetireActualLRPStub = stub
}

func (fake *FakeInternalClient) RetireActualLRPArgsForCall(i int) (lager.Logger, string, *models.ActualLRPKey) {
	fake.retireActualLRPMutex.RLock()
	defer fake.retireActualLRPMutex.RUnlock()
	argsForCall := fake.retireActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) RetireActualLRPReturns(result1 error) {
	fake.retireActualLRPMutex.Lock()
	defer fake.retireActualLRPMutex.Unlock()
	fake.RetireActualLRPStub = nil
	fake.retireActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) RetireActualLRPReturnsOnCall(i int, result1 error) {
	fake.retireActualLRPMutex.Lock()
	defer fake.retireActualLRPMutex.Unlock()
	fake.RetireActualLRPStub = nil
	if fake.retireActualLRPReturnsOnCall == nil {
		fake.retireActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.retireActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) StartActualLRP(arg1 lager.Logger, arg2 string, arg3 *models.ActualLRPKey, arg4 *models.ActualLRPInstanceKey, arg5 *models.ActualLRPNetInfo, arg6 []*models.ActualLRPInternalRoute, arg7 map[string]string, arg8 bool, arg9 string) error {
	var arg6Copy []*models.ActualLRPInternalRoute
	if arg6 != nil {
		arg6Copy = make([]*models.ActualLRPInternalRoute, len(arg6))
		copy(arg6Copy, arg6)
	}
	fake.startActualLRPMutex.Lock()
	ret, specificReturn := fake.startActualLRPReturnsOnCall[len(fake.startActualLRPArgsForCall)]
	fake.startActualLRPArgsForCall = append(fake.startActualLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 *models.ActualLRPKey
		arg4 *models.ActualLRPInstanceKey
		arg5 *models.ActualLRPNetInfo
		arg6 []*models.ActualLRPInternalRoute
		arg7 map[string]string
		arg8 bool
		arg9 string
	}{arg1, arg2, arg3, arg4, arg5, arg6Copy, arg7, arg8, arg9})
	stub := fake.StartActualLRPStub
	fakeReturns := fake.startActualLRPReturns
	fake.recordInvocation("StartActualLRP", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6Copy, arg7, arg8, arg9})
	fake.startActualLRPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInternalClient) StartActualLRPCallCount() int {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	return len(fake.startActualLRPArgsForCall)
}

func (fake *FakeInternalClient) StartActualLRPCalls(stub func(lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo, []*models.ActualLRPInternalRoute, map[string]string, bool, string) error) {
	fake.startActualLRPMutex.Lock()
	defer fake.startActualLRPMutex.Unlock()
	fake.StartActualLRPStub = stub
}

func (fake *FakeInternalClient) StartActualLRPArgsForCall(i int) (lager.Logger, string, *models.ActualLRPKey, *models.ActualLRPInstanceKey, *models.ActualLRPNetInfo, []*models.ActualLRPInternalRoute, map[string]string, bool, string) {
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	argsForCall := fake.startActualLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8, argsForCall.arg9
}

func (fake *FakeInternalClient) StartActualLRPReturns(result1 error) {
	fake.startActualLRPMutex.Lock()
	defer fake.startActualLRPMutex.Unlock()
	fake.StartActualLRPStub = nil
	fake.startActualLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) StartActualLRPReturnsOnCall(i int, result1 error) {
	fake.startActualLRPMutex.Lock()
	defer fake.startActualLRPMutex.Unlock()
	fake.StartActualLRPStub = nil
	if fake.startActualLRPReturnsOnCall == nil {
		fake.startActualLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startActualLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) StartTask(arg1 lager.Logger, arg2 string, arg3 string, arg4 string) (bool, error) {
	fake.startTaskMutex.Lock()
	ret, specificReturn := fake.startTaskReturnsOnCall[len(fake.startTaskArgsForCall)]
	fake.startTaskArgsForCall = append(fake.startTaskArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.StartTaskStub
	fakeReturns := fake.startTaskReturns
	fake.recordInvocation("StartTask", []interface{}{arg1, arg2, arg3, arg4})
	fake.startTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) StartTaskCallCount() int {
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	return len(fake.startTaskArgsForCall)
}

func (fake *FakeInternalClient) StartTaskCalls(stub func(lager.Logger, string, string, string) (bool, error)) {
	fake.startTaskMutex.Lock()
	defer fake.startTaskMutex.Unlock()
	fake.StartTaskStub = stub
}

func (fake *FakeInternalClient) StartTaskArgsForCall(i int) (lager.Logger, string, string, string) {
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	argsForCall := fake.startTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInternalClient) StartTaskReturns(result1 bool, result2 error) {
	fake.startTaskMutex.Lock()
	defer fake.startTaskMutex.Unlock()
	fake.StartTaskStub = nil
	fake.startTaskReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) StartTaskReturnsOnCall(i int, result1 bool, result2 error) {
	fake.startTaskMutex.Lock()
	defer fake.startTaskMutex.Unlock()
	fake.StartTaskStub = nil
	if fake.startTaskReturnsOnCall == nil {
		fake.startTaskReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.startTaskReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToEvents(arg1 lager.Logger) (events.EventSource, error) {
	fake.subscribeToEventsMutex.Lock()
	ret, specificReturn := fake.subscribeToEventsReturnsOnCall[len(fake.subscribeToEventsArgsForCall)]
	fake.subscribeToEventsArgsForCall = append(fake.subscribeToEventsArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	stub := fake.SubscribeToEventsStub
	fakeReturns := fake.subscribeToEventsReturns
	fake.recordInvocation("SubscribeToEvents", []interface{}{arg1})
	fake.subscribeToEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) SubscribeToEventsCallCount() int {
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	return len(fake.subscribeToEventsArgsForCall)
}

func (fake *FakeInternalClient) SubscribeToEventsCalls(stub func(lager.Logger) (events.EventSource, error)) {
	fake.subscribeToEventsMutex.Lock()
	defer fake.subscribeToEventsMutex.Unlock()
	fake.SubscribeToEventsStub = stub
}

func (fake *FakeInternalClient) SubscribeToEventsArgsForCall(i int) lager.Logger {
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	argsForCall := fake.subscribeToEventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeInternalClient) SubscribeToEventsReturns(result1 events.EventSource, result2 error) {
	fake.subscribeToEventsMutex.Lock()
	defer fake.subscribeToEventsMutex.Unlock()
	fake.SubscribeToEventsStub = nil
	fake.subscribeToEventsReturns = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToEventsReturnsOnCall(i int, result1 events.EventSource, result2 error) {
	fake.subscribeToEventsMutex.Lock()
	defer fake.subscribeToEventsMutex.Unlock()
	fake.SubscribeToEventsStub = nil
	if fake.subscribeToEventsReturnsOnCall == nil {
		fake.subscribeToEventsReturnsOnCall = make(map[int]struct {
			result1 events.EventSource
			result2 error
		})
	}
	fake.subscribeToEventsReturnsOnCall[i] = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToEventsByCellID(arg1 lager.Logger, arg2 string) (events.EventSource, error) {
	fake.subscribeToEventsByCellIDMutex.Lock()
	ret, specificReturn := fake.subscribeToEventsByCellIDReturnsOnCall[len(fake.subscribeToEventsByCellIDArgsForCall)]
	fake.subscribeToEventsByCellIDArgsForCall = append(fake.subscribeToEventsByCellIDArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	stub := fake.SubscribeToEventsByCellIDStub
	fakeReturns := fake.subscribeToEventsByCellIDReturns
	fake.recordInvocation("SubscribeToEventsByCellID", []interface{}{arg1, arg2})
	fake.subscribeToEventsByCellIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) SubscribeToEventsByCellIDCallCount() int {
	fake.subscribeToEventsByCellIDMutex.RLock()
	defer fake.subscribeToEventsByCellIDMutex.RUnlock()
	return len(fake.subscribeToEventsByCellIDArgsForCall)
}

func (fake *FakeInternalClient) SubscribeToEventsByCellIDCalls(stub func(lager.Logger, string) (events.EventSource, error)) {
	fake.subscribeToEventsByCellIDMutex.Lock()
	defer fake.subscribeToEventsByCellIDMutex.Unlock()
	fake.SubscribeToEventsByCellIDStub = stub
}

func (fake *FakeInternalClient) SubscribeToEventsByCellIDArgsForCall(i int) (lager.Logger, string) {
	fake.subscribeToEventsByCellIDMutex.RLock()
	defer fake.subscribeToEventsByCellIDMutex.RUnlock()
	argsForCall := fake.subscribeToEventsByCellIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) SubscribeToEventsByCellIDReturns(result1 events.EventSource, result2 error) {
	fake.subscribeToEventsByCellIDMutex.Lock()
	defer fake.subscribeToEventsByCellIDMutex.Unlock()
	fake.SubscribeToEventsByCellIDStub = nil
	fake.subscribeToEventsByCellIDReturns = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToEventsByCellIDReturnsOnCall(i int, result1 events.EventSource, result2 error) {
	fake.subscribeToEventsByCellIDMutex.Lock()
	defer fake.subscribeToEventsByCellIDMutex.Unlock()
	fake.SubscribeToEventsByCellIDStub = nil
	if fake.subscribeToEventsByCellIDReturnsOnCall == nil {
		fake.subscribeToEventsByCellIDReturnsOnCall = make(map[int]struct {
			result1 events.EventSource
			result2 error
		})
	}
	fake.subscribeToEventsByCellIDReturnsOnCall[i] = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToInstanceEvents(arg1 lager.Logger) (events.EventSource, error) {
	fake.subscribeToInstanceEventsMutex.Lock()
	ret, specificReturn := fake.subscribeToInstanceEventsReturnsOnCall[len(fake.subscribeToInstanceEventsArgsForCall)]
	fake.subscribeToInstanceEventsArgsForCall = append(fake.subscribeToInstanceEventsArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	stub := fake.SubscribeToInstanceEventsStub
	fakeReturns := fake.subscribeToInstanceEventsReturns
	fake.recordInvocation("SubscribeToInstanceEvents", []interface{}{arg1})
	fake.subscribeToInstanceEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsCallCount() int {
	fake.subscribeToInstanceEventsMutex.RLock()
	defer fake.subscribeToInstanceEventsMutex.RUnlock()
	return len(fake.subscribeToInstanceEventsArgsForCall)
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsCalls(stub func(lager.Logger) (events.EventSource, error)) {
	fake.subscribeToInstanceEventsMutex.Lock()
	defer fake.subscribeToInstanceEventsMutex.Unlock()
	fake.SubscribeToInstanceEventsStub = stub
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsArgsForCall(i int) lager.Logger {
	fake.subscribeToInstanceEventsMutex.RLock()
	defer fake.subscribeToInstanceEventsMutex.RUnlock()
	argsForCall := fake.subscribeToInstanceEventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsReturns(result1 events.EventSource, result2 error) {
	fake.subscribeToInstanceEventsMutex.Lock()
	defer fake.subscribeToInstanceEventsMutex.Unlock()
	fake.SubscribeToInstanceEventsStub = nil
	fake.subscribeToInstanceEventsReturns = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsReturnsOnCall(i int, result1 events.EventSource, result2 error) {
	fake.subscribeToInstanceEventsMutex.Lock()
	defer fake.subscribeToInstanceEventsMutex.Unlock()
	fake.SubscribeToInstanceEventsStub = nil
	if fake.subscribeToInstanceEventsReturnsOnCall == nil {
		fake.subscribeToInstanceEventsReturnsOnCall = make(map[int]struct {
			result1 events.EventSource
			result2 error
		})
	}
	fake.subscribeToInstanceEventsReturnsOnCall[i] = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsByCellID(arg1 lager.Logger, arg2 string) (events.EventSource, error) {
	fake.subscribeToInstanceEventsByCellIDMutex.Lock()
	ret, specificReturn := fake.subscribeToInstanceEventsByCellIDReturnsOnCall[len(fake.subscribeToInstanceEventsByCellIDArgsForCall)]
	fake.subscribeToInstanceEventsByCellIDArgsForCall = append(fake.subscribeToInstanceEventsByCellIDArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	stub := fake.SubscribeToInstanceEventsByCellIDStub
	fakeReturns := fake.subscribeToInstanceEventsByCellIDReturns
	fake.recordInvocation("SubscribeToInstanceEventsByCellID", []interface{}{arg1, arg2})
	fake.subscribeToInstanceEventsByCellIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsByCellIDCallCount() int {
	fake.subscribeToInstanceEventsByCellIDMutex.RLock()
	defer fake.subscribeToInstanceEventsByCellIDMutex.RUnlock()
	return len(fake.subscribeToInstanceEventsByCellIDArgsForCall)
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsByCellIDCalls(stub func(lager.Logger, string) (events.EventSource, error)) {
	fake.subscribeToInstanceEventsByCellIDMutex.Lock()
	defer fake.subscribeToInstanceEventsByCellIDMutex.Unlock()
	fake.SubscribeToInstanceEventsByCellIDStub = stub
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsByCellIDArgsForCall(i int) (lager.Logger, string) {
	fake.subscribeToInstanceEventsByCellIDMutex.RLock()
	defer fake.subscribeToInstanceEventsByCellIDMutex.RUnlock()
	argsForCall := fake.subscribeToInstanceEventsByCellIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsByCellIDReturns(result1 events.EventSource, result2 error) {
	fake.subscribeToInstanceEventsByCellIDMutex.Lock()
	defer fake.subscribeToInstanceEventsByCellIDMutex.Unlock()
	fake.SubscribeToInstanceEventsByCellIDStub = nil
	fake.subscribeToInstanceEventsByCellIDReturns = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToInstanceEventsByCellIDReturnsOnCall(i int, result1 events.EventSource, result2 error) {
	fake.subscribeToInstanceEventsByCellIDMutex.Lock()
	defer fake.subscribeToInstanceEventsByCellIDMutex.Unlock()
	fake.SubscribeToInstanceEventsByCellIDStub = nil
	if fake.subscribeToInstanceEventsByCellIDReturnsOnCall == nil {
		fake.subscribeToInstanceEventsByCellIDReturnsOnCall = make(map[int]struct {
			result1 events.EventSource
			result2 error
		})
	}
	fake.subscribeToInstanceEventsByCellIDReturnsOnCall[i] = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToTaskEvents(arg1 lager.Logger) (events.EventSource, error) {
	fake.subscribeToTaskEventsMutex.Lock()
	ret, specificReturn := fake.subscribeToTaskEventsReturnsOnCall[len(fake.subscribeToTaskEventsArgsForCall)]
	fake.subscribeToTaskEventsArgsForCall = append(fake.subscribeToTaskEventsArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	stub := fake.SubscribeToTaskEventsStub
	fakeReturns := fake.subscribeToTaskEventsReturns
	fake.recordInvocation("SubscribeToTaskEvents", []interface{}{arg1})
	fake.subscribeToTaskEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) SubscribeToTaskEventsCallCount() int {
	fake.subscribeToTaskEventsMutex.RLock()
	defer fake.subscribeToTaskEventsMutex.RUnlock()
	return len(fake.subscribeToTaskEventsArgsForCall)
}

func (fake *FakeInternalClient) SubscribeToTaskEventsCalls(stub func(lager.Logger) (events.EventSource, error)) {
	fake.subscribeToTaskEventsMutex.Lock()
	defer fake.subscribeToTaskEventsMutex.Unlock()
	fake.SubscribeToTaskEventsStub = stub
}

func (fake *FakeInternalClient) SubscribeToTaskEventsArgsForCall(i int) lager.Logger {
	fake.subscribeToTaskEventsMutex.RLock()
	defer fake.subscribeToTaskEventsMutex.RUnlock()
	argsForCall := fake.subscribeToTaskEventsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeInternalClient) SubscribeToTaskEventsReturns(result1 events.EventSource, result2 error) {
	fake.subscribeToTaskEventsMutex.Lock()
	defer fake.subscribeToTaskEventsMutex.Unlock()
	fake.SubscribeToTaskEventsStub = nil
	fake.subscribeToTaskEventsReturns = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) SubscribeToTaskEventsReturnsOnCall(i int, result1 events.EventSource, result2 error) {
	fake.subscribeToTaskEventsMutex.Lock()
	defer fake.subscribeToTaskEventsMutex.Unlock()
	fake.SubscribeToTaskEventsStub = nil
	if fake.subscribeToTaskEventsReturnsOnCall == nil {
		fake.subscribeToTaskEventsReturnsOnCall = make(map[int]struct {
			result1 events.EventSource
			result2 error
		})
	}
	fake.subscribeToTaskEventsReturnsOnCall[i] = struct {
		result1 events.EventSource
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TaskByGuid(arg1 lager.Logger, arg2 string, arg3 string) (*models.Task, error) {
	fake.taskByGuidMutex.Lock()
	ret, specificReturn := fake.taskByGuidReturnsOnCall[len(fake.taskByGuidArgsForCall)]
	fake.taskByGuidArgsForCall = append(fake.taskByGuidArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.TaskByGuidStub
	fakeReturns := fake.taskByGuidReturns
	fake.recordInvocation("TaskByGuid", []interface{}{arg1, arg2, arg3})
	fake.taskByGuidMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) TaskByGuidCallCount() int {
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	return len(fake.taskByGuidArgsForCall)
}

func (fake *FakeInternalClient) TaskByGuidCalls(stub func(lager.Logger, string, string) (*models.Task, error)) {
	fake.taskByGuidMutex.Lock()
	defer fake.taskByGuidMutex.Unlock()
	fake.TaskByGuidStub = stub
}

func (fake *FakeInternalClient) TaskByGuidArgsForCall(i int) (lager.Logger, string, string) {
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	argsForCall := fake.taskByGuidArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) TaskByGuidReturns(result1 *models.Task, result2 error) {
	fake.taskByGuidMutex.Lock()
	defer fake.taskByGuidMutex.Unlock()
	fake.TaskByGuidStub = nil
	fake.taskByGuidReturns = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TaskByGuidReturnsOnCall(i int, result1 *models.Task, result2 error) {
	fake.taskByGuidMutex.Lock()
	defer fake.taskByGuidMutex.Unlock()
	fake.TaskByGuidStub = nil
	if fake.taskByGuidReturnsOnCall == nil {
		fake.taskByGuidReturnsOnCall = make(map[int]struct {
			result1 *models.Task
			result2 error
		})
	}
	fake.taskByGuidReturnsOnCall[i] = struct {
		result1 *models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) Tasks(arg1 lager.Logger, arg2 string) ([]*models.Task, error) {
	fake.tasksMutex.Lock()
	ret, specificReturn := fake.tasksReturnsOnCall[len(fake.tasksArgsForCall)]
	fake.tasksArgsForCall = append(fake.tasksArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
	}{arg1, arg2})
	stub := fake.TasksStub
	fakeReturns := fake.tasksReturns
	fake.recordInvocation("Tasks", []interface{}{arg1, arg2})
	fake.tasksMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) TasksCallCount() int {
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	return len(fake.tasksArgsForCall)
}

func (fake *FakeInternalClient) TasksCalls(stub func(lager.Logger, string) ([]*models.Task, error)) {
	fake.tasksMutex.Lock()
	defer fake.tasksMutex.Unlock()
	fake.TasksStub = stub
}

func (fake *FakeInternalClient) TasksArgsForCall(i int) (lager.Logger, string) {
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	argsForCall := fake.tasksArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeInternalClient) TasksReturns(result1 []*models.Task, result2 error) {
	fake.tasksMutex.Lock()
	defer fake.tasksMutex.Unlock()
	fake.TasksStub = nil
	fake.tasksReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksReturnsOnCall(i int, result1 []*models.Task, result2 error) {
	fake.tasksMutex.Lock()
	defer fake.tasksMutex.Unlock()
	fake.TasksStub = nil
	if fake.tasksReturnsOnCall == nil {
		fake.tasksReturnsOnCall = make(map[int]struct {
			result1 []*models.Task
			result2 error
		})
	}
	fake.tasksReturnsOnCall[i] = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksByCellID(arg1 lager.Logger, arg2 string, arg3 string) ([]*models.Task, error) {
	fake.tasksByCellIDMutex.Lock()
	ret, specificReturn := fake.tasksByCellIDReturnsOnCall[len(fake.tasksByCellIDArgsForCall)]
	fake.tasksByCellIDArgsForCall = append(fake.tasksByCellIDArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.TasksByCellIDStub
	fakeReturns := fake.tasksByCellIDReturns
	fake.recordInvocation("TasksByCellID", []interface{}{arg1, arg2, arg3})
	fake.tasksByCellIDMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) TasksByCellIDCallCount() int {
	fake.tasksByCellIDMutex.RLock()
	defer fake.tasksByCellIDMutex.RUnlock()
	return len(fake.tasksByCellIDArgsForCall)
}

func (fake *FakeInternalClient) TasksByCellIDCalls(stub func(lager.Logger, string, string) ([]*models.Task, error)) {
	fake.tasksByCellIDMutex.Lock()
	defer fake.tasksByCellIDMutex.Unlock()
	fake.TasksByCellIDStub = stub
}

func (fake *FakeInternalClient) TasksByCellIDArgsForCall(i int) (lager.Logger, string, string) {
	fake.tasksByCellIDMutex.RLock()
	defer fake.tasksByCellIDMutex.RUnlock()
	argsForCall := fake.tasksByCellIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) TasksByCellIDReturns(result1 []*models.Task, result2 error) {
	fake.tasksByCellIDMutex.Lock()
	defer fake.tasksByCellIDMutex.Unlock()
	fake.TasksByCellIDStub = nil
	fake.tasksByCellIDReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksByCellIDReturnsOnCall(i int, result1 []*models.Task, result2 error) {
	fake.tasksByCellIDMutex.Lock()
	defer fake.tasksByCellIDMutex.Unlock()
	fake.TasksByCellIDStub = nil
	if fake.tasksByCellIDReturnsOnCall == nil {
		fake.tasksByCellIDReturnsOnCall = make(map[int]struct {
			result1 []*models.Task
			result2 error
		})
	}
	fake.tasksByCellIDReturnsOnCall[i] = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksByDomain(arg1 lager.Logger, arg2 string, arg3 string) ([]*models.Task, error) {
	fake.tasksByDomainMutex.Lock()
	ret, specificReturn := fake.tasksByDomainReturnsOnCall[len(fake.tasksByDomainArgsForCall)]
	fake.tasksByDomainArgsForCall = append(fake.tasksByDomainArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.TasksByDomainStub
	fakeReturns := fake.tasksByDomainReturns
	fake.recordInvocation("TasksByDomain", []interface{}{arg1, arg2, arg3})
	fake.tasksByDomainMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) TasksByDomainCallCount() int {
	fake.tasksByDomainMutex.RLock()
	defer fake.tasksByDomainMutex.RUnlock()
	return len(fake.tasksByDomainArgsForCall)
}

func (fake *FakeInternalClient) TasksByDomainCalls(stub func(lager.Logger, string, string) ([]*models.Task, error)) {
	fake.tasksByDomainMutex.Lock()
	defer fake.tasksByDomainMutex.Unlock()
	fake.TasksByDomainStub = stub
}

func (fake *FakeInternalClient) TasksByDomainArgsForCall(i int) (lager.Logger, string, string) {
	fake.tasksByDomainMutex.RLock()
	defer fake.tasksByDomainMutex.RUnlock()
	argsForCall := fake.tasksByDomainArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) TasksByDomainReturns(result1 []*models.Task, result2 error) {
	fake.tasksByDomainMutex.Lock()
	defer fake.tasksByDomainMutex.Unlock()
	fake.TasksByDomainStub = nil
	fake.tasksByDomainReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksByDomainReturnsOnCall(i int, result1 []*models.Task, result2 error) {
	fake.tasksByDomainMutex.Lock()
	defer fake.tasksByDomainMutex.Unlock()
	fake.TasksByDomainStub = nil
	if fake.tasksByDomainReturnsOnCall == nil {
		fake.tasksByDomainReturnsOnCall = make(map[int]struct {
			result1 []*models.Task
			result2 error
		})
	}
	fake.tasksByDomainReturnsOnCall[i] = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksWithFilter(arg1 lager.Logger, arg2 string, arg3 models.TaskFilter) ([]*models.Task, error) {
	fake.tasksWithFilterMutex.Lock()
	ret, specificReturn := fake.tasksWithFilterReturnsOnCall[len(fake.tasksWithFilterArgsForCall)]
	fake.tasksWithFilterArgsForCall = append(fake.tasksWithFilterArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 models.TaskFilter
	}{arg1, arg2, arg3})
	stub := fake.TasksWithFilterStub
	fakeReturns := fake.tasksWithFilterReturns
	fake.recordInvocation("TasksWithFilter", []interface{}{arg1, arg2, arg3})
	fake.tasksWithFilterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInternalClient) TasksWithFilterCallCount() int {
	fake.tasksWithFilterMutex.RLock()
	defer fake.tasksWithFilterMutex.RUnlock()
	return len(fake.tasksWithFilterArgsForCall)
}

func (fake *FakeInternalClient) TasksWithFilterCalls(stub func(lager.Logger, string, models.TaskFilter) ([]*models.Task, error)) {
	fake.tasksWithFilterMutex.Lock()
	defer fake.tasksWithFilterMutex.Unlock()
	fake.TasksWithFilterStub = stub
}

func (fake *FakeInternalClient) TasksWithFilterArgsForCall(i int) (lager.Logger, string, models.TaskFilter) {
	fake.tasksWithFilterMutex.RLock()
	defer fake.tasksWithFilterMutex.RUnlock()
	argsForCall := fake.tasksWithFilterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeInternalClient) TasksWithFilterReturns(result1 []*models.Task, result2 error) {
	fake.tasksWithFilterMutex.Lock()
	defer fake.tasksWithFilterMutex.Unlock()
	fake.TasksWithFilterStub = nil
	fake.tasksWithFilterReturns = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) TasksWithFilterReturnsOnCall(i int, result1 []*models.Task, result2 error) {
	fake.tasksWithFilterMutex.Lock()
	defer fake.tasksWithFilterMutex.Unlock()
	fake.TasksWithFilterStub = nil
	if fake.tasksWithFilterReturnsOnCall == nil {
		fake.tasksWithFilterReturnsOnCall = make(map[int]struct {
			result1 []*models.Task
			result2 error
		})
	}
	fake.tasksWithFilterReturnsOnCall[i] = struct {
		result1 []*models.Task
		result2 error
	}{result1, result2}
}

func (fake *FakeInternalClient) UpdateDesiredLRP(arg1 lager.Logger, arg2 string, arg3 string, arg4 *models.DesiredLRPUpdate) error {
	fake.updateDesiredLRPMutex.Lock()
	ret, specificReturn := fake.updateDesiredLRPReturnsOnCall[len(fake.updateDesiredLRPArgsForCall)]
	fake.updateDesiredLRPArgsForCall = append(fake.updateDesiredLRPArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 *models.DesiredLRPUpdate
	}{arg1, arg2, arg3, arg4})
	stub := fake.UpdateDesiredLRPStub
	fakeReturns := fake.updateDesiredLRPReturns
	fake.recordInvocation("UpdateDesiredLRP", []interface{}{arg1, arg2, arg3, arg4})
	fake.updateDesiredLRPMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInternalClient) UpdateDesiredLRPCallCount() int {
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	return len(fake.updateDesiredLRPArgsForCall)
}

func (fake *FakeInternalClient) UpdateDesiredLRPCalls(stub func(lager.Logger, string, string, *models.DesiredLRPUpdate) error) {
	fake.updateDesiredLRPMutex.Lock()
	defer fake.updateDesiredLRPMutex.Unlock()
	fake.UpdateDesiredLRPStub = stub
}

func (fake *FakeInternalClient) UpdateDesiredLRPArgsForCall(i int) (lager.Logger, string, string, *models.DesiredLRPUpdate) {
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	argsForCall := fake.updateDesiredLRPArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInternalClient) UpdateDesiredLRPReturns(result1 error) {
	fake.updateDesiredLRPMutex.Lock()
	defer fake.updateDesiredLRPMutex.Unlock()
	fake.UpdateDesiredLRPStub = nil
	fake.updateDesiredLRPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) UpdateDesiredLRPReturnsOnCall(i int, result1 error) {
	fake.updateDesiredLRPMutex.Lock()
	defer fake.updateDesiredLRPMutex.Unlock()
	fake.UpdateDesiredLRPStub = nil
	if fake.updateDesiredLRPReturnsOnCall == nil {
		fake.updateDesiredLRPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateDesiredLRPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) UpsertDomain(arg1 lager.Logger, arg2 string, arg3 string, arg4 time.Duration) error {
	fake.upsertDomainMutex.Lock()
	ret, specificReturn := fake.upsertDomainReturnsOnCall[len(fake.upsertDomainArgsForCall)]
	fake.upsertDomainArgsForCall = append(fake.upsertDomainArgsForCall, struct {
		arg1 lager.Logger
		arg2 string
		arg3 string
		arg4 time.Duration
	}{arg1, arg2, arg3, arg4})
	stub := fake.UpsertDomainStub
	fakeReturns := fake.upsertDomainReturns
	fake.recordInvocation("UpsertDomain", []interface{}{arg1, arg2, arg3, arg4})
	fake.upsertDomainMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeInternalClient) UpsertDomainCallCount() int {
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	return len(fake.upsertDomainArgsForCall)
}

func (fake *FakeInternalClient) UpsertDomainCalls(stub func(lager.Logger, string, string, time.Duration) error) {
	fake.upsertDomainMutex.Lock()
	defer fake.upsertDomainMutex.Unlock()
	fake.UpsertDomainStub = stub
}

func (fake *FakeInternalClient) UpsertDomainArgsForCall(i int) (lager.Logger, string, string, time.Duration) {
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	argsForCall := fake.upsertDomainArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeInternalClient) UpsertDomainReturns(result1 error) {
	fake.upsertDomainMutex.Lock()
	defer fake.upsertDomainMutex.Unlock()
	fake.UpsertDomainStub = nil
	fake.upsertDomainReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) UpsertDomainReturnsOnCall(i int, result1 error) {
	fake.upsertDomainMutex.Lock()
	defer fake.upsertDomainMutex.Unlock()
	fake.UpsertDomainStub = nil
	if fake.upsertDomainReturnsOnCall == nil {
		fake.upsertDomainReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.upsertDomainReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeInternalClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.actualLRPGroupByProcessGuidAndIndexMutex.RLock()
	defer fake.actualLRPGroupByProcessGuidAndIndexMutex.RUnlock()
	fake.actualLRPGroupsMutex.RLock()
	defer fake.actualLRPGroupsMutex.RUnlock()
	fake.actualLRPGroupsByProcessGuidMutex.RLock()
	defer fake.actualLRPGroupsByProcessGuidMutex.RUnlock()
	fake.actualLRPsMutex.RLock()
	defer fake.actualLRPsMutex.RUnlock()
	fake.cancelTaskMutex.RLock()
	defer fake.cancelTaskMutex.RUnlock()
	fake.cellsMutex.RLock()
	defer fake.cellsMutex.RUnlock()
	fake.claimActualLRPMutex.RLock()
	defer fake.claimActualLRPMutex.RUnlock()
	fake.completeTaskMutex.RLock()
	defer fake.completeTaskMutex.RUnlock()
	fake.crashActualLRPMutex.RLock()
	defer fake.crashActualLRPMutex.RUnlock()
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	fake.desireLRPMutex.RLock()
	defer fake.desireLRPMutex.RUnlock()
	fake.desireTaskMutex.RLock()
	defer fake.desireTaskMutex.RUnlock()
	fake.desiredLRPByProcessGuidMutex.RLock()
	defer fake.desiredLRPByProcessGuidMutex.RUnlock()
	fake.desiredLRPRoutingInfosMutex.RLock()
	defer fake.desiredLRPRoutingInfosMutex.RUnlock()
	fake.desiredLRPSchedulingInfoByProcessGuidMutex.RLock()
	defer fake.desiredLRPSchedulingInfoByProcessGuidMutex.RUnlock()
	fake.desiredLRPSchedulingInfosMutex.RLock()
	defer fake.desiredLRPSchedulingInfosMutex.RUnlock()
	fake.desiredLRPsMutex.RLock()
	defer fake.desiredLRPsMutex.RUnlock()
	fake.domainsMutex.RLock()
	defer fake.domainsMutex.RUnlock()
	fake.evacuateClaimedActualLRPMutex.RLock()
	defer fake.evacuateClaimedActualLRPMutex.RUnlock()
	fake.evacuateCrashedActualLRPMutex.RLock()
	defer fake.evacuateCrashedActualLRPMutex.RUnlock()
	fake.evacuateRunningActualLRPMutex.RLock()
	defer fake.evacuateRunningActualLRPMutex.RUnlock()
	fake.evacuateStoppedActualLRPMutex.RLock()
	defer fake.evacuateStoppedActualLRPMutex.RUnlock()
	fake.failActualLRPMutex.RLock()
	defer fake.failActualLRPMutex.RUnlock()
	fake.failTaskMutex.RLock()
	defer fake.failTaskMutex.RUnlock()
	fake.pingMutex.RLock()
	defer fake.pingMutex.RUnlock()
	fake.rejectTaskMutex.RLock()
	defer fake.rejectTaskMutex.RUnlock()
	fake.removeActualLRPMutex.RLock()
	defer fake.removeActualLRPMutex.RUnlock()
	fake.removeDesiredLRPMutex.RLock()
	defer fake.removeDesiredLRPMutex.RUnlock()
	fake.removeEvacuatingActualLRPMutex.RLock()
	defer fake.removeEvacuatingActualLRPMutex.RUnlock()
	fake.resolvingTaskMutex.RLock()
	defer fake.resolvingTaskMutex.RUnlock()
	fake.retireActualLRPMutex.RLock()
	defer fake.retireActualLRPMutex.RUnlock()
	fake.startActualLRPMutex.RLock()
	defer fake.startActualLRPMutex.RUnlock()
	fake.startTaskMutex.RLock()
	defer fake.startTaskMutex.RUnlock()
	fake.subscribeToEventsMutex.RLock()
	defer fake.subscribeToEventsMutex.RUnlock()
	fake.subscribeToEventsByCellIDMutex.RLock()
	defer fake.subscribeToEventsByCellIDMutex.RUnlock()
	fake.subscribeToInstanceEventsMutex.RLock()
	defer fake.subscribeToInstanceEventsMutex.RUnlock()
	fake.subscribeToInstanceEventsByCellIDMutex.RLock()
	defer fake.subscribeToInstanceEventsByCellIDMutex.RUnlock()
	fake.subscribeToTaskEventsMutex.RLock()
	defer fake.subscribeToTaskEventsMutex.RUnlock()
	fake.taskByGuidMutex.RLock()
	defer fake.taskByGuidMutex.RUnlock()
	fake.tasksMutex.RLock()
	defer fake.tasksMutex.RUnlock()
	fake.tasksByCellIDMutex.RLock()
	defer fake.tasksByCellIDMutex.RUnlock()
	fake.tasksByDomainMutex.RLock()
	defer fake.tasksByDomainMutex.RUnlock()
	fake.tasksWithFilterMutex.RLock()
	defer fake.tasksWithFilterMutex.RUnlock()
	fake.updateDesiredLRPMutex.RLock()
	defer fake.updateDesiredLRPMutex.RUnlock()
	fake.upsertDomainMutex.RLock()
	defer fake.upsertDomainMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeInternalClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ bbs.InternalClient = new(FakeInternalClient)
