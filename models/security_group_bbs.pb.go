// Code generated by protoc-gen-go-bbs. DO NOT EDIT.
// versions:
// - protoc-gen-go-bbs v0.0.1
// - protoc            v5.27.0--rc1
// source: security_group.proto

package models

// Prevent copylock errors when using ProtoPortRange directly
type PortRange struct {
	Start uint32
	End   uint32
}

func (m *PortRange) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}
func (m *PortRange) SetStart(value uint32) {
	if m != nil {
		m.Start = value
	}
}
func (m *PortRange) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}
func (m *PortRange) SetEnd(value uint32) {
	if m != nil {
		m.End = value
	}
}
func (x *PortRange) ToProto() *ProtoPortRange {
	proto := &ProtoPortRange{
		Start: x.Start,
		End:   x.End,
	}
	return proto
}

func PortRangeProtoMap(values []*PortRange) []*ProtoPortRange {
	result := make([]*ProtoPortRange, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoICMPInfo directly
type ICMPInfo struct {
	Type int32
	Code int32
}

func (m *ICMPInfo) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}
func (m *ICMPInfo) SetType(value int32) {
	if m != nil {
		m.Type = value
	}
}
func (m *ICMPInfo) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}
func (m *ICMPInfo) SetCode(value int32) {
	if m != nil {
		m.Code = value
	}
}
func (x *ICMPInfo) ToProto() *ProtoICMPInfo {
	proto := &ProtoICMPInfo{
		Type: x.Type,
		Code: x.Code,
	}
	return proto
}

func ICMPInfoProtoMap(values []*ICMPInfo) []*ProtoICMPInfo {
	result := make([]*ProtoICMPInfo, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoSecurityGroupRule directly
type SecurityGroupRule struct {
	Protocol     string
	Destinations []string
	Ports        []uint32
	PortRange    *PortRange
	IcmpInfo     *ICMPInfo
	Log          bool
	Annotations  []string
}

func (m *SecurityGroupRule) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}
func (m *SecurityGroupRule) SetProtocol(value string) {
	if m != nil {
		m.Protocol = value
	}
}
func (m *SecurityGroupRule) GetDestinations() []string {
	if m != nil {
		return m.Destinations
	}
	return nil
}
func (m *SecurityGroupRule) SetDestinations(value []string) {
	if m != nil {
		m.Destinations = value
	}
}
func (m *SecurityGroupRule) GetPorts() []uint32 {
	if m != nil {
		return m.Ports
	}
	return 0
}
func (m *SecurityGroupRule) SetPorts(value []uint32) {
	if m != nil {
		m.Ports = value
	}
}
func (m *SecurityGroupRule) GetPortRange() *PortRange {
	if m != nil {
		return m.PortRange
	}
	return nil
}
func (m *SecurityGroupRule) SetPortRange(value *PortRange) {
	if m != nil {
		m.PortRange = value
	}
}
func (m *SecurityGroupRule) GetIcmpInfo() *ICMPInfo {
	if m != nil {
		return m.IcmpInfo
	}
	return nil
}
func (m *SecurityGroupRule) SetIcmpInfo(value *ICMPInfo) {
	if m != nil {
		m.IcmpInfo = value
	}
}
func (m *SecurityGroupRule) GetLog() bool {
	if m != nil {
		return m.Log
	}
	return false
}
func (m *SecurityGroupRule) SetLog(value bool) {
	if m != nil {
		m.Log = value
	}
}
func (m *SecurityGroupRule) GetAnnotations() []string {
	if m != nil {
		return m.Annotations
	}
	return nil
}
func (m *SecurityGroupRule) SetAnnotations(value []string) {
	if m != nil {
		m.Annotations = value
	}
}
func (x *SecurityGroupRule) ToProto() *ProtoSecurityGroupRule {
	proto := &ProtoSecurityGroupRule{
		Protocol:     x.Protocol,
		Destinations: x.Destinations,
		Ports:        x.Ports,
		PortRange:    x.PortRange.ToProto(),
		IcmpInfo:     x.IcmpInfo.ToProto(),
		Log:          x.Log,
		Annotations:  x.Annotations,
	}
	return proto
}

func SecurityGroupRuleProtoMap(values []*SecurityGroupRule) []*ProtoSecurityGroupRule {
	result := make([]*ProtoSecurityGroupRule, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}
