// Code generated by protoc-gen-go-bbs. DO NOT EDIT.
// versions:
// - protoc-gen-go-bbs v0.0.1
// - protoc            v5.26.1
// source: cells.proto

package models

// Prevent copylock errors when using ProtoCellCapacity directly
type CellCapacity struct {
	MemoryMb   int32
	DiskMb     int32
	Containers int32
}

func (this *CellCapacity) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CellCapacity)
	if !ok {
		that2, ok := that.(CellCapacity)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.MemoryMb != that1.MemoryMb {
		return false
	}
	if this.DiskMb != that1.DiskMb {
		return false
	}
	if this.Containers != that1.Containers {
		return false
	}
	return true
}
func (m *CellCapacity) GetMemoryMb() int32 {
	if m != nil {
		return m.MemoryMb
	}
	return 0
}
func (m *CellCapacity) SetMemoryMb(value int32) {
	if m != nil {
		m.MemoryMb = value
	}
}
func (m *CellCapacity) GetDiskMb() int32 {
	if m != nil {
		return m.DiskMb
	}
	return 0
}
func (m *CellCapacity) SetDiskMb(value int32) {
	if m != nil {
		m.DiskMb = value
	}
}
func (m *CellCapacity) GetContainers() int32 {
	if m != nil {
		return m.Containers
	}
	return 0
}
func (m *CellCapacity) SetContainers(value int32) {
	if m != nil {
		m.Containers = value
	}
}
func (x *CellCapacity) ToProto() *ProtoCellCapacity {
	proto := &ProtoCellCapacity{
		MemoryMb:   x.MemoryMb,
		DiskMb:     x.DiskMb,
		Containers: x.Containers,
	}
	return proto
}

func CellCapacityProtoMap(values []*CellCapacity) []*ProtoCellCapacity {
	result := make([]*ProtoCellCapacity, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoCellPresence directly
type CellPresence struct {
	CellId                string
	RepAddress            string
	Zone                  string
	Capacity              *CellCapacity
	RootfsProviders       []*Provider
	PlacementTags         []string
	OptionalPlacementTags []string
	RepUrl                string
}

func (this *CellPresence) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CellPresence)
	if !ok {
		that2, ok := that.(CellPresence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.CellId != that1.CellId {
		return false
	}
	if this.RepAddress != that1.RepAddress {
		return false
	}
	if this.Zone != that1.Zone {
		return false
	}
	if !this.Capacity.Equal(that1.Capacity) {
		return false
	}
	if len(this.RootfsProviders) != len(that1.RootfsProviders) {
		return false
	}
	for i := range this.RootfsProviders {
		if !this.RootfsProviders[i].Equal(that1.RootfsProviders[i]) {
			return false
		}
	}
	if len(this.PlacementTags) != len(that1.PlacementTags) {
		return false
	}
	for i := range this.PlacementTags {
		if this.PlacementTags[i] != that1.PlacementTags[i] {
			return false
		}
	}
	if len(this.OptionalPlacementTags) != len(that1.OptionalPlacementTags) {
		return false
	}
	for i := range this.OptionalPlacementTags {
		if this.OptionalPlacementTags[i] != that1.OptionalPlacementTags[i] {
			return false
		}
	}
	if this.RepUrl != that1.RepUrl {
		return false
	}
	return true
}
func (m *CellPresence) GetCellId() string {
	if m != nil {
		return m.CellId
	}
	return ""
}
func (m *CellPresence) SetCellId(value string) {
	if m != nil {
		m.CellId = value
	}
}
func (m *CellPresence) GetRepAddress() string {
	if m != nil {
		return m.RepAddress
	}
	return ""
}
func (m *CellPresence) SetRepAddress(value string) {
	if m != nil {
		m.RepAddress = value
	}
}
func (m *CellPresence) GetZone() string {
	if m != nil {
		return m.Zone
	}
	return ""
}
func (m *CellPresence) SetZone(value string) {
	if m != nil {
		m.Zone = value
	}
}
func (m *CellPresence) GetCapacity() *CellCapacity {
	if m != nil {
		return m.Capacity
	}
	return nil
}
func (m *CellPresence) SetCapacity(value *CellCapacity) {
	if m != nil {
		m.Capacity = value
	}
}
func (m *CellPresence) GetRootfsProviders() []*Provider {
	if m != nil {
		return m.RootfsProviders
	}
	return nil
}
func (m *CellPresence) SetRootfsProviders(value []*Provider) {
	if m != nil {
		m.RootfsProviders = value
	}
}
func (m *CellPresence) GetPlacementTags() []string {
	if m != nil {
		return m.PlacementTags
	}
	return nil
}
func (m *CellPresence) SetPlacementTags(value []string) {
	if m != nil {
		m.PlacementTags = value
	}
}
func (m *CellPresence) GetOptionalPlacementTags() []string {
	if m != nil {
		return m.OptionalPlacementTags
	}
	return nil
}
func (m *CellPresence) SetOptionalPlacementTags(value []string) {
	if m != nil {
		m.OptionalPlacementTags = value
	}
}
func (m *CellPresence) GetRepUrl() string {
	if m != nil {
		return m.RepUrl
	}
	return ""
}
func (m *CellPresence) SetRepUrl(value string) {
	if m != nil {
		m.RepUrl = value
	}
}
func (x *CellPresence) ToProto() *ProtoCellPresence {
	proto := &ProtoCellPresence{
		CellId:                x.CellId,
		RepAddress:            x.RepAddress,
		Zone:                  x.Zone,
		Capacity:              x.Capacity.ToProto(),
		RootfsProviders:       ProviderProtoMap(x.RootfsProviders),
		PlacementTags:         x.PlacementTags,
		OptionalPlacementTags: x.OptionalPlacementTags,
		RepUrl:                x.RepUrl,
	}
	return proto
}

func CellPresenceProtoMap(values []*CellPresence) []*ProtoCellPresence {
	result := make([]*ProtoCellPresence, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoProvider directly
type Provider struct {
	Name       string
	Properties []string
}

func (this *Provider) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Provider)
	if !ok {
		that2, ok := that.(Provider)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Name != that1.Name {
		return false
	}
	if len(this.Properties) != len(that1.Properties) {
		return false
	}
	for i := range this.Properties {
		if this.Properties[i] != that1.Properties[i] {
			return false
		}
	}
	return true
}
func (m *Provider) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}
func (m *Provider) SetName(value string) {
	if m != nil {
		m.Name = value
	}
}
func (m *Provider) GetProperties() []string {
	if m != nil {
		return m.Properties
	}
	return nil
}
func (m *Provider) SetProperties(value []string) {
	if m != nil {
		m.Properties = value
	}
}
func (x *Provider) ToProto() *ProtoProvider {
	proto := &ProtoProvider{
		Name:       x.Name,
		Properties: x.Properties,
	}
	return proto
}

func ProviderProtoMap(values []*Provider) []*ProtoProvider {
	result := make([]*ProtoProvider, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoCellsResponse directly
type CellsResponse struct {
	Error *Error
	Cells []*CellPresence
}

func (this *CellsResponse) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CellsResponse)
	if !ok {
		that2, ok := that.(CellsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.Error.Equal(that1.Error) {
		return false
	}
	if len(this.Cells) != len(that1.Cells) {
		return false
	}
	for i := range this.Cells {
		if !this.Cells[i].Equal(that1.Cells[i]) {
			return false
		}
	}
	return true
}
func (m *CellsResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *CellsResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (m *CellsResponse) GetCells() []*CellPresence {
	if m != nil {
		return m.Cells
	}
	return nil
}
func (m *CellsResponse) SetCells(value []*CellPresence) {
	if m != nil {
		m.Cells = value
	}
}
func (x *CellsResponse) ToProto() *ProtoCellsResponse {
	proto := &ProtoCellsResponse{
		Error: x.Error.ToProto(),
		Cells: CellPresenceProtoMap(x.Cells),
	}
	return proto
}

func CellsResponseProtoMap(values []*CellsResponse) []*ProtoCellsResponse {
	result := make([]*ProtoCellsResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}
