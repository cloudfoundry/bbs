// Code generated by protoc-gen-go-bbs. DO NOT EDIT.
// versions:
// - protoc-gen-go-bbs v0.0.1
// - protoc            v5.27.0--rc1
// source: cells.proto

package models

// Prevent copylock errors when using ProtoCellCapacity directly
type CellCapacity struct {
	MemoryMb   int32
	DiskMb     int32
	Containers int32
}

func (m *CellCapacity) GetMemoryMb() int32 {
	if m != nil {
		return m.MemoryMb
	}
	return 0
}
func (m *CellCapacity) SetMemoryMb(value int32) {
	if m != nil {
		m.MemoryMb = value
	}
}
func (m *CellCapacity) GetDiskMb() int32 {
	if m != nil {
		return m.DiskMb
	}
	return 0
}
func (m *CellCapacity) SetDiskMb(value int32) {
	if m != nil {
		m.DiskMb = value
	}
}
func (m *CellCapacity) GetContainers() int32 {
	if m != nil {
		return m.Containers
	}
	return 0
}
func (m *CellCapacity) SetContainers(value int32) {
	if m != nil {
		m.Containers = value
	}
}
func (x *CellCapacity) ToProto() *ProtoCellCapacity {
	proto := &ProtoCellCapacity{
		MemoryMb:   x.MemoryMb,
		DiskMb:     x.DiskMb,
		Containers: x.Containers,
	}
	return proto
}

func CellCapacityProtoMap(values []*CellCapacity) []*ProtoCellCapacity {
	result := make([]*ProtoCellCapacity, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoCellPresence directly
type CellPresence struct {
	CellId                string
	RepAddress            string
	Zone                  string
	Capacity              *CellCapacity
	RootfsProviders       []*Provider
	PlacementTags         []string
	OptionalPlacementTags []string
	RepUrl                string
}

func (m *CellPresence) GetCellId() string {
	if m != nil {
		return m.CellId
	}
	return ""
}
func (m *CellPresence) SetCellId(value string) {
	if m != nil {
		m.CellId = value
	}
}
func (m *CellPresence) GetRepAddress() string {
	if m != nil {
		return m.RepAddress
	}
	return ""
}
func (m *CellPresence) SetRepAddress(value string) {
	if m != nil {
		m.RepAddress = value
	}
}
func (m *CellPresence) GetZone() string {
	if m != nil {
		return m.Zone
	}
	return ""
}
func (m *CellPresence) SetZone(value string) {
	if m != nil {
		m.Zone = value
	}
}
func (m *CellPresence) GetCapacity() *CellCapacity {
	if m != nil {
		return m.Capacity
	}
	return nil
}
func (m *CellPresence) SetCapacity(value *CellCapacity) {
	if m != nil {
		m.Capacity = value
	}
}
func (m *CellPresence) GetRootfsProviders() []*Provider {
	if m != nil {
		return m.RootfsProviders
	}
	return nil
}
func (m *CellPresence) SetRootfsProviders(value []*Provider) {
	if m != nil {
		m.RootfsProviders = value
	}
}
func (m *CellPresence) GetPlacementTags() []string {
	if m != nil {
		return m.PlacementTags
	}
	return nil
}
func (m *CellPresence) SetPlacementTags(value []string) {
	if m != nil {
		m.PlacementTags = value
	}
}
func (m *CellPresence) GetOptionalPlacementTags() []string {
	if m != nil {
		return m.OptionalPlacementTags
	}
	return nil
}
func (m *CellPresence) SetOptionalPlacementTags(value []string) {
	if m != nil {
		m.OptionalPlacementTags = value
	}
}
func (m *CellPresence) GetRepUrl() string {
	if m != nil {
		return m.RepUrl
	}
	return ""
}
func (m *CellPresence) SetRepUrl(value string) {
	if m != nil {
		m.RepUrl = value
	}
}
func (x *CellPresence) ToProto() *ProtoCellPresence {
	proto := &ProtoCellPresence{
		CellId:                x.CellId,
		RepAddress:            x.RepAddress,
		Zone:                  x.Zone,
		Capacity:              x.Capacity.ToProto(),
		RootfsProviders:       ProviderProtoMap(x.RootfsProviders),
		PlacementTags:         x.PlacementTags,
		OptionalPlacementTags: x.OptionalPlacementTags,
		RepUrl:                x.RepUrl,
	}
	return proto
}

func CellPresenceProtoMap(values []*CellPresence) []*ProtoCellPresence {
	result := make([]*ProtoCellPresence, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoProvider directly
type Provider struct {
	Name       string
	Properties []string
}

func (m *Provider) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}
func (m *Provider) SetName(value string) {
	if m != nil {
		m.Name = value
	}
}
func (m *Provider) GetProperties() []string {
	if m != nil {
		return m.Properties
	}
	return nil
}
func (m *Provider) SetProperties(value []string) {
	if m != nil {
		m.Properties = value
	}
}
func (x *Provider) ToProto() *ProtoProvider {
	proto := &ProtoProvider{
		Name:       x.Name,
		Properties: x.Properties,
	}
	return proto
}

func ProviderProtoMap(values []*Provider) []*ProtoProvider {
	result := make([]*ProtoProvider, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoCellsResponse directly
type CellsResponse struct {
	Error *Error
	Cells []*CellPresence
}

func (m *CellsResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *CellsResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (m *CellsResponse) GetCells() []*CellPresence {
	if m != nil {
		return m.Cells
	}
	return nil
}
func (m *CellsResponse) SetCells(value []*CellPresence) {
	if m != nil {
		m.Cells = value
	}
}
func (x *CellsResponse) ToProto() *ProtoCellsResponse {
	proto := &ProtoCellsResponse{
		Error: x.Error.ToProto(),
		Cells: CellPresenceProtoMap(x.Cells),
	}
	return proto
}

func CellsResponseProtoMap(values []*CellsResponse) []*ProtoCellsResponse {
	result := make([]*ProtoCellsResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}
