// Code generated by protoc-gen-go-bbs. DO NOT EDIT.
// versions:
// - protoc-gen-go-bbs v0.0.1
// - protoc            v5.26.1
// source: task_requests.proto

package models

// Prevent copylock errors when using ProtoTaskLifecycleResponse directly
type TaskLifecycleResponse struct {
	Error *Error
}

func (this *TaskLifecycleResponse) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TaskLifecycleResponse)
	if !ok {
		that2, ok := that.(TaskLifecycleResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (m *TaskLifecycleResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *TaskLifecycleResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (x *TaskLifecycleResponse) ToProto() *ProtoTaskLifecycleResponse {
	proto := &ProtoTaskLifecycleResponse{
		Error: x.Error.ToProto(),
	}
	return proto
}

func TaskLifecycleResponseProtoMap(values []*TaskLifecycleResponse) []*ProtoTaskLifecycleResponse {
	result := make([]*ProtoTaskLifecycleResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesireTaskRequest directly
type DesireTaskRequest struct {
	TaskDefinition *TaskDefinition
	TaskGuid       string
	Domain         string
}

func (this *DesireTaskRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesireTaskRequest)
	if !ok {
		that2, ok := that.(DesireTaskRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.TaskDefinition.Equal(that1.TaskDefinition) {
		return false
	}
	if this.TaskGuid != that1.TaskGuid {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	return true
}
func (m *DesireTaskRequest) GetTaskDefinition() *TaskDefinition {
	if m != nil {
		return m.TaskDefinition
	}
	return nil
}
func (m *DesireTaskRequest) SetTaskDefinition(value *TaskDefinition) {
	if m != nil {
		m.TaskDefinition = value
	}
}
func (m *DesireTaskRequest) GetTaskGuid() string {
	if m != nil {
		return m.TaskGuid
	}
	return ""
}
func (m *DesireTaskRequest) SetTaskGuid(value string) {
	if m != nil {
		m.TaskGuid = value
	}
}
func (m *DesireTaskRequest) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}
func (m *DesireTaskRequest) SetDomain(value string) {
	if m != nil {
		m.Domain = value
	}
}
func (x *DesireTaskRequest) ToProto() *ProtoDesireTaskRequest {
	proto := &ProtoDesireTaskRequest{
		TaskDefinition: x.TaskDefinition.ToProto(),
		TaskGuid:       x.TaskGuid,
		Domain:         x.Domain,
	}
	return proto
}

func DesireTaskRequestProtoMap(values []*DesireTaskRequest) []*ProtoDesireTaskRequest {
	result := make([]*ProtoDesireTaskRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoStartTaskRequest directly
type StartTaskRequest struct {
	TaskGuid string
	CellId   string
}

func (this *StartTaskRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StartTaskRequest)
	if !ok {
		that2, ok := that.(StartTaskRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.TaskGuid != that1.TaskGuid {
		return false
	}
	if this.CellId != that1.CellId {
		return false
	}
	return true
}
func (m *StartTaskRequest) GetTaskGuid() string {
	if m != nil {
		return m.TaskGuid
	}
	return ""
}
func (m *StartTaskRequest) SetTaskGuid(value string) {
	if m != nil {
		m.TaskGuid = value
	}
}
func (m *StartTaskRequest) GetCellId() string {
	if m != nil {
		return m.CellId
	}
	return ""
}
func (m *StartTaskRequest) SetCellId(value string) {
	if m != nil {
		m.CellId = value
	}
}
func (x *StartTaskRequest) ToProto() *ProtoStartTaskRequest {
	proto := &ProtoStartTaskRequest{
		TaskGuid: x.TaskGuid,
		CellId:   x.CellId,
	}
	return proto
}

func StartTaskRequestProtoMap(values []*StartTaskRequest) []*ProtoStartTaskRequest {
	result := make([]*ProtoStartTaskRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoStartTaskResponse directly
type StartTaskResponse struct {
	Error       *Error
	ShouldStart bool
}

func (this *StartTaskResponse) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StartTaskResponse)
	if !ok {
		that2, ok := that.(StartTaskResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.Error.Equal(that1.Error) {
		return false
	}
	if this.ShouldStart != that1.ShouldStart {
		return false
	}
	return true
}
func (m *StartTaskResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *StartTaskResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (m *StartTaskResponse) GetShouldStart() bool {
	if m != nil {
		return m.ShouldStart
	}
	return false
}
func (m *StartTaskResponse) SetShouldStart(value bool) {
	if m != nil {
		m.ShouldStart = value
	}
}
func (x *StartTaskResponse) ToProto() *ProtoStartTaskResponse {
	proto := &ProtoStartTaskResponse{
		Error:       x.Error.ToProto(),
		ShouldStart: x.ShouldStart,
	}
	return proto
}

func StartTaskResponseProtoMap(values []*StartTaskResponse) []*ProtoStartTaskResponse {
	result := make([]*ProtoStartTaskResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoFailTaskRequest directly
type FailTaskRequest struct {
	TaskGuid      string
	FailureReason string
}

func (this *FailTaskRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FailTaskRequest)
	if !ok {
		that2, ok := that.(FailTaskRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.TaskGuid != that1.TaskGuid {
		return false
	}
	if this.FailureReason != that1.FailureReason {
		return false
	}
	return true
}
func (m *FailTaskRequest) GetTaskGuid() string {
	if m != nil {
		return m.TaskGuid
	}
	return ""
}
func (m *FailTaskRequest) SetTaskGuid(value string) {
	if m != nil {
		m.TaskGuid = value
	}
}
func (m *FailTaskRequest) GetFailureReason() string {
	if m != nil {
		return m.FailureReason
	}
	return ""
}
func (m *FailTaskRequest) SetFailureReason(value string) {
	if m != nil {
		m.FailureReason = value
	}
}
func (x *FailTaskRequest) ToProto() *ProtoFailTaskRequest {
	proto := &ProtoFailTaskRequest{
		TaskGuid:      x.TaskGuid,
		FailureReason: x.FailureReason,
	}
	return proto
}

func FailTaskRequestProtoMap(values []*FailTaskRequest) []*ProtoFailTaskRequest {
	result := make([]*ProtoFailTaskRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoRejectTaskRequest directly
type RejectTaskRequest struct {
	TaskGuid        string
	RejectionReason string
}

func (this *RejectTaskRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RejectTaskRequest)
	if !ok {
		that2, ok := that.(RejectTaskRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.TaskGuid != that1.TaskGuid {
		return false
	}
	if this.RejectionReason != that1.RejectionReason {
		return false
	}
	return true
}
func (m *RejectTaskRequest) GetTaskGuid() string {
	if m != nil {
		return m.TaskGuid
	}
	return ""
}
func (m *RejectTaskRequest) SetTaskGuid(value string) {
	if m != nil {
		m.TaskGuid = value
	}
}
func (m *RejectTaskRequest) GetRejectionReason() string {
	if m != nil {
		return m.RejectionReason
	}
	return ""
}
func (m *RejectTaskRequest) SetRejectionReason(value string) {
	if m != nil {
		m.RejectionReason = value
	}
}
func (x *RejectTaskRequest) ToProto() *ProtoRejectTaskRequest {
	proto := &ProtoRejectTaskRequest{
		TaskGuid:        x.TaskGuid,
		RejectionReason: x.RejectionReason,
	}
	return proto
}

func RejectTaskRequestProtoMap(values []*RejectTaskRequest) []*ProtoRejectTaskRequest {
	result := make([]*ProtoRejectTaskRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoTaskGuidRequest directly
type TaskGuidRequest struct {
	TaskGuid string
}

func (this *TaskGuidRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TaskGuidRequest)
	if !ok {
		that2, ok := that.(TaskGuidRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.TaskGuid != that1.TaskGuid {
		return false
	}
	return true
}
func (m *TaskGuidRequest) GetTaskGuid() string {
	if m != nil {
		return m.TaskGuid
	}
	return ""
}
func (m *TaskGuidRequest) SetTaskGuid(value string) {
	if m != nil {
		m.TaskGuid = value
	}
}
func (x *TaskGuidRequest) ToProto() *ProtoTaskGuidRequest {
	proto := &ProtoTaskGuidRequest{
		TaskGuid: x.TaskGuid,
	}
	return proto
}

func TaskGuidRequestProtoMap(values []*TaskGuidRequest) []*ProtoTaskGuidRequest {
	result := make([]*ProtoTaskGuidRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoCompleteTaskRequest directly
type CompleteTaskRequest struct {
	TaskGuid      string
	CellId        string
	Failed        bool
	FailureReason string
	Result        string
}

func (this *CompleteTaskRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CompleteTaskRequest)
	if !ok {
		that2, ok := that.(CompleteTaskRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.TaskGuid != that1.TaskGuid {
		return false
	}
	if this.CellId != that1.CellId {
		return false
	}
	if this.Failed != that1.Failed {
		return false
	}
	if this.FailureReason != that1.FailureReason {
		return false
	}
	if this.Result != that1.Result {
		return false
	}
	return true
}
func (m *CompleteTaskRequest) GetTaskGuid() string {
	if m != nil {
		return m.TaskGuid
	}
	return ""
}
func (m *CompleteTaskRequest) SetTaskGuid(value string) {
	if m != nil {
		m.TaskGuid = value
	}
}
func (m *CompleteTaskRequest) GetCellId() string {
	if m != nil {
		return m.CellId
	}
	return ""
}
func (m *CompleteTaskRequest) SetCellId(value string) {
	if m != nil {
		m.CellId = value
	}
}
func (m *CompleteTaskRequest) GetFailed() bool {
	if m != nil {
		return m.Failed
	}
	return false
}
func (m *CompleteTaskRequest) SetFailed(value bool) {
	if m != nil {
		m.Failed = value
	}
}
func (m *CompleteTaskRequest) GetFailureReason() string {
	if m != nil {
		return m.FailureReason
	}
	return ""
}
func (m *CompleteTaskRequest) SetFailureReason(value string) {
	if m != nil {
		m.FailureReason = value
	}
}
func (m *CompleteTaskRequest) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}
func (m *CompleteTaskRequest) SetResult(value string) {
	if m != nil {
		m.Result = value
	}
}
func (x *CompleteTaskRequest) ToProto() *ProtoCompleteTaskRequest {
	proto := &ProtoCompleteTaskRequest{
		TaskGuid:      x.TaskGuid,
		CellId:        x.CellId,
		Failed:        x.Failed,
		FailureReason: x.FailureReason,
		Result:        x.Result,
	}
	return proto
}

func CompleteTaskRequestProtoMap(values []*CompleteTaskRequest) []*ProtoCompleteTaskRequest {
	result := make([]*ProtoCompleteTaskRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoTaskCallbackResponse directly
type TaskCallbackResponse struct {
	TaskGuid      string
	Failed        bool
	FailureReason string
	Result        string
	Annotation    string
	CreatedAt     int64
}

func (this *TaskCallbackResponse) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TaskCallbackResponse)
	if !ok {
		that2, ok := that.(TaskCallbackResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.TaskGuid != that1.TaskGuid {
		return false
	}
	if this.Failed != that1.Failed {
		return false
	}
	if this.FailureReason != that1.FailureReason {
		return false
	}
	if this.Result != that1.Result {
		return false
	}
	if this.Annotation != that1.Annotation {
		return false
	}
	if this.CreatedAt != that1.CreatedAt {
		return false
	}
	return true
}
func (m *TaskCallbackResponse) GetTaskGuid() string {
	if m != nil {
		return m.TaskGuid
	}
	return ""
}
func (m *TaskCallbackResponse) SetTaskGuid(value string) {
	if m != nil {
		m.TaskGuid = value
	}
}
func (m *TaskCallbackResponse) GetFailed() bool {
	if m != nil {
		return m.Failed
	}
	return false
}
func (m *TaskCallbackResponse) SetFailed(value bool) {
	if m != nil {
		m.Failed = value
	}
}
func (m *TaskCallbackResponse) GetFailureReason() string {
	if m != nil {
		return m.FailureReason
	}
	return ""
}
func (m *TaskCallbackResponse) SetFailureReason(value string) {
	if m != nil {
		m.FailureReason = value
	}
}
func (m *TaskCallbackResponse) GetResult() string {
	if m != nil {
		return m.Result
	}
	return ""
}
func (m *TaskCallbackResponse) SetResult(value string) {
	if m != nil {
		m.Result = value
	}
}
func (m *TaskCallbackResponse) GetAnnotation() string {
	if m != nil {
		return m.Annotation
	}
	return ""
}
func (m *TaskCallbackResponse) SetAnnotation(value string) {
	if m != nil {
		m.Annotation = value
	}
}
func (m *TaskCallbackResponse) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}
func (m *TaskCallbackResponse) SetCreatedAt(value int64) {
	if m != nil {
		m.CreatedAt = value
	}
}
func (x *TaskCallbackResponse) ToProto() *ProtoTaskCallbackResponse {
	proto := &ProtoTaskCallbackResponse{
		TaskGuid:      x.TaskGuid,
		Failed:        x.Failed,
		FailureReason: x.FailureReason,
		Result:        x.Result,
		Annotation:    x.Annotation,
		CreatedAt:     x.CreatedAt,
	}
	return proto
}

func TaskCallbackResponseProtoMap(values []*TaskCallbackResponse) []*ProtoTaskCallbackResponse {
	result := make([]*ProtoTaskCallbackResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoTasksRequest directly
type TasksRequest struct {
	Domain string
	CellId string
}

func (this *TasksRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TasksRequest)
	if !ok {
		that2, ok := that.(TasksRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Domain != that1.Domain {
		return false
	}
	if this.CellId != that1.CellId {
		return false
	}
	return true
}
func (m *TasksRequest) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}
func (m *TasksRequest) SetDomain(value string) {
	if m != nil {
		m.Domain = value
	}
}
func (m *TasksRequest) GetCellId() string {
	if m != nil {
		return m.CellId
	}
	return ""
}
func (m *TasksRequest) SetCellId(value string) {
	if m != nil {
		m.CellId = value
	}
}
func (x *TasksRequest) ToProto() *ProtoTasksRequest {
	proto := &ProtoTasksRequest{
		Domain: x.Domain,
		CellId: x.CellId,
	}
	return proto
}

func TasksRequestProtoMap(values []*TasksRequest) []*ProtoTasksRequest {
	result := make([]*ProtoTasksRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoTasksResponse directly
type TasksResponse struct {
	Error *Error
	Tasks []*Task
}

func (this *TasksResponse) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TasksResponse)
	if !ok {
		that2, ok := that.(TasksResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.Error.Equal(that1.Error) {
		return false
	}
	if len(this.Tasks) != len(that1.Tasks) {
		return false
	}
	for i := range this.Tasks {
		if !this.Tasks[i].Equal(that1.Tasks[i]) {
			return false
		}
	}
	return true
}
func (m *TasksResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *TasksResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (m *TasksResponse) GetTasks() []*Task {
	if m != nil {
		return m.Tasks
	}
	return nil
}
func (m *TasksResponse) SetTasks(value []*Task) {
	if m != nil {
		m.Tasks = value
	}
}
func (x *TasksResponse) ToProto() *ProtoTasksResponse {
	proto := &ProtoTasksResponse{
		Error: x.Error.ToProto(),
		Tasks: TaskProtoMap(x.Tasks),
	}
	return proto
}

func TasksResponseProtoMap(values []*TasksResponse) []*ProtoTasksResponse {
	result := make([]*ProtoTasksResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoTaskByGuidRequest directly
type TaskByGuidRequest struct {
	TaskGuid string
}

func (this *TaskByGuidRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TaskByGuidRequest)
	if !ok {
		that2, ok := that.(TaskByGuidRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.TaskGuid != that1.TaskGuid {
		return false
	}
	return true
}
func (m *TaskByGuidRequest) GetTaskGuid() string {
	if m != nil {
		return m.TaskGuid
	}
	return ""
}
func (m *TaskByGuidRequest) SetTaskGuid(value string) {
	if m != nil {
		m.TaskGuid = value
	}
}
func (x *TaskByGuidRequest) ToProto() *ProtoTaskByGuidRequest {
	proto := &ProtoTaskByGuidRequest{
		TaskGuid: x.TaskGuid,
	}
	return proto
}

func TaskByGuidRequestProtoMap(values []*TaskByGuidRequest) []*ProtoTaskByGuidRequest {
	result := make([]*ProtoTaskByGuidRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoTaskResponse directly
type TaskResponse struct {
	Error *Error
	Task  *Task
}

func (this *TaskResponse) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TaskResponse)
	if !ok {
		that2, ok := that.(TaskResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.Error.Equal(that1.Error) {
		return false
	}
	if !this.Task.Equal(that1.Task) {
		return false
	}
	return true
}
func (m *TaskResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *TaskResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (m *TaskResponse) GetTask() *Task {
	if m != nil {
		return m.Task
	}
	return nil
}
func (m *TaskResponse) SetTask(value *Task) {
	if m != nil {
		m.Task = value
	}
}
func (x *TaskResponse) ToProto() *ProtoTaskResponse {
	proto := &ProtoTaskResponse{
		Error: x.Error.ToProto(),
		Task:  x.Task.ToProto(),
	}
	return proto
}

func TaskResponseProtoMap(values []*TaskResponse) []*ProtoTaskResponse {
	result := make([]*ProtoTaskResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}
