// Code generated by protoc-gen-go-bbs. DO NOT EDIT.
// versions:
// - protoc-gen-go-bbs v0.0.1
// - protoc            v5.27.0--rc1
// source: evacuation.proto

package models

// Prevent copylock errors when using ProtoEvacuationResponse directly
type EvacuationResponse struct {
	Error         *Error
	KeepContainer bool
}

func (m *EvacuationResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *EvacuationResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (m *EvacuationResponse) GetKeepContainer() bool {
	if m != nil {
		return m.KeepContainer
	}
	return false
}
func (m *EvacuationResponse) SetKeepContainer(value bool) {
	if m != nil {
		m.KeepContainer = value
	}
}
func (x *EvacuationResponse) ToProto() *ProtoEvacuationResponse {
	proto := &ProtoEvacuationResponse{
		Error:         x.Error.ToProto(),
		KeepContainer: x.KeepContainer,
	}
	return proto
}

func EvacuationResponseProtoMap(values []*EvacuationResponse) []*ProtoEvacuationResponse {
	result := make([]*ProtoEvacuationResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoEvacuateClaimedActualLRPRequest directly
type EvacuateClaimedActualLRPRequest struct {
	ActualLrpKey         *ActualLRPKey
	ActualLrpInstanceKey *ActualLRPInstanceKey
}

func (m *EvacuateClaimedActualLRPRequest) GetActualLrpKey() *ActualLRPKey {
	if m != nil {
		return m.ActualLrpKey
	}
	return nil
}
func (m *EvacuateClaimedActualLRPRequest) SetActualLrpKey(value *ActualLRPKey) {
	if m != nil {
		m.ActualLrpKey = value
	}
}
func (m *EvacuateClaimedActualLRPRequest) GetActualLrpInstanceKey() *ActualLRPInstanceKey {
	if m != nil {
		return m.ActualLrpInstanceKey
	}
	return nil
}
func (m *EvacuateClaimedActualLRPRequest) SetActualLrpInstanceKey(value *ActualLRPInstanceKey) {
	if m != nil {
		m.ActualLrpInstanceKey = value
	}
}
func (x *EvacuateClaimedActualLRPRequest) ToProto() *ProtoEvacuateClaimedActualLRPRequest {
	proto := &ProtoEvacuateClaimedActualLRPRequest{
		ActualLrpKey:         x.ActualLrpKey.ToProto(),
		ActualLrpInstanceKey: x.ActualLrpInstanceKey.ToProto(),
	}
	return proto
}

func EvacuateClaimedActualLRPRequestProtoMap(values []*EvacuateClaimedActualLRPRequest) []*ProtoEvacuateClaimedActualLRPRequest {
	result := make([]*ProtoEvacuateClaimedActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoEvacuateRunningActualLRPRequest directly
type EvacuateRunningActualLRPRequest struct {
	ActualLrpKey            *ActualLRPKey
	ActualLrpInstanceKey    *ActualLRPInstanceKey
	ActualLrpNetInfo        *ActualLRPNetInfo
	ActualLrpInternalRoutes []*ActualLRPInternalRoute
	MetricTags              map[string]string
	ProtoRoutable           bool
	AvailabilityZone        string
}

func (m *EvacuateRunningActualLRPRequest) GetActualLrpKey() *ActualLRPKey {
	if m != nil {
		return m.ActualLrpKey
	}
	return nil
}
func (m *EvacuateRunningActualLRPRequest) SetActualLrpKey(value *ActualLRPKey) {
	if m != nil {
		m.ActualLrpKey = value
	}
}
func (m *EvacuateRunningActualLRPRequest) GetActualLrpInstanceKey() *ActualLRPInstanceKey {
	if m != nil {
		return m.ActualLrpInstanceKey
	}
	return nil
}
func (m *EvacuateRunningActualLRPRequest) SetActualLrpInstanceKey(value *ActualLRPInstanceKey) {
	if m != nil {
		m.ActualLrpInstanceKey = value
	}
}
func (m *EvacuateRunningActualLRPRequest) GetActualLrpNetInfo() *ActualLRPNetInfo {
	if m != nil {
		return m.ActualLrpNetInfo
	}
	return nil
}
func (m *EvacuateRunningActualLRPRequest) SetActualLrpNetInfo(value *ActualLRPNetInfo) {
	if m != nil {
		m.ActualLrpNetInfo = value
	}
}
func (m *EvacuateRunningActualLRPRequest) GetActualLrpInternalRoutes() []*ActualLRPInternalRoute {
	if m != nil {
		return m.ActualLrpInternalRoutes
	}
	return nil
}
func (m *EvacuateRunningActualLRPRequest) SetActualLrpInternalRoutes(value []*ActualLRPInternalRoute) {
	if m != nil {
		m.ActualLrpInternalRoutes = value
	}
}
func (m *EvacuateRunningActualLRPRequest) GetMetricTags() map[string]string {
	if m != nil {
		return m.MetricTags
	}
	return nil
}
func (m *EvacuateRunningActualLRPRequest) SetMetricTags(value map[string]string) {
	if m != nil {
		m.MetricTags = value
	}
}
func (m *EvacuateRunningActualLRPRequest) GetProtoRoutable() bool {
	if m != nil {
		return m.ProtoRoutable
	}
	return false
}
func (m *EvacuateRunningActualLRPRequest) SetProtoRoutable(value bool) {
	if m != nil {
		m.ProtoRoutable = value
	}
}
func (m *EvacuateRunningActualLRPRequest) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}
func (m *EvacuateRunningActualLRPRequest) SetAvailabilityZone(value string) {
	if m != nil {
		m.AvailabilityZone = value
	}
}
func (x *EvacuateRunningActualLRPRequest) ToProto() *ProtoEvacuateRunningActualLRPRequest {
	proto := &ProtoEvacuateRunningActualLRPRequest{
		ActualLrpKey:            x.ActualLrpKey.ToProto(),
		ActualLrpInstanceKey:    x.ActualLrpInstanceKey.ToProto(),
		ActualLrpNetInfo:        x.ActualLrpNetInfo.ToProto(),
		ActualLrpInternalRoutes: ActualLRPInternalRouteProtoMap(x.ActualLrpInternalRoutes),
		MetricTags:              x.MetricTags,
		ProtoRoutable:           &x.ProtoRoutable,
		AvailabilityZone:        x.AvailabilityZone,
	}
	return proto
}

func EvacuateRunningActualLRPRequestProtoMap(values []*EvacuateRunningActualLRPRequest) []*ProtoEvacuateRunningActualLRPRequest {
	result := make([]*ProtoEvacuateRunningActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoEvacuateStoppedActualLRPRequest directly
type EvacuateStoppedActualLRPRequest struct {
	ActualLrpKey         *ActualLRPKey
	ActualLrpInstanceKey *ActualLRPInstanceKey
}

func (m *EvacuateStoppedActualLRPRequest) GetActualLrpKey() *ActualLRPKey {
	if m != nil {
		return m.ActualLrpKey
	}
	return nil
}
func (m *EvacuateStoppedActualLRPRequest) SetActualLrpKey(value *ActualLRPKey) {
	if m != nil {
		m.ActualLrpKey = value
	}
}
func (m *EvacuateStoppedActualLRPRequest) GetActualLrpInstanceKey() *ActualLRPInstanceKey {
	if m != nil {
		return m.ActualLrpInstanceKey
	}
	return nil
}
func (m *EvacuateStoppedActualLRPRequest) SetActualLrpInstanceKey(value *ActualLRPInstanceKey) {
	if m != nil {
		m.ActualLrpInstanceKey = value
	}
}
func (x *EvacuateStoppedActualLRPRequest) ToProto() *ProtoEvacuateStoppedActualLRPRequest {
	proto := &ProtoEvacuateStoppedActualLRPRequest{
		ActualLrpKey:         x.ActualLrpKey.ToProto(),
		ActualLrpInstanceKey: x.ActualLrpInstanceKey.ToProto(),
	}
	return proto
}

func EvacuateStoppedActualLRPRequestProtoMap(values []*EvacuateStoppedActualLRPRequest) []*ProtoEvacuateStoppedActualLRPRequest {
	result := make([]*ProtoEvacuateStoppedActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoEvacuateCrashedActualLRPRequest directly
type EvacuateCrashedActualLRPRequest struct {
	ActualLrpKey         *ActualLRPKey
	ActualLrpInstanceKey *ActualLRPInstanceKey
	ErrorMessage         string
}

func (m *EvacuateCrashedActualLRPRequest) GetActualLrpKey() *ActualLRPKey {
	if m != nil {
		return m.ActualLrpKey
	}
	return nil
}
func (m *EvacuateCrashedActualLRPRequest) SetActualLrpKey(value *ActualLRPKey) {
	if m != nil {
		m.ActualLrpKey = value
	}
}
func (m *EvacuateCrashedActualLRPRequest) GetActualLrpInstanceKey() *ActualLRPInstanceKey {
	if m != nil {
		return m.ActualLrpInstanceKey
	}
	return nil
}
func (m *EvacuateCrashedActualLRPRequest) SetActualLrpInstanceKey(value *ActualLRPInstanceKey) {
	if m != nil {
		m.ActualLrpInstanceKey = value
	}
}
func (m *EvacuateCrashedActualLRPRequest) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}
func (m *EvacuateCrashedActualLRPRequest) SetErrorMessage(value string) {
	if m != nil {
		m.ErrorMessage = value
	}
}
func (x *EvacuateCrashedActualLRPRequest) ToProto() *ProtoEvacuateCrashedActualLRPRequest {
	proto := &ProtoEvacuateCrashedActualLRPRequest{
		ActualLrpKey:         x.ActualLrpKey.ToProto(),
		ActualLrpInstanceKey: x.ActualLrpInstanceKey.ToProto(),
		ErrorMessage:         x.ErrorMessage,
	}
	return proto
}

func EvacuateCrashedActualLRPRequestProtoMap(values []*EvacuateCrashedActualLRPRequest) []*ProtoEvacuateCrashedActualLRPRequest {
	result := make([]*ProtoEvacuateCrashedActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoRemoveEvacuatingActualLRPRequest directly
type RemoveEvacuatingActualLRPRequest struct {
	ActualLrpKey         *ActualLRPKey
	ActualLrpInstanceKey *ActualLRPInstanceKey
}

func (m *RemoveEvacuatingActualLRPRequest) GetActualLrpKey() *ActualLRPKey {
	if m != nil {
		return m.ActualLrpKey
	}
	return nil
}
func (m *RemoveEvacuatingActualLRPRequest) SetActualLrpKey(value *ActualLRPKey) {
	if m != nil {
		m.ActualLrpKey = value
	}
}
func (m *RemoveEvacuatingActualLRPRequest) GetActualLrpInstanceKey() *ActualLRPInstanceKey {
	if m != nil {
		return m.ActualLrpInstanceKey
	}
	return nil
}
func (m *RemoveEvacuatingActualLRPRequest) SetActualLrpInstanceKey(value *ActualLRPInstanceKey) {
	if m != nil {
		m.ActualLrpInstanceKey = value
	}
}
func (x *RemoveEvacuatingActualLRPRequest) ToProto() *ProtoRemoveEvacuatingActualLRPRequest {
	proto := &ProtoRemoveEvacuatingActualLRPRequest{
		ActualLrpKey:         x.ActualLrpKey.ToProto(),
		ActualLrpInstanceKey: x.ActualLrpInstanceKey.ToProto(),
	}
	return proto
}

func RemoveEvacuatingActualLRPRequestProtoMap(values []*RemoveEvacuatingActualLRPRequest) []*ProtoRemoveEvacuatingActualLRPRequest {
	result := make([]*ProtoRemoveEvacuatingActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoRemoveEvacuatingActualLRPResponse directly
type RemoveEvacuatingActualLRPResponse struct {
	Error *Error
}

func (m *RemoveEvacuatingActualLRPResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *RemoveEvacuatingActualLRPResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (x *RemoveEvacuatingActualLRPResponse) ToProto() *ProtoRemoveEvacuatingActualLRPResponse {
	proto := &ProtoRemoveEvacuatingActualLRPResponse{
		Error: x.Error.ToProto(),
	}
	return proto
}

func RemoveEvacuatingActualLRPResponseProtoMap(values []*RemoveEvacuatingActualLRPResponse) []*ProtoRemoveEvacuatingActualLRPResponse {
	result := make([]*ProtoRemoveEvacuatingActualLRPResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}
