// Code generated by protoc-gen-go-bbs. DO NOT EDIT.
// versions:
// - protoc-gen-go-bbs v0.0.1
// - protoc            v5.27.0--rc1
// source: evacuation.proto

package models

// Prevent copylock errors when using ProtoEvacuationResponse directly
type EvacuationResponse struct {
	Error         *Error
	KeepContainer bool
}

func (x *EvacuationResponse) ToProto() *ProtoEvacuationResponse {
	proto := &ProtoEvacuationResponse{
		Error:         x.Error.ToProto(),
		KeepContainer: x.KeepContainer,
	}
	return proto
}

func EvacuationResponseProtoMap(values []*EvacuationResponse) []*ProtoEvacuationResponse {
	result := make([]*ProtoEvacuationResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoEvacuateClaimedActualLRPRequest directly
type EvacuateClaimedActualLRPRequest struct {
	ActualLrpKey         *ActualLRPKey
	ActualLrpInstanceKey *ActualLRPInstanceKey
}

func (x *EvacuateClaimedActualLRPRequest) ToProto() *ProtoEvacuateClaimedActualLRPRequest {
	proto := &ProtoEvacuateClaimedActualLRPRequest{
		ActualLrpKey:         x.ActualLrpKey.ToProto(),
		ActualLrpInstanceKey: x.ActualLrpInstanceKey.ToProto(),
	}
	return proto
}

func EvacuateClaimedActualLRPRequestProtoMap(values []*EvacuateClaimedActualLRPRequest) []*ProtoEvacuateClaimedActualLRPRequest {
	result := make([]*ProtoEvacuateClaimedActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoEvacuateRunningActualLRPRequest directly
type EvacuateRunningActualLRPRequest struct {
	ActualLrpKey            *ActualLRPKey
	ActualLrpInstanceKey    *ActualLRPInstanceKey
	ActualLrpNetInfo        *ActualLRPNetInfo
	ActualLrpInternalRoutes []*ActualLRPInternalRoute
	MetricTags              map[string]string
	ProtoRoutable           bool
	AvailabilityZone        string
}

func (x *EvacuateRunningActualLRPRequest) ToProto() *ProtoEvacuateRunningActualLRPRequest {
	proto := &ProtoEvacuateRunningActualLRPRequest{
		ActualLrpKey:            x.ActualLrpKey.ToProto(),
		ActualLrpInstanceKey:    x.ActualLrpInstanceKey.ToProto(),
		ActualLrpNetInfo:        x.ActualLrpNetInfo.ToProto(),
		ActualLrpInternalRoutes: ActualLRPInternalRouteProtoMap(x.ActualLrpInternalRoutes),
		MetricTags:              x.MetricTags,
		ProtoRoutable:           &x.ProtoRoutable,
		AvailabilityZone:        x.AvailabilityZone,
	}
	return proto
}

func EvacuateRunningActualLRPRequestProtoMap(values []*EvacuateRunningActualLRPRequest) []*ProtoEvacuateRunningActualLRPRequest {
	result := make([]*ProtoEvacuateRunningActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoEvacuateStoppedActualLRPRequest directly
type EvacuateStoppedActualLRPRequest struct {
	ActualLrpKey         *ActualLRPKey
	ActualLrpInstanceKey *ActualLRPInstanceKey
}

func (x *EvacuateStoppedActualLRPRequest) ToProto() *ProtoEvacuateStoppedActualLRPRequest {
	proto := &ProtoEvacuateStoppedActualLRPRequest{
		ActualLrpKey:         x.ActualLrpKey.ToProto(),
		ActualLrpInstanceKey: x.ActualLrpInstanceKey.ToProto(),
	}
	return proto
}

func EvacuateStoppedActualLRPRequestProtoMap(values []*EvacuateStoppedActualLRPRequest) []*ProtoEvacuateStoppedActualLRPRequest {
	result := make([]*ProtoEvacuateStoppedActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoEvacuateCrashedActualLRPRequest directly
type EvacuateCrashedActualLRPRequest struct {
	ActualLrpKey         *ActualLRPKey
	ActualLrpInstanceKey *ActualLRPInstanceKey
	ErrorMessage         string
}

func (x *EvacuateCrashedActualLRPRequest) ToProto() *ProtoEvacuateCrashedActualLRPRequest {
	proto := &ProtoEvacuateCrashedActualLRPRequest{
		ActualLrpKey:         x.ActualLrpKey.ToProto(),
		ActualLrpInstanceKey: x.ActualLrpInstanceKey.ToProto(),
		ErrorMessage:         x.ErrorMessage,
	}
	return proto
}

func EvacuateCrashedActualLRPRequestProtoMap(values []*EvacuateCrashedActualLRPRequest) []*ProtoEvacuateCrashedActualLRPRequest {
	result := make([]*ProtoEvacuateCrashedActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoRemoveEvacuatingActualLRPRequest directly
type RemoveEvacuatingActualLRPRequest struct {
	ActualLrpKey         *ActualLRPKey
	ActualLrpInstanceKey *ActualLRPInstanceKey
}

func (x *RemoveEvacuatingActualLRPRequest) ToProto() *ProtoRemoveEvacuatingActualLRPRequest {
	proto := &ProtoRemoveEvacuatingActualLRPRequest{
		ActualLrpKey:         x.ActualLrpKey.ToProto(),
		ActualLrpInstanceKey: x.ActualLrpInstanceKey.ToProto(),
	}
	return proto
}

func RemoveEvacuatingActualLRPRequestProtoMap(values []*RemoveEvacuatingActualLRPRequest) []*ProtoRemoveEvacuatingActualLRPRequest {
	result := make([]*ProtoRemoveEvacuatingActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoRemoveEvacuatingActualLRPResponse directly
type RemoveEvacuatingActualLRPResponse struct {
	Error *Error
}

func (x *RemoveEvacuatingActualLRPResponse) ToProto() *ProtoRemoveEvacuatingActualLRPResponse {
	proto := &ProtoRemoveEvacuatingActualLRPResponse{
		Error: x.Error.ToProto(),
	}
	return proto
}

func RemoveEvacuatingActualLRPResponseProtoMap(values []*RemoveEvacuatingActualLRPResponse) []*ProtoRemoveEvacuatingActualLRPResponse {
	result := make([]*ProtoRemoveEvacuatingActualLRPResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}
