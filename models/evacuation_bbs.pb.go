// Code generated by protoc-gen-go-bbs. DO NOT EDIT.
// versions:
// - protoc-gen-go-bbs v0.0.1
// - protoc            v5.27.0--rc1
// source: evacuation.proto

package models

// Prevent copylock errors when using ProtoEvacuationResponse directly
type EvacuationResponse struct {
	Error         *Error
	KeepContainer bool
}

func (this *EvacuationResponse) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EvacuationResponse)
	if !ok {
		that2, ok := that.(EvacuationResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.Error.Equal(that1.Error) {
		return false
	}
	if this.KeepContainer != that1.KeepContainer {
		return false
	}
	return true
}
func (m *EvacuationResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *EvacuationResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (m *EvacuationResponse) GetKeepContainer() bool {
	if m != nil {
		return m.KeepContainer
	}
	return false
}
func (m *EvacuationResponse) SetKeepContainer(value bool) {
	if m != nil {
		m.KeepContainer = value
	}
}
func (x *EvacuationResponse) ToProto() *ProtoEvacuationResponse {
	proto := &ProtoEvacuationResponse{
		Error:         x.Error.ToProto(),
		KeepContainer: x.KeepContainer,
	}
	return proto
}

func EvacuationResponseProtoMap(values []*EvacuationResponse) []*ProtoEvacuationResponse {
	result := make([]*ProtoEvacuationResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoEvacuateClaimedActualLRPRequest directly
type EvacuateClaimedActualLRPRequest struct {
	ActualLRPKey         *ActualLRPKey
	ActualLRPInstanceKey *ActualLRPInstanceKey
}

func (this *EvacuateClaimedActualLRPRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EvacuateClaimedActualLRPRequest)
	if !ok {
		that2, ok := that.(EvacuateClaimedActualLRPRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.ActualLRPKey.Equal(that1.ActualLRPKey) {
		return false
	}
	if !this.ActualLRPInstanceKey.Equal(that1.ActualLRPInstanceKey) {
		return false
	}
	return true
}
func (m *EvacuateClaimedActualLRPRequest) GetActualLRPKey() *ActualLRPKey {
	if m != nil {
		return m.ActualLRPKey
	}
	return nil
}
func (m *EvacuateClaimedActualLRPRequest) SetActualLRPKey(value *ActualLRPKey) {
	if m != nil {
		m.ActualLRPKey = value
	}
}
func (m *EvacuateClaimedActualLRPRequest) GetActualLRPInstanceKey() *ActualLRPInstanceKey {
	if m != nil {
		return m.ActualLRPInstanceKey
	}
	return nil
}
func (m *EvacuateClaimedActualLRPRequest) SetActualLRPInstanceKey(value *ActualLRPInstanceKey) {
	if m != nil {
		m.ActualLRPInstanceKey = value
	}
}
func (x *EvacuateClaimedActualLRPRequest) ToProto() *ProtoEvacuateClaimedActualLRPRequest {
	proto := &ProtoEvacuateClaimedActualLRPRequest{
		ActualLrpKey:         x.ActualLRPKey.ToProto(),
		ActualLrpInstanceKey: x.ActualLRPInstanceKey.ToProto(),
	}
	return proto
}

func EvacuateClaimedActualLRPRequestProtoMap(values []*EvacuateClaimedActualLRPRequest) []*ProtoEvacuateClaimedActualLRPRequest {
	result := make([]*ProtoEvacuateClaimedActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoEvacuateRunningActualLRPRequest directly
type EvacuateRunningActualLRPRequest struct {
	ActualLRPKey            *ActualLRPKey
	ActualLRPInstanceKey    *ActualLRPInstanceKey
	ActualLRPNetInfo        *ActualLRPNetInfo
	ActualLRPInternalRoutes []*ActualLRPInternalRoute
	MetricTags              map[string]string
	Routable                *bool
	AvailabilityZone        string
}

func (this *EvacuateRunningActualLRPRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EvacuateRunningActualLRPRequest)
	if !ok {
		that2, ok := that.(EvacuateRunningActualLRPRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.ActualLRPKey.Equal(that1.ActualLRPKey) {
		return false
	}
	if !this.ActualLRPInstanceKey.Equal(that1.ActualLRPInstanceKey) {
		return false
	}
	if !this.ActualLRPNetInfo.Equal(that1.ActualLRPNetInfo) {
		return false
	}
	if len(this.ActualLRPInternalRoutes) != len(that1.ActualLRPInternalRoutes) {
		return false
	}
	for i := range this.ActualLRPInternalRoutes {
		if !this.ActualLRPInternalRoutes[i].Equal(that1.ActualLRPInternalRoutes[i]) {
			return false
		}
	}
	if len(this.MetricTags) != len(that1.MetricTags) {
		return false
	}
	for i := range this.MetricTags {
		if this.MetricTags[i] != that1.MetricTags[i] {
			return false
		}
	}
	if this.Routable != that1.Routable {
		return false
	}
	if this.AvailabilityZone != that1.AvailabilityZone {
		return false
	}
	return true
}
func (m *EvacuateRunningActualLRPRequest) GetActualLRPKey() *ActualLRPKey {
	if m != nil {
		return m.ActualLRPKey
	}
	return nil
}
func (m *EvacuateRunningActualLRPRequest) SetActualLRPKey(value *ActualLRPKey) {
	if m != nil {
		m.ActualLRPKey = value
	}
}
func (m *EvacuateRunningActualLRPRequest) GetActualLRPInstanceKey() *ActualLRPInstanceKey {
	if m != nil {
		return m.ActualLRPInstanceKey
	}
	return nil
}
func (m *EvacuateRunningActualLRPRequest) SetActualLRPInstanceKey(value *ActualLRPInstanceKey) {
	if m != nil {
		m.ActualLRPInstanceKey = value
	}
}
func (m *EvacuateRunningActualLRPRequest) GetActualLRPNetInfo() *ActualLRPNetInfo {
	if m != nil {
		return m.ActualLRPNetInfo
	}
	return nil
}
func (m *EvacuateRunningActualLRPRequest) SetActualLRPNetInfo(value *ActualLRPNetInfo) {
	if m != nil {
		m.ActualLRPNetInfo = value
	}
}
func (m *EvacuateRunningActualLRPRequest) GetActualLRPInternalRoutes() []*ActualLRPInternalRoute {
	if m != nil {
		return m.ActualLRPInternalRoutes
	}
	return nil
}
func (m *EvacuateRunningActualLRPRequest) SetActualLRPInternalRoutes(value []*ActualLRPInternalRoute) {
	if m != nil {
		m.ActualLRPInternalRoutes = value
	}
}
func (m *EvacuateRunningActualLRPRequest) GetMetricTags() map[string]string {
	if m != nil {
		return m.MetricTags
	}
	return nil
}
func (m *EvacuateRunningActualLRPRequest) SetMetricTags(value map[string]string) {
	if m != nil {
		m.MetricTags = value
	}
}
func (m *EvacuateRunningActualLRPRequest) RoutableExists() bool {
	return m != nil && m.Routable != nil
}
func (m *EvacuateRunningActualLRPRequest) GetRoutable() *bool {
	if m != nil && m.Routable != nil {
		return m.Routable
	}
	return nil
}
func (m *EvacuateRunningActualLRPRequest) SetRoutable(value *bool) {
	if m != nil {
		m.Routable = value
	}
}
func (m *EvacuateRunningActualLRPRequest) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}
func (m *EvacuateRunningActualLRPRequest) SetAvailabilityZone(value string) {
	if m != nil {
		m.AvailabilityZone = value
	}
}
func (x *EvacuateRunningActualLRPRequest) ToProto() *ProtoEvacuateRunningActualLRPRequest {
	proto := &ProtoEvacuateRunningActualLRPRequest{
		ActualLrpKey:            x.ActualLRPKey.ToProto(),
		ActualLrpInstanceKey:    x.ActualLRPInstanceKey.ToProto(),
		ActualLrpNetInfo:        x.ActualLRPNetInfo.ToProto(),
		ActualLrpInternalRoutes: ActualLRPInternalRouteProtoMap(x.ActualLRPInternalRoutes),
		MetricTags:              x.MetricTags,
		Routable:                &x.Routable,
		AvailabilityZone:        x.AvailabilityZone,
	}
	return proto
}

func EvacuateRunningActualLRPRequestProtoMap(values []*EvacuateRunningActualLRPRequest) []*ProtoEvacuateRunningActualLRPRequest {
	result := make([]*ProtoEvacuateRunningActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoEvacuateStoppedActualLRPRequest directly
type EvacuateStoppedActualLRPRequest struct {
	ActualLRPKey         *ActualLRPKey
	ActualLRPInstanceKey *ActualLRPInstanceKey
}

func (this *EvacuateStoppedActualLRPRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EvacuateStoppedActualLRPRequest)
	if !ok {
		that2, ok := that.(EvacuateStoppedActualLRPRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.ActualLRPKey.Equal(that1.ActualLRPKey) {
		return false
	}
	if !this.ActualLRPInstanceKey.Equal(that1.ActualLRPInstanceKey) {
		return false
	}
	return true
}
func (m *EvacuateStoppedActualLRPRequest) GetActualLRPKey() *ActualLRPKey {
	if m != nil {
		return m.ActualLRPKey
	}
	return nil
}
func (m *EvacuateStoppedActualLRPRequest) SetActualLRPKey(value *ActualLRPKey) {
	if m != nil {
		m.ActualLRPKey = value
	}
}
func (m *EvacuateStoppedActualLRPRequest) GetActualLRPInstanceKey() *ActualLRPInstanceKey {
	if m != nil {
		return m.ActualLRPInstanceKey
	}
	return nil
}
func (m *EvacuateStoppedActualLRPRequest) SetActualLRPInstanceKey(value *ActualLRPInstanceKey) {
	if m != nil {
		m.ActualLRPInstanceKey = value
	}
}
func (x *EvacuateStoppedActualLRPRequest) ToProto() *ProtoEvacuateStoppedActualLRPRequest {
	proto := &ProtoEvacuateStoppedActualLRPRequest{
		ActualLrpKey:         x.ActualLRPKey.ToProto(),
		ActualLrpInstanceKey: x.ActualLRPInstanceKey.ToProto(),
	}
	return proto
}

func EvacuateStoppedActualLRPRequestProtoMap(values []*EvacuateStoppedActualLRPRequest) []*ProtoEvacuateStoppedActualLRPRequest {
	result := make([]*ProtoEvacuateStoppedActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoEvacuateCrashedActualLRPRequest directly
type EvacuateCrashedActualLRPRequest struct {
	ActualLRPKey         *ActualLRPKey
	ActualLRPInstanceKey *ActualLRPInstanceKey
	ErrorMessage         string
}

func (this *EvacuateCrashedActualLRPRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EvacuateCrashedActualLRPRequest)
	if !ok {
		that2, ok := that.(EvacuateCrashedActualLRPRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.ActualLRPKey.Equal(that1.ActualLRPKey) {
		return false
	}
	if !this.ActualLRPInstanceKey.Equal(that1.ActualLRPInstanceKey) {
		return false
	}
	if this.ErrorMessage != that1.ErrorMessage {
		return false
	}
	return true
}
func (m *EvacuateCrashedActualLRPRequest) GetActualLRPKey() *ActualLRPKey {
	if m != nil {
		return m.ActualLRPKey
	}
	return nil
}
func (m *EvacuateCrashedActualLRPRequest) SetActualLRPKey(value *ActualLRPKey) {
	if m != nil {
		m.ActualLRPKey = value
	}
}
func (m *EvacuateCrashedActualLRPRequest) GetActualLRPInstanceKey() *ActualLRPInstanceKey {
	if m != nil {
		return m.ActualLRPInstanceKey
	}
	return nil
}
func (m *EvacuateCrashedActualLRPRequest) SetActualLRPInstanceKey(value *ActualLRPInstanceKey) {
	if m != nil {
		m.ActualLRPInstanceKey = value
	}
}
func (m *EvacuateCrashedActualLRPRequest) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}
func (m *EvacuateCrashedActualLRPRequest) SetErrorMessage(value string) {
	if m != nil {
		m.ErrorMessage = value
	}
}
func (x *EvacuateCrashedActualLRPRequest) ToProto() *ProtoEvacuateCrashedActualLRPRequest {
	proto := &ProtoEvacuateCrashedActualLRPRequest{
		ActualLrpKey:         x.ActualLRPKey.ToProto(),
		ActualLrpInstanceKey: x.ActualLRPInstanceKey.ToProto(),
		ErrorMessage:         x.ErrorMessage,
	}
	return proto
}

func EvacuateCrashedActualLRPRequestProtoMap(values []*EvacuateCrashedActualLRPRequest) []*ProtoEvacuateCrashedActualLRPRequest {
	result := make([]*ProtoEvacuateCrashedActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoRemoveEvacuatingActualLRPRequest directly
type RemoveEvacuatingActualLRPRequest struct {
	ActualLRPKey         *ActualLRPKey
	ActualLRPInstanceKey *ActualLRPInstanceKey
}

func (this *RemoveEvacuatingActualLRPRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoveEvacuatingActualLRPRequest)
	if !ok {
		that2, ok := that.(RemoveEvacuatingActualLRPRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.ActualLRPKey.Equal(that1.ActualLRPKey) {
		return false
	}
	if !this.ActualLRPInstanceKey.Equal(that1.ActualLRPInstanceKey) {
		return false
	}
	return true
}
func (m *RemoveEvacuatingActualLRPRequest) GetActualLRPKey() *ActualLRPKey {
	if m != nil {
		return m.ActualLRPKey
	}
	return nil
}
func (m *RemoveEvacuatingActualLRPRequest) SetActualLRPKey(value *ActualLRPKey) {
	if m != nil {
		m.ActualLRPKey = value
	}
}
func (m *RemoveEvacuatingActualLRPRequest) GetActualLRPInstanceKey() *ActualLRPInstanceKey {
	if m != nil {
		return m.ActualLRPInstanceKey
	}
	return nil
}
func (m *RemoveEvacuatingActualLRPRequest) SetActualLRPInstanceKey(value *ActualLRPInstanceKey) {
	if m != nil {
		m.ActualLRPInstanceKey = value
	}
}
func (x *RemoveEvacuatingActualLRPRequest) ToProto() *ProtoRemoveEvacuatingActualLRPRequest {
	proto := &ProtoRemoveEvacuatingActualLRPRequest{
		ActualLrpKey:         x.ActualLRPKey.ToProto(),
		ActualLrpInstanceKey: x.ActualLRPInstanceKey.ToProto(),
	}
	return proto
}

func RemoveEvacuatingActualLRPRequestProtoMap(values []*RemoveEvacuatingActualLRPRequest) []*ProtoRemoveEvacuatingActualLRPRequest {
	result := make([]*ProtoRemoveEvacuatingActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoRemoveEvacuatingActualLRPResponse directly
type RemoveEvacuatingActualLRPResponse struct {
	Error *Error
}

func (this *RemoveEvacuatingActualLRPResponse) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoveEvacuatingActualLRPResponse)
	if !ok {
		that2, ok := that.(RemoveEvacuatingActualLRPResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (m *RemoveEvacuatingActualLRPResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *RemoveEvacuatingActualLRPResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (x *RemoveEvacuatingActualLRPResponse) ToProto() *ProtoRemoveEvacuatingActualLRPResponse {
	proto := &ProtoRemoveEvacuatingActualLRPResponse{
		Error: x.Error.ToProto(),
	}
	return proto
}

func RemoveEvacuatingActualLRPResponseProtoMap(values []*RemoveEvacuatingActualLRPResponse) []*ProtoRemoveEvacuatingActualLRPResponse {
	result := make([]*ProtoRemoveEvacuatingActualLRPResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}
