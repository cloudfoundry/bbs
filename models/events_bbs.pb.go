// Code generated by protoc-gen-go-bbs. DO NOT EDIT.
// versions:
// - protoc-gen-go-bbs v0.0.1
// - protoc            v5.27.0--rc1
// source: events.proto

package models

// Prevent copylock errors when using ProtoActualLRPCreatedEvent directly
type ActualLRPCreatedEvent struct {
	ActualLrpGroup *ActualLRPGroup
}

func (x *ActualLRPCreatedEvent) ToProto() *ProtoActualLRPCreatedEvent {
	proto := &ProtoActualLRPCreatedEvent{
		ActualLrpGroup: x.ActualLrpGroup.ToProto(),
	}
	return proto
}

func ActualLRPCreatedEventProtoMap(values []*ActualLRPCreatedEvent) []*ProtoActualLRPCreatedEvent {
	result := make([]*ProtoActualLRPCreatedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPChangedEvent directly
type ActualLRPChangedEvent struct {
	Before *ActualLRPGroup
	After  *ActualLRPGroup
}

func (x *ActualLRPChangedEvent) ToProto() *ProtoActualLRPChangedEvent {
	proto := &ProtoActualLRPChangedEvent{
		Before: x.Before.ToProto(),
		After:  x.After.ToProto(),
	}
	return proto
}

func ActualLRPChangedEventProtoMap(values []*ActualLRPChangedEvent) []*ProtoActualLRPChangedEvent {
	result := make([]*ProtoActualLRPChangedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPRemovedEvent directly
type ActualLRPRemovedEvent struct {
	ActualLrpGroup *ActualLRPGroup
}

func (x *ActualLRPRemovedEvent) ToProto() *ProtoActualLRPRemovedEvent {
	proto := &ProtoActualLRPRemovedEvent{
		ActualLrpGroup: x.ActualLrpGroup.ToProto(),
	}
	return proto
}

func ActualLRPRemovedEventProtoMap(values []*ActualLRPRemovedEvent) []*ProtoActualLRPRemovedEvent {
	result := make([]*ProtoActualLRPRemovedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPInstanceCreatedEvent directly
type ActualLRPInstanceCreatedEvent struct {
	ActualLrp *ActualLRP
	TraceId   string
}

func (x *ActualLRPInstanceCreatedEvent) ToProto() *ProtoActualLRPInstanceCreatedEvent {
	proto := &ProtoActualLRPInstanceCreatedEvent{
		ActualLrp: x.ActualLrp.ToProto(),
		TraceId:   x.TraceId,
	}
	return proto
}

func ActualLRPInstanceCreatedEventProtoMap(values []*ActualLRPInstanceCreatedEvent) []*ProtoActualLRPInstanceCreatedEvent {
	result := make([]*ProtoActualLRPInstanceCreatedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPInfo directly
type ActualLRPInfo struct {
	ActualLrpNetInfo *ActualLRPNetInfo
	CrashCount       int32
	CrashReason      string
	State            string
	PlacementError   string
	Since            int64
	ModificationTag  *ModificationTag
	Presence         ActualLRP_Presence
	ProtoRoutable    bool
	AvailabilityZone string
}

func (x *ActualLRPInfo) ToProto() *ProtoActualLRPInfo {
	proto := &ProtoActualLRPInfo{
		ActualLrpNetInfo: x.ActualLrpNetInfo.ToProto(),
		CrashCount:       x.CrashCount,
		CrashReason:      x.CrashReason,
		State:            x.State,
		PlacementError:   x.PlacementError,
		Since:            x.Since,
		ModificationTag:  x.ModificationTag.ToProto(),
		Presence:         ProtoActualLRPInfo_Presence(x.Presence),
		ProtoRoutable:    &x.ProtoRoutable,
		AvailabilityZone: x.AvailabilityZone,
	}
	return proto
}

func ActualLRPInfoProtoMap(values []*ActualLRPInfo) []*ProtoActualLRPInfo {
	result := make([]*ProtoActualLRPInfo, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPInstanceChangedEvent directly
type ActualLRPInstanceChangedEvent struct {
	ActualLrpKey         *ActualLRPKey
	ActualLrpInstanceKey *ActualLRPInstanceKey
	Before               *ActualLRPInfo
	After                *ActualLRPInfo
	TraceId              string
}

func (x *ActualLRPInstanceChangedEvent) ToProto() *ProtoActualLRPInstanceChangedEvent {
	proto := &ProtoActualLRPInstanceChangedEvent{
		ActualLrpKey:         x.ActualLrpKey.ToProto(),
		ActualLrpInstanceKey: x.ActualLrpInstanceKey.ToProto(),
		Before:               x.Before.ToProto(),
		After:                x.After.ToProto(),
		TraceId:              x.TraceId,
	}
	return proto
}

func ActualLRPInstanceChangedEventProtoMap(values []*ActualLRPInstanceChangedEvent) []*ProtoActualLRPInstanceChangedEvent {
	result := make([]*ProtoActualLRPInstanceChangedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPInstanceRemovedEvent directly
type ActualLRPInstanceRemovedEvent struct {
	ActualLrp *ActualLRP
	TraceId   string
}

func (x *ActualLRPInstanceRemovedEvent) ToProto() *ProtoActualLRPInstanceRemovedEvent {
	proto := &ProtoActualLRPInstanceRemovedEvent{
		ActualLrp: x.ActualLrp.ToProto(),
		TraceId:   x.TraceId,
	}
	return proto
}

func ActualLRPInstanceRemovedEventProtoMap(values []*ActualLRPInstanceRemovedEvent) []*ProtoActualLRPInstanceRemovedEvent {
	result := make([]*ProtoActualLRPInstanceRemovedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPCreatedEvent directly
type DesiredLRPCreatedEvent struct {
	DesiredLrp *DesiredLRP
	TraceId    string
}

func (x *DesiredLRPCreatedEvent) ToProto() *ProtoDesiredLRPCreatedEvent {
	proto := &ProtoDesiredLRPCreatedEvent{
		DesiredLrp: x.DesiredLrp.ToProto(),
		TraceId:    x.TraceId,
	}
	return proto
}

func DesiredLRPCreatedEventProtoMap(values []*DesiredLRPCreatedEvent) []*ProtoDesiredLRPCreatedEvent {
	result := make([]*ProtoDesiredLRPCreatedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPChangedEvent directly
type DesiredLRPChangedEvent struct {
	Before  *DesiredLRP
	After   *DesiredLRP
	TraceId string
}

func (x *DesiredLRPChangedEvent) ToProto() *ProtoDesiredLRPChangedEvent {
	proto := &ProtoDesiredLRPChangedEvent{
		Before:  x.Before.ToProto(),
		After:   x.After.ToProto(),
		TraceId: x.TraceId,
	}
	return proto
}

func DesiredLRPChangedEventProtoMap(values []*DesiredLRPChangedEvent) []*ProtoDesiredLRPChangedEvent {
	result := make([]*ProtoDesiredLRPChangedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPRemovedEvent directly
type DesiredLRPRemovedEvent struct {
	DesiredLrp *DesiredLRP
	TraceId    string
}

func (x *DesiredLRPRemovedEvent) ToProto() *ProtoDesiredLRPRemovedEvent {
	proto := &ProtoDesiredLRPRemovedEvent{
		DesiredLrp: x.DesiredLrp.ToProto(),
		TraceId:    x.TraceId,
	}
	return proto
}

func DesiredLRPRemovedEventProtoMap(values []*DesiredLRPRemovedEvent) []*ProtoDesiredLRPRemovedEvent {
	result := make([]*ProtoDesiredLRPRemovedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPCrashedEvent directly
type ActualLRPCrashedEvent struct {
	ActualLrpKey         *ActualLRPKey
	ActualLrpInstanceKey *ActualLRPInstanceKey
	CrashCount           int32
	CrashReason          string
	Since                int64
}

func (x *ActualLRPCrashedEvent) ToProto() *ProtoActualLRPCrashedEvent {
	proto := &ProtoActualLRPCrashedEvent{
		ActualLrpKey:         x.ActualLrpKey.ToProto(),
		ActualLrpInstanceKey: x.ActualLrpInstanceKey.ToProto(),
		CrashCount:           x.CrashCount,
		CrashReason:          x.CrashReason,
		Since:                x.Since,
	}
	return proto
}

func ActualLRPCrashedEventProtoMap(values []*ActualLRPCrashedEvent) []*ProtoActualLRPCrashedEvent {
	result := make([]*ProtoActualLRPCrashedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoEventsByCellId directly
type EventsByCellId struct {
	CellId string
}

func (x *EventsByCellId) ToProto() *ProtoEventsByCellId {
	proto := &ProtoEventsByCellId{
		CellId: x.CellId,
	}
	return proto
}

func EventsByCellIdProtoMap(values []*EventsByCellId) []*ProtoEventsByCellId {
	result := make([]*ProtoEventsByCellId, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoTaskCreatedEvent directly
type TaskCreatedEvent struct {
	Task *Task
}

func (x *TaskCreatedEvent) ToProto() *ProtoTaskCreatedEvent {
	proto := &ProtoTaskCreatedEvent{
		Task: x.Task.ToProto(),
	}
	return proto
}

func TaskCreatedEventProtoMap(values []*TaskCreatedEvent) []*ProtoTaskCreatedEvent {
	result := make([]*ProtoTaskCreatedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoTaskChangedEvent directly
type TaskChangedEvent struct {
	Before *Task
	After  *Task
}

func (x *TaskChangedEvent) ToProto() *ProtoTaskChangedEvent {
	proto := &ProtoTaskChangedEvent{
		Before: x.Before.ToProto(),
		After:  x.After.ToProto(),
	}
	return proto
}

func TaskChangedEventProtoMap(values []*TaskChangedEvent) []*ProtoTaskChangedEvent {
	result := make([]*ProtoTaskChangedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoTaskRemovedEvent directly
type TaskRemovedEvent struct {
	Task *Task
}

func (x *TaskRemovedEvent) ToProto() *ProtoTaskRemovedEvent {
	proto := &ProtoTaskRemovedEvent{
		Task: x.Task.ToProto(),
	}
	return proto
}

func TaskRemovedEventProtoMap(values []*TaskRemovedEvent) []*ProtoTaskRemovedEvent {
	result := make([]*ProtoTaskRemovedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}
