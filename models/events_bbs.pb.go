// Code generated by protoc-gen-go-bbs. DO NOT EDIT.
// versions:
// - protoc-gen-go-bbs v0.0.1
// - protoc            v5.29.3
// source: events.proto

package models

// Deprecated: marked deprecated in events.proto
// Prevent copylock errors when using ProtoActualLRPCreatedEvent directly
type ActualLRPCreatedEvent struct {
	ActualLrpGroup *ActualLRPGroup `json:"actual_lrp_group,omitempty"`
}

func (this *ActualLRPCreatedEvent) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPCreatedEvent)
	if !ok {
		that2, ok := that.(ActualLRPCreatedEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.ActualLrpGroup == nil {
		if that1.ActualLrpGroup != nil {
			return false
		}
	} else if !this.ActualLrpGroup.Equal(*that1.ActualLrpGroup) {
		return false
	}
	return true
}
func (m *ActualLRPCreatedEvent) GetActualLrpGroup() *ActualLRPGroup {
	if m != nil {
		return m.ActualLrpGroup
	}
	return nil
}
func (m *ActualLRPCreatedEvent) SetActualLrpGroup(value *ActualLRPGroup) {
	if m != nil {
		m.ActualLrpGroup = value
	}
}
func (x *ActualLRPCreatedEvent) ToProto() *ProtoActualLRPCreatedEvent {
	if x == nil {
		return nil
	}

	proto := &ProtoActualLRPCreatedEvent{
		ActualLrpGroup: x.ActualLrpGroup.ToProto(),
	}
	return proto
}

func (x *ProtoActualLRPCreatedEvent) FromProto() *ActualLRPCreatedEvent {
	if x == nil {
		return nil
	}

	copysafe := &ActualLRPCreatedEvent{
		ActualLrpGroup: x.ActualLrpGroup.FromProto(),
	}
	return copysafe
}

func ActualLRPCreatedEventToProtoSlice(values []*ActualLRPCreatedEvent) []*ProtoActualLRPCreatedEvent {
	if values == nil {
		return nil
	}
	result := make([]*ProtoActualLRPCreatedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func ActualLRPCreatedEventFromProtoSlice(values []*ProtoActualLRPCreatedEvent) []*ActualLRPCreatedEvent {
	if values == nil {
		return nil
	}
	result := make([]*ActualLRPCreatedEvent, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Deprecated: marked deprecated in events.proto
// Prevent copylock errors when using ProtoActualLRPChangedEvent directly
type ActualLRPChangedEvent struct {
	Before *ActualLRPGroup `json:"before,omitempty"`
	After  *ActualLRPGroup `json:"after,omitempty"`
}

func (this *ActualLRPChangedEvent) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPChangedEvent)
	if !ok {
		that2, ok := that.(ActualLRPChangedEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Before == nil {
		if that1.Before != nil {
			return false
		}
	} else if !this.Before.Equal(*that1.Before) {
		return false
	}
	if this.After == nil {
		if that1.After != nil {
			return false
		}
	} else if !this.After.Equal(*that1.After) {
		return false
	}
	return true
}
func (m *ActualLRPChangedEvent) GetBefore() *ActualLRPGroup {
	if m != nil {
		return m.Before
	}
	return nil
}
func (m *ActualLRPChangedEvent) SetBefore(value *ActualLRPGroup) {
	if m != nil {
		m.Before = value
	}
}
func (m *ActualLRPChangedEvent) GetAfter() *ActualLRPGroup {
	if m != nil {
		return m.After
	}
	return nil
}
func (m *ActualLRPChangedEvent) SetAfter(value *ActualLRPGroup) {
	if m != nil {
		m.After = value
	}
}
func (x *ActualLRPChangedEvent) ToProto() *ProtoActualLRPChangedEvent {
	if x == nil {
		return nil
	}

	proto := &ProtoActualLRPChangedEvent{
		Before: x.Before.ToProto(),
		After:  x.After.ToProto(),
	}
	return proto
}

func (x *ProtoActualLRPChangedEvent) FromProto() *ActualLRPChangedEvent {
	if x == nil {
		return nil
	}

	copysafe := &ActualLRPChangedEvent{
		Before: x.Before.FromProto(),
		After:  x.After.FromProto(),
	}
	return copysafe
}

func ActualLRPChangedEventToProtoSlice(values []*ActualLRPChangedEvent) []*ProtoActualLRPChangedEvent {
	if values == nil {
		return nil
	}
	result := make([]*ProtoActualLRPChangedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func ActualLRPChangedEventFromProtoSlice(values []*ProtoActualLRPChangedEvent) []*ActualLRPChangedEvent {
	if values == nil {
		return nil
	}
	result := make([]*ActualLRPChangedEvent, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Deprecated: marked deprecated in events.proto
// Prevent copylock errors when using ProtoActualLRPRemovedEvent directly
type ActualLRPRemovedEvent struct {
	ActualLrpGroup *ActualLRPGroup `json:"actual_lrp_group,omitempty"`
}

func (this *ActualLRPRemovedEvent) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPRemovedEvent)
	if !ok {
		that2, ok := that.(ActualLRPRemovedEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.ActualLrpGroup == nil {
		if that1.ActualLrpGroup != nil {
			return false
		}
	} else if !this.ActualLrpGroup.Equal(*that1.ActualLrpGroup) {
		return false
	}
	return true
}
func (m *ActualLRPRemovedEvent) GetActualLrpGroup() *ActualLRPGroup {
	if m != nil {
		return m.ActualLrpGroup
	}
	return nil
}
func (m *ActualLRPRemovedEvent) SetActualLrpGroup(value *ActualLRPGroup) {
	if m != nil {
		m.ActualLrpGroup = value
	}
}
func (x *ActualLRPRemovedEvent) ToProto() *ProtoActualLRPRemovedEvent {
	if x == nil {
		return nil
	}

	proto := &ProtoActualLRPRemovedEvent{
		ActualLrpGroup: x.ActualLrpGroup.ToProto(),
	}
	return proto
}

func (x *ProtoActualLRPRemovedEvent) FromProto() *ActualLRPRemovedEvent {
	if x == nil {
		return nil
	}

	copysafe := &ActualLRPRemovedEvent{
		ActualLrpGroup: x.ActualLrpGroup.FromProto(),
	}
	return copysafe
}

func ActualLRPRemovedEventToProtoSlice(values []*ActualLRPRemovedEvent) []*ProtoActualLRPRemovedEvent {
	if values == nil {
		return nil
	}
	result := make([]*ProtoActualLRPRemovedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func ActualLRPRemovedEventFromProtoSlice(values []*ProtoActualLRPRemovedEvent) []*ActualLRPRemovedEvent {
	if values == nil {
		return nil
	}
	result := make([]*ActualLRPRemovedEvent, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPInstanceCreatedEvent directly
type ActualLRPInstanceCreatedEvent struct {
	ActualLrp *ActualLRP `json:"actual_lrp,omitempty"`
	TraceId   string     `json:"trace_id"`
}

func (this *ActualLRPInstanceCreatedEvent) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPInstanceCreatedEvent)
	if !ok {
		that2, ok := that.(ActualLRPInstanceCreatedEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.ActualLrp == nil {
		if that1.ActualLrp != nil {
			return false
		}
	} else if !this.ActualLrp.Equal(*that1.ActualLrp) {
		return false
	}
	if this.TraceId != that1.TraceId {
		return false
	}
	return true
}
func (m *ActualLRPInstanceCreatedEvent) GetActualLrp() *ActualLRP {
	if m != nil {
		return m.ActualLrp
	}
	return nil
}
func (m *ActualLRPInstanceCreatedEvent) SetActualLrp(value *ActualLRP) {
	if m != nil {
		m.ActualLrp = value
	}
}
func (m *ActualLRPInstanceCreatedEvent) GetTraceId() string {
	if m != nil {
		return m.TraceId
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *ActualLRPInstanceCreatedEvent) SetTraceId(value string) {
	if m != nil {
		m.TraceId = value
	}
}
func (x *ActualLRPInstanceCreatedEvent) ToProto() *ProtoActualLRPInstanceCreatedEvent {
	if x == nil {
		return nil
	}

	proto := &ProtoActualLRPInstanceCreatedEvent{
		ActualLrp: x.ActualLrp.ToProto(),
		TraceId:   x.TraceId,
	}
	return proto
}

func (x *ProtoActualLRPInstanceCreatedEvent) FromProto() *ActualLRPInstanceCreatedEvent {
	if x == nil {
		return nil
	}

	copysafe := &ActualLRPInstanceCreatedEvent{
		ActualLrp: x.ActualLrp.FromProto(),
		TraceId:   x.TraceId,
	}
	return copysafe
}

func ActualLRPInstanceCreatedEventToProtoSlice(values []*ActualLRPInstanceCreatedEvent) []*ProtoActualLRPInstanceCreatedEvent {
	if values == nil {
		return nil
	}
	result := make([]*ProtoActualLRPInstanceCreatedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func ActualLRPInstanceCreatedEventFromProtoSlice(values []*ProtoActualLRPInstanceCreatedEvent) []*ActualLRPInstanceCreatedEvent {
	if values == nil {
		return nil
	}
	result := make([]*ActualLRPInstanceCreatedEvent, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPInfo directly
type ActualLRPInfo struct {
	ActualLrpNetInfo ActualLRPNetInfo   `json:"actual_lrp_net_info"`
	CrashCount       int32              `json:"crash_count"`
	CrashReason      string             `json:"crash_reason,omitempty"`
	State            string             `json:"state"`
	PlacementError   string             `json:"placement_error,omitempty"`
	Since            int64              `json:"since"`
	ModificationTag  ModificationTag    `json:"modification_tag"`
	Presence         ActualLRP_Presence `json:"presence"`
	Routable         *bool              `json:"Routable,omitempty"`
	AvailabilityZone string             `json:"availability_zone"`
}

func (this *ActualLRPInfo) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPInfo)
	if !ok {
		that2, ok := that.(ActualLRPInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.ActualLrpNetInfo.Equal(that1.ActualLrpNetInfo) {
		return false
	}
	if this.CrashCount != that1.CrashCount {
		return false
	}
	if this.CrashReason != that1.CrashReason {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.PlacementError != that1.PlacementError {
		return false
	}
	if this.Since != that1.Since {
		return false
	}
	if !this.ModificationTag.Equal(that1.ModificationTag) {
		return false
	}
	if this.Presence != that1.Presence {
		return false
	}
	if this.Routable == nil {
		if that1.Routable != nil {
			return false
		}
	} else if *this.Routable != *that1.Routable {
		return false
	}
	if this.AvailabilityZone != that1.AvailabilityZone {
		return false
	}
	return true
}
func (m *ActualLRPInfo) SetActualLrpNetInfo(value ActualLRPNetInfo) {
	if m != nil {
		m.ActualLrpNetInfo = value
	}
}
func (m *ActualLRPInfo) GetCrashCount() int32 {
	if m != nil {
		return m.CrashCount
	}
	var defaultValue int32
	defaultValue = 0
	return defaultValue
}
func (m *ActualLRPInfo) SetCrashCount(value int32) {
	if m != nil {
		m.CrashCount = value
	}
}
func (m *ActualLRPInfo) GetCrashReason() string {
	if m != nil {
		return m.CrashReason
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *ActualLRPInfo) SetCrashReason(value string) {
	if m != nil {
		m.CrashReason = value
	}
}
func (m *ActualLRPInfo) GetState() string {
	if m != nil {
		return m.State
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *ActualLRPInfo) SetState(value string) {
	if m != nil {
		m.State = value
	}
}
func (m *ActualLRPInfo) GetPlacementError() string {
	if m != nil {
		return m.PlacementError
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *ActualLRPInfo) SetPlacementError(value string) {
	if m != nil {
		m.PlacementError = value
	}
}
func (m *ActualLRPInfo) GetSince() int64 {
	if m != nil {
		return m.Since
	}
	var defaultValue int64
	defaultValue = 0
	return defaultValue
}
func (m *ActualLRPInfo) SetSince(value int64) {
	if m != nil {
		m.Since = value
	}
}
func (m *ActualLRPInfo) SetModificationTag(value ModificationTag) {
	if m != nil {
		m.ModificationTag = value
	}
}
func (m *ActualLRPInfo) SetPresence(value ActualLRP_Presence) {
	if m != nil {
		m.Presence = value
	}
}
func (m *ActualLRPInfo) RoutableExists() bool {
	return m != nil && m.Routable != nil
}
func (m *ActualLRPInfo) GetRoutable() *bool {
	if m != nil && m.Routable != nil {
		return m.Routable
	}
	var defaultValue bool
	defaultValue = false
	return &defaultValue
}
func (m *ActualLRPInfo) SetRoutable(value *bool) {
	if m != nil {
		m.Routable = value
	}
}
func (m *ActualLRPInfo) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *ActualLRPInfo) SetAvailabilityZone(value string) {
	if m != nil {
		m.AvailabilityZone = value
	}
}
func (x *ActualLRPInfo) ToProto() *ProtoActualLRPInfo {
	if x == nil {
		return nil
	}

	proto := &ProtoActualLRPInfo{
		ActualLrpNetInfo: x.ActualLrpNetInfo.ToProto(),
		CrashCount:       x.CrashCount,
		CrashReason:      x.CrashReason,
		State:            x.State,
		PlacementError:   x.PlacementError,
		Since:            x.Since,
		ModificationTag:  x.ModificationTag.ToProto(),
		Presence:         ProtoActualLRP_Presence(x.Presence),
		Routable:         x.Routable,
		AvailabilityZone: x.AvailabilityZone,
	}
	return proto
}

func (x *ProtoActualLRPInfo) FromProto() *ActualLRPInfo {
	if x == nil {
		return nil
	}

	copysafe := &ActualLRPInfo{
		ActualLrpNetInfo: *x.ActualLrpNetInfo.FromProto(),
		CrashCount:       x.CrashCount,
		CrashReason:      x.CrashReason,
		State:            x.State,
		PlacementError:   x.PlacementError,
		Since:            x.Since,
		ModificationTag:  *x.ModificationTag.FromProto(),
		Presence:         ActualLRP_Presence(x.Presence),
		Routable:         x.Routable,
		AvailabilityZone: x.AvailabilityZone,
	}
	return copysafe
}

func ActualLRPInfoToProtoSlice(values []*ActualLRPInfo) []*ProtoActualLRPInfo {
	if values == nil {
		return nil
	}
	result := make([]*ProtoActualLRPInfo, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func ActualLRPInfoFromProtoSlice(values []*ProtoActualLRPInfo) []*ActualLRPInfo {
	if values == nil {
		return nil
	}
	result := make([]*ActualLRPInfo, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPInstanceChangedEvent directly
type ActualLRPInstanceChangedEvent struct {
	ActualLrpKey         ActualLRPKey         `json:"actual_lrp_key"`
	ActualLrpInstanceKey ActualLRPInstanceKey `json:"actual_lrp_instance_key"`
	Before               *ActualLRPInfo       `json:"before,omitempty"`
	After                *ActualLRPInfo       `json:"after,omitempty"`
	TraceId              string               `json:"trace_id"`
}

func (this *ActualLRPInstanceChangedEvent) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPInstanceChangedEvent)
	if !ok {
		that2, ok := that.(ActualLRPInstanceChangedEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.ActualLrpKey.Equal(that1.ActualLrpKey) {
		return false
	}
	if !this.ActualLrpInstanceKey.Equal(that1.ActualLrpInstanceKey) {
		return false
	}
	if this.Before == nil {
		if that1.Before != nil {
			return false
		}
	} else if !this.Before.Equal(*that1.Before) {
		return false
	}
	if this.After == nil {
		if that1.After != nil {
			return false
		}
	} else if !this.After.Equal(*that1.After) {
		return false
	}
	if this.TraceId != that1.TraceId {
		return false
	}
	return true
}
func (m *ActualLRPInstanceChangedEvent) SetActualLrpKey(value ActualLRPKey) {
	if m != nil {
		m.ActualLrpKey = value
	}
}
func (m *ActualLRPInstanceChangedEvent) SetActualLrpInstanceKey(value ActualLRPInstanceKey) {
	if m != nil {
		m.ActualLrpInstanceKey = value
	}
}
func (m *ActualLRPInstanceChangedEvent) GetBefore() *ActualLRPInfo {
	if m != nil {
		return m.Before
	}
	return nil
}
func (m *ActualLRPInstanceChangedEvent) SetBefore(value *ActualLRPInfo) {
	if m != nil {
		m.Before = value
	}
}
func (m *ActualLRPInstanceChangedEvent) GetAfter() *ActualLRPInfo {
	if m != nil {
		return m.After
	}
	return nil
}
func (m *ActualLRPInstanceChangedEvent) SetAfter(value *ActualLRPInfo) {
	if m != nil {
		m.After = value
	}
}
func (m *ActualLRPInstanceChangedEvent) GetTraceId() string {
	if m != nil {
		return m.TraceId
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *ActualLRPInstanceChangedEvent) SetTraceId(value string) {
	if m != nil {
		m.TraceId = value
	}
}
func (x *ActualLRPInstanceChangedEvent) ToProto() *ProtoActualLRPInstanceChangedEvent {
	if x == nil {
		return nil
	}

	proto := &ProtoActualLRPInstanceChangedEvent{
		ActualLrpKey:         x.ActualLrpKey.ToProto(),
		ActualLrpInstanceKey: x.ActualLrpInstanceKey.ToProto(),
		Before:               x.Before.ToProto(),
		After:                x.After.ToProto(),
		TraceId:              x.TraceId,
	}
	return proto
}

func (x *ProtoActualLRPInstanceChangedEvent) FromProto() *ActualLRPInstanceChangedEvent {
	if x == nil {
		return nil
	}

	copysafe := &ActualLRPInstanceChangedEvent{
		ActualLrpKey:         *x.ActualLrpKey.FromProto(),
		ActualLrpInstanceKey: *x.ActualLrpInstanceKey.FromProto(),
		Before:               x.Before.FromProto(),
		After:                x.After.FromProto(),
		TraceId:              x.TraceId,
	}
	return copysafe
}

func ActualLRPInstanceChangedEventToProtoSlice(values []*ActualLRPInstanceChangedEvent) []*ProtoActualLRPInstanceChangedEvent {
	if values == nil {
		return nil
	}
	result := make([]*ProtoActualLRPInstanceChangedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func ActualLRPInstanceChangedEventFromProtoSlice(values []*ProtoActualLRPInstanceChangedEvent) []*ActualLRPInstanceChangedEvent {
	if values == nil {
		return nil
	}
	result := make([]*ActualLRPInstanceChangedEvent, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPInstanceRemovedEvent directly
type ActualLRPInstanceRemovedEvent struct {
	ActualLrp *ActualLRP `json:"actual_lrp,omitempty"`
	TraceId   string     `json:"trace_id"`
}

func (this *ActualLRPInstanceRemovedEvent) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPInstanceRemovedEvent)
	if !ok {
		that2, ok := that.(ActualLRPInstanceRemovedEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.ActualLrp == nil {
		if that1.ActualLrp != nil {
			return false
		}
	} else if !this.ActualLrp.Equal(*that1.ActualLrp) {
		return false
	}
	if this.TraceId != that1.TraceId {
		return false
	}
	return true
}
func (m *ActualLRPInstanceRemovedEvent) GetActualLrp() *ActualLRP {
	if m != nil {
		return m.ActualLrp
	}
	return nil
}
func (m *ActualLRPInstanceRemovedEvent) SetActualLrp(value *ActualLRP) {
	if m != nil {
		m.ActualLrp = value
	}
}
func (m *ActualLRPInstanceRemovedEvent) GetTraceId() string {
	if m != nil {
		return m.TraceId
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *ActualLRPInstanceRemovedEvent) SetTraceId(value string) {
	if m != nil {
		m.TraceId = value
	}
}
func (x *ActualLRPInstanceRemovedEvent) ToProto() *ProtoActualLRPInstanceRemovedEvent {
	if x == nil {
		return nil
	}

	proto := &ProtoActualLRPInstanceRemovedEvent{
		ActualLrp: x.ActualLrp.ToProto(),
		TraceId:   x.TraceId,
	}
	return proto
}

func (x *ProtoActualLRPInstanceRemovedEvent) FromProto() *ActualLRPInstanceRemovedEvent {
	if x == nil {
		return nil
	}

	copysafe := &ActualLRPInstanceRemovedEvent{
		ActualLrp: x.ActualLrp.FromProto(),
		TraceId:   x.TraceId,
	}
	return copysafe
}

func ActualLRPInstanceRemovedEventToProtoSlice(values []*ActualLRPInstanceRemovedEvent) []*ProtoActualLRPInstanceRemovedEvent {
	if values == nil {
		return nil
	}
	result := make([]*ProtoActualLRPInstanceRemovedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func ActualLRPInstanceRemovedEventFromProtoSlice(values []*ProtoActualLRPInstanceRemovedEvent) []*ActualLRPInstanceRemovedEvent {
	if values == nil {
		return nil
	}
	result := make([]*ActualLRPInstanceRemovedEvent, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPCreatedEvent directly
type DesiredLRPCreatedEvent struct {
	DesiredLrp *DesiredLRP `json:"desired_lrp,omitempty"`
	TraceId    string      `json:"trace_id"`
}

func (this *DesiredLRPCreatedEvent) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRPCreatedEvent)
	if !ok {
		that2, ok := that.(DesiredLRPCreatedEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.DesiredLrp == nil {
		if that1.DesiredLrp != nil {
			return false
		}
	} else if !this.DesiredLrp.Equal(*that1.DesiredLrp) {
		return false
	}
	if this.TraceId != that1.TraceId {
		return false
	}
	return true
}
func (m *DesiredLRPCreatedEvent) GetDesiredLrp() *DesiredLRP {
	if m != nil {
		return m.DesiredLrp
	}
	return nil
}
func (m *DesiredLRPCreatedEvent) SetDesiredLrp(value *DesiredLRP) {
	if m != nil {
		m.DesiredLrp = value
	}
}
func (m *DesiredLRPCreatedEvent) GetTraceId() string {
	if m != nil {
		return m.TraceId
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *DesiredLRPCreatedEvent) SetTraceId(value string) {
	if m != nil {
		m.TraceId = value
	}
}
func (x *DesiredLRPCreatedEvent) ToProto() *ProtoDesiredLRPCreatedEvent {
	if x == nil {
		return nil
	}

	proto := &ProtoDesiredLRPCreatedEvent{
		DesiredLrp: x.DesiredLrp.ToProto(),
		TraceId:    x.TraceId,
	}
	return proto
}

func (x *ProtoDesiredLRPCreatedEvent) FromProto() *DesiredLRPCreatedEvent {
	if x == nil {
		return nil
	}

	copysafe := &DesiredLRPCreatedEvent{
		DesiredLrp: x.DesiredLrp.FromProto(),
		TraceId:    x.TraceId,
	}
	return copysafe
}

func DesiredLRPCreatedEventToProtoSlice(values []*DesiredLRPCreatedEvent) []*ProtoDesiredLRPCreatedEvent {
	if values == nil {
		return nil
	}
	result := make([]*ProtoDesiredLRPCreatedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func DesiredLRPCreatedEventFromProtoSlice(values []*ProtoDesiredLRPCreatedEvent) []*DesiredLRPCreatedEvent {
	if values == nil {
		return nil
	}
	result := make([]*DesiredLRPCreatedEvent, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPChangedEvent directly
type DesiredLRPChangedEvent struct {
	Before  *DesiredLRP `json:"before,omitempty"`
	After   *DesiredLRP `json:"after,omitempty"`
	TraceId string      `json:"trace_id"`
}

func (this *DesiredLRPChangedEvent) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRPChangedEvent)
	if !ok {
		that2, ok := that.(DesiredLRPChangedEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Before == nil {
		if that1.Before != nil {
			return false
		}
	} else if !this.Before.Equal(*that1.Before) {
		return false
	}
	if this.After == nil {
		if that1.After != nil {
			return false
		}
	} else if !this.After.Equal(*that1.After) {
		return false
	}
	if this.TraceId != that1.TraceId {
		return false
	}
	return true
}
func (m *DesiredLRPChangedEvent) GetBefore() *DesiredLRP {
	if m != nil {
		return m.Before
	}
	return nil
}
func (m *DesiredLRPChangedEvent) SetBefore(value *DesiredLRP) {
	if m != nil {
		m.Before = value
	}
}
func (m *DesiredLRPChangedEvent) GetAfter() *DesiredLRP {
	if m != nil {
		return m.After
	}
	return nil
}
func (m *DesiredLRPChangedEvent) SetAfter(value *DesiredLRP) {
	if m != nil {
		m.After = value
	}
}
func (m *DesiredLRPChangedEvent) GetTraceId() string {
	if m != nil {
		return m.TraceId
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *DesiredLRPChangedEvent) SetTraceId(value string) {
	if m != nil {
		m.TraceId = value
	}
}
func (x *DesiredLRPChangedEvent) ToProto() *ProtoDesiredLRPChangedEvent {
	if x == nil {
		return nil
	}

	proto := &ProtoDesiredLRPChangedEvent{
		Before:  x.Before.ToProto(),
		After:   x.After.ToProto(),
		TraceId: x.TraceId,
	}
	return proto
}

func (x *ProtoDesiredLRPChangedEvent) FromProto() *DesiredLRPChangedEvent {
	if x == nil {
		return nil
	}

	copysafe := &DesiredLRPChangedEvent{
		Before:  x.Before.FromProto(),
		After:   x.After.FromProto(),
		TraceId: x.TraceId,
	}
	return copysafe
}

func DesiredLRPChangedEventToProtoSlice(values []*DesiredLRPChangedEvent) []*ProtoDesiredLRPChangedEvent {
	if values == nil {
		return nil
	}
	result := make([]*ProtoDesiredLRPChangedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func DesiredLRPChangedEventFromProtoSlice(values []*ProtoDesiredLRPChangedEvent) []*DesiredLRPChangedEvent {
	if values == nil {
		return nil
	}
	result := make([]*DesiredLRPChangedEvent, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPRemovedEvent directly
type DesiredLRPRemovedEvent struct {
	DesiredLrp *DesiredLRP `json:"desired_lrp,omitempty"`
	TraceId    string      `json:"trace_id"`
}

func (this *DesiredLRPRemovedEvent) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRPRemovedEvent)
	if !ok {
		that2, ok := that.(DesiredLRPRemovedEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.DesiredLrp == nil {
		if that1.DesiredLrp != nil {
			return false
		}
	} else if !this.DesiredLrp.Equal(*that1.DesiredLrp) {
		return false
	}
	if this.TraceId != that1.TraceId {
		return false
	}
	return true
}
func (m *DesiredLRPRemovedEvent) GetDesiredLrp() *DesiredLRP {
	if m != nil {
		return m.DesiredLrp
	}
	return nil
}
func (m *DesiredLRPRemovedEvent) SetDesiredLrp(value *DesiredLRP) {
	if m != nil {
		m.DesiredLrp = value
	}
}
func (m *DesiredLRPRemovedEvent) GetTraceId() string {
	if m != nil {
		return m.TraceId
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *DesiredLRPRemovedEvent) SetTraceId(value string) {
	if m != nil {
		m.TraceId = value
	}
}
func (x *DesiredLRPRemovedEvent) ToProto() *ProtoDesiredLRPRemovedEvent {
	if x == nil {
		return nil
	}

	proto := &ProtoDesiredLRPRemovedEvent{
		DesiredLrp: x.DesiredLrp.ToProto(),
		TraceId:    x.TraceId,
	}
	return proto
}

func (x *ProtoDesiredLRPRemovedEvent) FromProto() *DesiredLRPRemovedEvent {
	if x == nil {
		return nil
	}

	copysafe := &DesiredLRPRemovedEvent{
		DesiredLrp: x.DesiredLrp.FromProto(),
		TraceId:    x.TraceId,
	}
	return copysafe
}

func DesiredLRPRemovedEventToProtoSlice(values []*DesiredLRPRemovedEvent) []*ProtoDesiredLRPRemovedEvent {
	if values == nil {
		return nil
	}
	result := make([]*ProtoDesiredLRPRemovedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func DesiredLRPRemovedEventFromProtoSlice(values []*ProtoDesiredLRPRemovedEvent) []*DesiredLRPRemovedEvent {
	if values == nil {
		return nil
	}
	result := make([]*DesiredLRPRemovedEvent, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPCrashedEvent directly
type ActualLRPCrashedEvent struct {
	ActualLrpKey         ActualLRPKey         `json:"actual_lrp_key"`
	ActualLrpInstanceKey ActualLRPInstanceKey `json:"actual_lrp_instance_key"`
	CrashCount           int32                `json:"crash_count"`
	CrashReason          string               `json:"crash_reason,omitempty"`
	Since                int64                `json:"since"`
}

func (this *ActualLRPCrashedEvent) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPCrashedEvent)
	if !ok {
		that2, ok := that.(ActualLRPCrashedEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.ActualLrpKey.Equal(that1.ActualLrpKey) {
		return false
	}
	if !this.ActualLrpInstanceKey.Equal(that1.ActualLrpInstanceKey) {
		return false
	}
	if this.CrashCount != that1.CrashCount {
		return false
	}
	if this.CrashReason != that1.CrashReason {
		return false
	}
	if this.Since != that1.Since {
		return false
	}
	return true
}
func (m *ActualLRPCrashedEvent) SetActualLrpKey(value ActualLRPKey) {
	if m != nil {
		m.ActualLrpKey = value
	}
}
func (m *ActualLRPCrashedEvent) SetActualLrpInstanceKey(value ActualLRPInstanceKey) {
	if m != nil {
		m.ActualLrpInstanceKey = value
	}
}
func (m *ActualLRPCrashedEvent) GetCrashCount() int32 {
	if m != nil {
		return m.CrashCount
	}
	var defaultValue int32
	defaultValue = 0
	return defaultValue
}
func (m *ActualLRPCrashedEvent) SetCrashCount(value int32) {
	if m != nil {
		m.CrashCount = value
	}
}
func (m *ActualLRPCrashedEvent) GetCrashReason() string {
	if m != nil {
		return m.CrashReason
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *ActualLRPCrashedEvent) SetCrashReason(value string) {
	if m != nil {
		m.CrashReason = value
	}
}
func (m *ActualLRPCrashedEvent) GetSince() int64 {
	if m != nil {
		return m.Since
	}
	var defaultValue int64
	defaultValue = 0
	return defaultValue
}
func (m *ActualLRPCrashedEvent) SetSince(value int64) {
	if m != nil {
		m.Since = value
	}
}
func (x *ActualLRPCrashedEvent) ToProto() *ProtoActualLRPCrashedEvent {
	if x == nil {
		return nil
	}

	proto := &ProtoActualLRPCrashedEvent{
		ActualLrpKey:         x.ActualLrpKey.ToProto(),
		ActualLrpInstanceKey: x.ActualLrpInstanceKey.ToProto(),
		CrashCount:           x.CrashCount,
		CrashReason:          x.CrashReason,
		Since:                x.Since,
	}
	return proto
}

func (x *ProtoActualLRPCrashedEvent) FromProto() *ActualLRPCrashedEvent {
	if x == nil {
		return nil
	}

	copysafe := &ActualLRPCrashedEvent{
		ActualLrpKey:         *x.ActualLrpKey.FromProto(),
		ActualLrpInstanceKey: *x.ActualLrpInstanceKey.FromProto(),
		CrashCount:           x.CrashCount,
		CrashReason:          x.CrashReason,
		Since:                x.Since,
	}
	return copysafe
}

func ActualLRPCrashedEventToProtoSlice(values []*ActualLRPCrashedEvent) []*ProtoActualLRPCrashedEvent {
	if values == nil {
		return nil
	}
	result := make([]*ProtoActualLRPCrashedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func ActualLRPCrashedEventFromProtoSlice(values []*ProtoActualLRPCrashedEvent) []*ActualLRPCrashedEvent {
	if values == nil {
		return nil
	}
	result := make([]*ActualLRPCrashedEvent, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoEventsByCellId directly
type EventsByCellId struct {
	CellId string `json:"cell_id"`
}

func (this *EventsByCellId) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventsByCellId)
	if !ok {
		that2, ok := that.(EventsByCellId)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.CellId != that1.CellId {
		return false
	}
	return true
}
func (m *EventsByCellId) GetCellId() string {
	if m != nil {
		return m.CellId
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *EventsByCellId) SetCellId(value string) {
	if m != nil {
		m.CellId = value
	}
}
func (x *EventsByCellId) ToProto() *ProtoEventsByCellId {
	if x == nil {
		return nil
	}

	proto := &ProtoEventsByCellId{
		CellId: x.CellId,
	}
	return proto
}

func (x *ProtoEventsByCellId) FromProto() *EventsByCellId {
	if x == nil {
		return nil
	}

	copysafe := &EventsByCellId{
		CellId: x.CellId,
	}
	return copysafe
}

func EventsByCellIdToProtoSlice(values []*EventsByCellId) []*ProtoEventsByCellId {
	if values == nil {
		return nil
	}
	result := make([]*ProtoEventsByCellId, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func EventsByCellIdFromProtoSlice(values []*ProtoEventsByCellId) []*EventsByCellId {
	if values == nil {
		return nil
	}
	result := make([]*EventsByCellId, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoTaskCreatedEvent directly
type TaskCreatedEvent struct {
	Task *Task `json:"task,omitempty"`
}

func (this *TaskCreatedEvent) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TaskCreatedEvent)
	if !ok {
		that2, ok := that.(TaskCreatedEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Task == nil {
		if that1.Task != nil {
			return false
		}
	} else if !this.Task.Equal(*that1.Task) {
		return false
	}
	return true
}
func (m *TaskCreatedEvent) GetTask() *Task {
	if m != nil {
		return m.Task
	}
	return nil
}
func (m *TaskCreatedEvent) SetTask(value *Task) {
	if m != nil {
		m.Task = value
	}
}
func (x *TaskCreatedEvent) ToProto() *ProtoTaskCreatedEvent {
	if x == nil {
		return nil
	}

	proto := &ProtoTaskCreatedEvent{
		Task: x.Task.ToProto(),
	}
	return proto
}

func (x *ProtoTaskCreatedEvent) FromProto() *TaskCreatedEvent {
	if x == nil {
		return nil
	}

	copysafe := &TaskCreatedEvent{
		Task: x.Task.FromProto(),
	}
	return copysafe
}

func TaskCreatedEventToProtoSlice(values []*TaskCreatedEvent) []*ProtoTaskCreatedEvent {
	if values == nil {
		return nil
	}
	result := make([]*ProtoTaskCreatedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func TaskCreatedEventFromProtoSlice(values []*ProtoTaskCreatedEvent) []*TaskCreatedEvent {
	if values == nil {
		return nil
	}
	result := make([]*TaskCreatedEvent, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoTaskChangedEvent directly
type TaskChangedEvent struct {
	Before *Task `json:"before,omitempty"`
	After  *Task `json:"after,omitempty"`
}

func (this *TaskChangedEvent) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TaskChangedEvent)
	if !ok {
		that2, ok := that.(TaskChangedEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Before == nil {
		if that1.Before != nil {
			return false
		}
	} else if !this.Before.Equal(*that1.Before) {
		return false
	}
	if this.After == nil {
		if that1.After != nil {
			return false
		}
	} else if !this.After.Equal(*that1.After) {
		return false
	}
	return true
}
func (m *TaskChangedEvent) GetBefore() *Task {
	if m != nil {
		return m.Before
	}
	return nil
}
func (m *TaskChangedEvent) SetBefore(value *Task) {
	if m != nil {
		m.Before = value
	}
}
func (m *TaskChangedEvent) GetAfter() *Task {
	if m != nil {
		return m.After
	}
	return nil
}
func (m *TaskChangedEvent) SetAfter(value *Task) {
	if m != nil {
		m.After = value
	}
}
func (x *TaskChangedEvent) ToProto() *ProtoTaskChangedEvent {
	if x == nil {
		return nil
	}

	proto := &ProtoTaskChangedEvent{
		Before: x.Before.ToProto(),
		After:  x.After.ToProto(),
	}
	return proto
}

func (x *ProtoTaskChangedEvent) FromProto() *TaskChangedEvent {
	if x == nil {
		return nil
	}

	copysafe := &TaskChangedEvent{
		Before: x.Before.FromProto(),
		After:  x.After.FromProto(),
	}
	return copysafe
}

func TaskChangedEventToProtoSlice(values []*TaskChangedEvent) []*ProtoTaskChangedEvent {
	if values == nil {
		return nil
	}
	result := make([]*ProtoTaskChangedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func TaskChangedEventFromProtoSlice(values []*ProtoTaskChangedEvent) []*TaskChangedEvent {
	if values == nil {
		return nil
	}
	result := make([]*TaskChangedEvent, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoTaskRemovedEvent directly
type TaskRemovedEvent struct {
	Task *Task `json:"task,omitempty"`
}

func (this *TaskRemovedEvent) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TaskRemovedEvent)
	if !ok {
		that2, ok := that.(TaskRemovedEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Task == nil {
		if that1.Task != nil {
			return false
		}
	} else if !this.Task.Equal(*that1.Task) {
		return false
	}
	return true
}
func (m *TaskRemovedEvent) GetTask() *Task {
	if m != nil {
		return m.Task
	}
	return nil
}
func (m *TaskRemovedEvent) SetTask(value *Task) {
	if m != nil {
		m.Task = value
	}
}
func (x *TaskRemovedEvent) ToProto() *ProtoTaskRemovedEvent {
	if x == nil {
		return nil
	}

	proto := &ProtoTaskRemovedEvent{
		Task: x.Task.ToProto(),
	}
	return proto
}

func (x *ProtoTaskRemovedEvent) FromProto() *TaskRemovedEvent {
	if x == nil {
		return nil
	}

	copysafe := &TaskRemovedEvent{
		Task: x.Task.FromProto(),
	}
	return copysafe
}

func TaskRemovedEventToProtoSlice(values []*TaskRemovedEvent) []*ProtoTaskRemovedEvent {
	if values == nil {
		return nil
	}
	result := make([]*ProtoTaskRemovedEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func TaskRemovedEventFromProtoSlice(values []*ProtoTaskRemovedEvent) []*TaskRemovedEvent {
	if values == nil {
		return nil
	}
	result := make([]*TaskRemovedEvent, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoFakeEvent directly
type FakeEvent struct {
	Token string `json:"token,omitempty"`
}

func (this *FakeEvent) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FakeEvent)
	if !ok {
		that2, ok := that.(FakeEvent)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Token != that1.Token {
		return false
	}
	return true
}
func (m *FakeEvent) GetToken() string {
	if m != nil {
		return m.Token
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *FakeEvent) SetToken(value string) {
	if m != nil {
		m.Token = value
	}
}
func (x *FakeEvent) ToProto() *ProtoFakeEvent {
	if x == nil {
		return nil
	}

	proto := &ProtoFakeEvent{
		Token: x.Token,
	}
	return proto
}

func (x *ProtoFakeEvent) FromProto() *FakeEvent {
	if x == nil {
		return nil
	}

	copysafe := &FakeEvent{
		Token: x.Token,
	}
	return copysafe
}

func FakeEventToProtoSlice(values []*FakeEvent) []*ProtoFakeEvent {
	if values == nil {
		return nil
	}
	result := make([]*ProtoFakeEvent, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func FakeEventFromProtoSlice(values []*ProtoFakeEvent) []*FakeEvent {
	if values == nil {
		return nil
	}
	result := make([]*FakeEvent, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}
