// Code generated by protoc-gen-go-bbs. DO NOT EDIT.
// versions:
// - protoc-gen-go-bbs v0.0.1
// - protoc            v5.27.0--rc1
// source: actual_lrp_requests.proto

package models

// Prevent copylock errors when using ProtoActualLRPLifecycleResponse directly
type ActualLRPLifecycleResponse struct {
	Error *Error
}

func (this *ActualLRPLifecycleResponse) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPLifecycleResponse)
	if !ok {
		that2, ok := that.(ActualLRPLifecycleResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (m *ActualLRPLifecycleResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *ActualLRPLifecycleResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (x *ActualLRPLifecycleResponse) ToProto() *ProtoActualLRPLifecycleResponse {
	proto := &ProtoActualLRPLifecycleResponse{
		Error: x.Error.ToProto(),
	}
	return proto
}

func ActualLRPLifecycleResponseProtoMap(values []*ActualLRPLifecycleResponse) []*ProtoActualLRPLifecycleResponse {
	result := make([]*ProtoActualLRPLifecycleResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPGroupsResponse directly
type ActualLRPGroupsResponse struct {
	Error           *Error
	ActualLRPGroups []*ActualLRPGroup
}

func (this *ActualLRPGroupsResponse) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPGroupsResponse)
	if !ok {
		that2, ok := that.(ActualLRPGroupsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.Error.Equal(that1.Error) {
		return false
	}
	if len(this.ActualLRPGroups) != len(that1.ActualLRPGroups) {
		return false
	}
	for i := range this.ActualLRPGroups {
		if !this.ActualLRPGroups[i].Equal(that1.ActualLRPGroups[i]) {
			return false
		}
	}
	return true
}
func (m *ActualLRPGroupsResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *ActualLRPGroupsResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (m *ActualLRPGroupsResponse) GetActualLRPGroups() []*ActualLRPGroup {
	if m != nil {
		return m.ActualLRPGroups
	}
	return nil
}
func (m *ActualLRPGroupsResponse) SetActualLRPGroups(value []*ActualLRPGroup) {
	if m != nil {
		m.ActualLRPGroups = value
	}
}
func (x *ActualLRPGroupsResponse) ToProto() *ProtoActualLRPGroupsResponse {
	proto := &ProtoActualLRPGroupsResponse{
		Error:           x.Error.ToProto(),
		ActualLrpGroups: ActualLRPGroupProtoMap(x.ActualLRPGroups),
	}
	return proto
}

func ActualLRPGroupsResponseProtoMap(values []*ActualLRPGroupsResponse) []*ProtoActualLRPGroupsResponse {
	result := make([]*ProtoActualLRPGroupsResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPGroupResponse directly
type ActualLRPGroupResponse struct {
	Error          *Error
	ActualLRPGroup *ActualLRPGroup
}

func (this *ActualLRPGroupResponse) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPGroupResponse)
	if !ok {
		that2, ok := that.(ActualLRPGroupResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.Error.Equal(that1.Error) {
		return false
	}
	if !this.ActualLRPGroup.Equal(that1.ActualLRPGroup) {
		return false
	}
	return true
}
func (m *ActualLRPGroupResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *ActualLRPGroupResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (m *ActualLRPGroupResponse) GetActualLRPGroup() *ActualLRPGroup {
	if m != nil {
		return m.ActualLRPGroup
	}
	return nil
}
func (m *ActualLRPGroupResponse) SetActualLRPGroup(value *ActualLRPGroup) {
	if m != nil {
		m.ActualLRPGroup = value
	}
}
func (x *ActualLRPGroupResponse) ToProto() *ProtoActualLRPGroupResponse {
	proto := &ProtoActualLRPGroupResponse{
		Error:          x.Error.ToProto(),
		ActualLrpGroup: x.ActualLRPGroup.ToProto(),
	}
	return proto
}

func ActualLRPGroupResponseProtoMap(values []*ActualLRPGroupResponse) []*ProtoActualLRPGroupResponse {
	result := make([]*ProtoActualLRPGroupResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPGroupsRequest directly
type ActualLRPGroupsRequest struct {
	Domain string
	CellId string
}

func (this *ActualLRPGroupsRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPGroupsRequest)
	if !ok {
		that2, ok := that.(ActualLRPGroupsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Domain != that1.Domain {
		return false
	}
	if this.CellId != that1.CellId {
		return false
	}
	return true
}
func (m *ActualLRPGroupsRequest) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}
func (m *ActualLRPGroupsRequest) SetDomain(value string) {
	if m != nil {
		m.Domain = value
	}
}
func (m *ActualLRPGroupsRequest) GetCellId() string {
	if m != nil {
		return m.CellId
	}
	return ""
}
func (m *ActualLRPGroupsRequest) SetCellId(value string) {
	if m != nil {
		m.CellId = value
	}
}
func (x *ActualLRPGroupsRequest) ToProto() *ProtoActualLRPGroupsRequest {
	proto := &ProtoActualLRPGroupsRequest{
		Domain: x.Domain,
		CellId: x.CellId,
	}
	return proto
}

func ActualLRPGroupsRequestProtoMap(values []*ActualLRPGroupsRequest) []*ProtoActualLRPGroupsRequest {
	result := make([]*ProtoActualLRPGroupsRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPGroupsByProcessGuidRequest directly
type ActualLRPGroupsByProcessGuidRequest struct {
	ProcessGuid string
}

func (this *ActualLRPGroupsByProcessGuidRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPGroupsByProcessGuidRequest)
	if !ok {
		that2, ok := that.(ActualLRPGroupsByProcessGuidRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.ProcessGuid != that1.ProcessGuid {
		return false
	}
	return true
}
func (m *ActualLRPGroupsByProcessGuidRequest) GetProcessGuid() string {
	if m != nil {
		return m.ProcessGuid
	}
	return ""
}
func (m *ActualLRPGroupsByProcessGuidRequest) SetProcessGuid(value string) {
	if m != nil {
		m.ProcessGuid = value
	}
}
func (x *ActualLRPGroupsByProcessGuidRequest) ToProto() *ProtoActualLRPGroupsByProcessGuidRequest {
	proto := &ProtoActualLRPGroupsByProcessGuidRequest{
		ProcessGuid: x.ProcessGuid,
	}
	return proto
}

func ActualLRPGroupsByProcessGuidRequestProtoMap(values []*ActualLRPGroupsByProcessGuidRequest) []*ProtoActualLRPGroupsByProcessGuidRequest {
	result := make([]*ProtoActualLRPGroupsByProcessGuidRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPGroupByProcessGuidAndIndexRequest directly
type ActualLRPGroupByProcessGuidAndIndexRequest struct {
	ProcessGuid string
	Index       int32
}

func (this *ActualLRPGroupByProcessGuidAndIndexRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPGroupByProcessGuidAndIndexRequest)
	if !ok {
		that2, ok := that.(ActualLRPGroupByProcessGuidAndIndexRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.ProcessGuid != that1.ProcessGuid {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	return true
}
func (m *ActualLRPGroupByProcessGuidAndIndexRequest) GetProcessGuid() string {
	if m != nil {
		return m.ProcessGuid
	}
	return ""
}
func (m *ActualLRPGroupByProcessGuidAndIndexRequest) SetProcessGuid(value string) {
	if m != nil {
		m.ProcessGuid = value
	}
}
func (m *ActualLRPGroupByProcessGuidAndIndexRequest) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}
func (m *ActualLRPGroupByProcessGuidAndIndexRequest) SetIndex(value int32) {
	if m != nil {
		m.Index = value
	}
}
func (x *ActualLRPGroupByProcessGuidAndIndexRequest) ToProto() *ProtoActualLRPGroupByProcessGuidAndIndexRequest {
	proto := &ProtoActualLRPGroupByProcessGuidAndIndexRequest{
		ProcessGuid: x.ProcessGuid,
		Index:       x.Index,
	}
	return proto
}

func ActualLRPGroupByProcessGuidAndIndexRequestProtoMap(values []*ActualLRPGroupByProcessGuidAndIndexRequest) []*ProtoActualLRPGroupByProcessGuidAndIndexRequest {
	result := make([]*ProtoActualLRPGroupByProcessGuidAndIndexRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoClaimActualLRPRequest directly
type ClaimActualLRPRequest struct {
	ProcessGuid          string
	Index                int32
	ActualLRPInstanceKey *ActualLRPInstanceKey
}

func (this *ClaimActualLRPRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClaimActualLRPRequest)
	if !ok {
		that2, ok := that.(ClaimActualLRPRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.ProcessGuid != that1.ProcessGuid {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	if !this.ActualLRPInstanceKey.Equal(that1.ActualLRPInstanceKey) {
		return false
	}
	return true
}
func (m *ClaimActualLRPRequest) GetProcessGuid() string {
	if m != nil {
		return m.ProcessGuid
	}
	return ""
}
func (m *ClaimActualLRPRequest) SetProcessGuid(value string) {
	if m != nil {
		m.ProcessGuid = value
	}
}
func (m *ClaimActualLRPRequest) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}
func (m *ClaimActualLRPRequest) SetIndex(value int32) {
	if m != nil {
		m.Index = value
	}
}
func (m *ClaimActualLRPRequest) GetActualLRPInstanceKey() *ActualLRPInstanceKey {
	if m != nil {
		return m.ActualLRPInstanceKey
	}
	return nil
}
func (m *ClaimActualLRPRequest) SetActualLRPInstanceKey(value *ActualLRPInstanceKey) {
	if m != nil {
		m.ActualLRPInstanceKey = value
	}
}
func (x *ClaimActualLRPRequest) ToProto() *ProtoClaimActualLRPRequest {
	proto := &ProtoClaimActualLRPRequest{
		ProcessGuid:          x.ProcessGuid,
		Index:                x.Index,
		ActualLrpInstanceKey: x.ActualLRPInstanceKey.ToProto(),
	}
	return proto
}

func ClaimActualLRPRequestProtoMap(values []*ClaimActualLRPRequest) []*ProtoClaimActualLRPRequest {
	result := make([]*ProtoClaimActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoStartActualLRPRequest directly
type StartActualLRPRequest struct {
	ActualLRPKey            *ActualLRPKey
	ActualLRPInstanceKey    *ActualLRPInstanceKey
	ActualLRPNetInfo        *ActualLRPNetInfo
	ActualLRPInternalRoutes []*ActualLRPInternalRoute
	MetricTags              map[string]string
	Routable                *bool
	AvailabilityZone        string
}

func (this *StartActualLRPRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StartActualLRPRequest)
	if !ok {
		that2, ok := that.(StartActualLRPRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.ActualLRPKey.Equal(that1.ActualLRPKey) {
		return false
	}
	if !this.ActualLRPInstanceKey.Equal(that1.ActualLRPInstanceKey) {
		return false
	}
	if !this.ActualLRPNetInfo.Equal(that1.ActualLRPNetInfo) {
		return false
	}
	if len(this.ActualLRPInternalRoutes) != len(that1.ActualLRPInternalRoutes) {
		return false
	}
	for i := range this.ActualLRPInternalRoutes {
		if !this.ActualLRPInternalRoutes[i].Equal(that1.ActualLRPInternalRoutes[i]) {
			return false
		}
	}
	if len(this.MetricTags) != len(that1.MetricTags) {
		return false
	}
	for i := range this.MetricTags {
		if this.MetricTags[i] != that1.MetricTags[i] {
			return false
		}
	}
	if this.Routable != that1.Routable {
		return false
	}
	if this.AvailabilityZone != that1.AvailabilityZone {
		return false
	}
	return true
}
func (m *StartActualLRPRequest) GetActualLRPKey() *ActualLRPKey {
	if m != nil {
		return m.ActualLRPKey
	}
	return nil
}
func (m *StartActualLRPRequest) SetActualLRPKey(value *ActualLRPKey) {
	if m != nil {
		m.ActualLRPKey = value
	}
}
func (m *StartActualLRPRequest) GetActualLRPInstanceKey() *ActualLRPInstanceKey {
	if m != nil {
		return m.ActualLRPInstanceKey
	}
	return nil
}
func (m *StartActualLRPRequest) SetActualLRPInstanceKey(value *ActualLRPInstanceKey) {
	if m != nil {
		m.ActualLRPInstanceKey = value
	}
}
func (m *StartActualLRPRequest) GetActualLRPNetInfo() *ActualLRPNetInfo {
	if m != nil {
		return m.ActualLRPNetInfo
	}
	return nil
}
func (m *StartActualLRPRequest) SetActualLRPNetInfo(value *ActualLRPNetInfo) {
	if m != nil {
		m.ActualLRPNetInfo = value
	}
}
func (m *StartActualLRPRequest) GetActualLRPInternalRoutes() []*ActualLRPInternalRoute {
	if m != nil {
		return m.ActualLRPInternalRoutes
	}
	return nil
}
func (m *StartActualLRPRequest) SetActualLRPInternalRoutes(value []*ActualLRPInternalRoute) {
	if m != nil {
		m.ActualLRPInternalRoutes = value
	}
}
func (m *StartActualLRPRequest) GetMetricTags() map[string]string {
	if m != nil {
		return m.MetricTags
	}
	return nil
}
func (m *StartActualLRPRequest) SetMetricTags(value map[string]string) {
	if m != nil {
		m.MetricTags = value
	}
}
func (m *StartActualLRPRequest) RoutableExists() bool {
	return m != nil && m.Routable != nil
}
func (m *StartActualLRPRequest) GetRoutable() *bool {
	if m != nil && m.Routable != nil {
		return m.Routable
	}
	return nil
}
func (m *StartActualLRPRequest) SetRoutable(value *bool) {
	if m != nil {
		m.Routable = value
	}
}
func (m *StartActualLRPRequest) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}
func (m *StartActualLRPRequest) SetAvailabilityZone(value string) {
	if m != nil {
		m.AvailabilityZone = value
	}
}
func (x *StartActualLRPRequest) ToProto() *ProtoStartActualLRPRequest {
	proto := &ProtoStartActualLRPRequest{
		ActualLrpKey:            x.ActualLRPKey.ToProto(),
		ActualLrpInstanceKey:    x.ActualLRPInstanceKey.ToProto(),
		ActualLrpNetInfo:        x.ActualLRPNetInfo.ToProto(),
		ActualLrpInternalRoutes: ActualLRPInternalRouteProtoMap(x.ActualLRPInternalRoutes),
		MetricTags:              x.MetricTags,
		Routable:                &x.Routable,
		AvailabilityZone:        x.AvailabilityZone,
	}
	return proto
}

func StartActualLRPRequestProtoMap(values []*StartActualLRPRequest) []*ProtoStartActualLRPRequest {
	result := make([]*ProtoStartActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoCrashActualLRPRequest directly
type CrashActualLRPRequest struct {
	ActualLRPKey         *ActualLRPKey
	ActualLRPInstanceKey *ActualLRPInstanceKey
	ErrorMessage         string
}

func (this *CrashActualLRPRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CrashActualLRPRequest)
	if !ok {
		that2, ok := that.(CrashActualLRPRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.ActualLRPKey.Equal(that1.ActualLRPKey) {
		return false
	}
	if !this.ActualLRPInstanceKey.Equal(that1.ActualLRPInstanceKey) {
		return false
	}
	if this.ErrorMessage != that1.ErrorMessage {
		return false
	}
	return true
}
func (m *CrashActualLRPRequest) GetActualLRPKey() *ActualLRPKey {
	if m != nil {
		return m.ActualLRPKey
	}
	return nil
}
func (m *CrashActualLRPRequest) SetActualLRPKey(value *ActualLRPKey) {
	if m != nil {
		m.ActualLRPKey = value
	}
}
func (m *CrashActualLRPRequest) GetActualLRPInstanceKey() *ActualLRPInstanceKey {
	if m != nil {
		return m.ActualLRPInstanceKey
	}
	return nil
}
func (m *CrashActualLRPRequest) SetActualLRPInstanceKey(value *ActualLRPInstanceKey) {
	if m != nil {
		m.ActualLRPInstanceKey = value
	}
}
func (m *CrashActualLRPRequest) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}
func (m *CrashActualLRPRequest) SetErrorMessage(value string) {
	if m != nil {
		m.ErrorMessage = value
	}
}
func (x *CrashActualLRPRequest) ToProto() *ProtoCrashActualLRPRequest {
	proto := &ProtoCrashActualLRPRequest{
		ActualLrpKey:         x.ActualLRPKey.ToProto(),
		ActualLrpInstanceKey: x.ActualLRPInstanceKey.ToProto(),
		ErrorMessage:         x.ErrorMessage,
	}
	return proto
}

func CrashActualLRPRequestProtoMap(values []*CrashActualLRPRequest) []*ProtoCrashActualLRPRequest {
	result := make([]*ProtoCrashActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoFailActualLRPRequest directly
type FailActualLRPRequest struct {
	ActualLRPKey *ActualLRPKey
	ErrorMessage string
}

func (this *FailActualLRPRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FailActualLRPRequest)
	if !ok {
		that2, ok := that.(FailActualLRPRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.ActualLRPKey.Equal(that1.ActualLRPKey) {
		return false
	}
	if this.ErrorMessage != that1.ErrorMessage {
		return false
	}
	return true
}
func (m *FailActualLRPRequest) GetActualLRPKey() *ActualLRPKey {
	if m != nil {
		return m.ActualLRPKey
	}
	return nil
}
func (m *FailActualLRPRequest) SetActualLRPKey(value *ActualLRPKey) {
	if m != nil {
		m.ActualLRPKey = value
	}
}
func (m *FailActualLRPRequest) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}
func (m *FailActualLRPRequest) SetErrorMessage(value string) {
	if m != nil {
		m.ErrorMessage = value
	}
}
func (x *FailActualLRPRequest) ToProto() *ProtoFailActualLRPRequest {
	proto := &ProtoFailActualLRPRequest{
		ActualLrpKey: x.ActualLRPKey.ToProto(),
		ErrorMessage: x.ErrorMessage,
	}
	return proto
}

func FailActualLRPRequestProtoMap(values []*FailActualLRPRequest) []*ProtoFailActualLRPRequest {
	result := make([]*ProtoFailActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoRetireActualLRPRequest directly
type RetireActualLRPRequest struct {
	ActualLRPKey *ActualLRPKey
}

func (this *RetireActualLRPRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RetireActualLRPRequest)
	if !ok {
		that2, ok := that.(RetireActualLRPRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.ActualLRPKey.Equal(that1.ActualLRPKey) {
		return false
	}
	return true
}
func (m *RetireActualLRPRequest) GetActualLRPKey() *ActualLRPKey {
	if m != nil {
		return m.ActualLRPKey
	}
	return nil
}
func (m *RetireActualLRPRequest) SetActualLRPKey(value *ActualLRPKey) {
	if m != nil {
		m.ActualLRPKey = value
	}
}
func (x *RetireActualLRPRequest) ToProto() *ProtoRetireActualLRPRequest {
	proto := &ProtoRetireActualLRPRequest{
		ActualLrpKey: x.ActualLRPKey.ToProto(),
	}
	return proto
}

func RetireActualLRPRequestProtoMap(values []*RetireActualLRPRequest) []*ProtoRetireActualLRPRequest {
	result := make([]*ProtoRetireActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoRemoveActualLRPRequest directly
type RemoveActualLRPRequest struct {
	ProcessGuid          string
	Index                int32
	ActualLRPInstanceKey *ActualLRPInstanceKey
}

func (this *RemoveActualLRPRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoveActualLRPRequest)
	if !ok {
		that2, ok := that.(RemoveActualLRPRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.ProcessGuid != that1.ProcessGuid {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	if !this.ActualLRPInstanceKey.Equal(that1.ActualLRPInstanceKey) {
		return false
	}
	return true
}
func (m *RemoveActualLRPRequest) GetProcessGuid() string {
	if m != nil {
		return m.ProcessGuid
	}
	return ""
}
func (m *RemoveActualLRPRequest) SetProcessGuid(value string) {
	if m != nil {
		m.ProcessGuid = value
	}
}
func (m *RemoveActualLRPRequest) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}
func (m *RemoveActualLRPRequest) SetIndex(value int32) {
	if m != nil {
		m.Index = value
	}
}
func (m *RemoveActualLRPRequest) GetActualLRPInstanceKey() *ActualLRPInstanceKey {
	if m != nil {
		return m.ActualLRPInstanceKey
	}
	return nil
}
func (m *RemoveActualLRPRequest) SetActualLRPInstanceKey(value *ActualLRPInstanceKey) {
	if m != nil {
		m.ActualLRPInstanceKey = value
	}
}
func (x *RemoveActualLRPRequest) ToProto() *ProtoRemoveActualLRPRequest {
	proto := &ProtoRemoveActualLRPRequest{
		ProcessGuid:          x.ProcessGuid,
		Index:                x.Index,
		ActualLrpInstanceKey: x.ActualLRPInstanceKey.ToProto(),
	}
	return proto
}

func RemoveActualLRPRequestProtoMap(values []*RemoveActualLRPRequest) []*ProtoRemoveActualLRPRequest {
	result := make([]*ProtoRemoveActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPsResponse directly
type ActualLRPsResponse struct {
	Error      *Error
	ActualLRPs []*ActualLRP
}

func (this *ActualLRPsResponse) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPsResponse)
	if !ok {
		that2, ok := that.(ActualLRPsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.Error.Equal(that1.Error) {
		return false
	}
	if len(this.ActualLRPs) != len(that1.ActualLRPs) {
		return false
	}
	for i := range this.ActualLRPs {
		if !this.ActualLRPs[i].Equal(that1.ActualLRPs[i]) {
			return false
		}
	}
	return true
}
func (m *ActualLRPsResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *ActualLRPsResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (m *ActualLRPsResponse) GetActualLRPs() []*ActualLRP {
	if m != nil {
		return m.ActualLRPs
	}
	return nil
}
func (m *ActualLRPsResponse) SetActualLRPs(value []*ActualLRP) {
	if m != nil {
		m.ActualLRPs = value
	}
}
func (x *ActualLRPsResponse) ToProto() *ProtoActualLRPsResponse {
	proto := &ProtoActualLRPsResponse{
		Error:      x.Error.ToProto(),
		ActualLrps: ActualLRPProtoMap(x.ActualLRPs),
	}
	return proto
}

func ActualLRPsResponseProtoMap(values []*ActualLRPsResponse) []*ProtoActualLRPsResponse {
	result := make([]*ProtoActualLRPsResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPsRequest directly
type ActualLRPsRequest struct {
	Domain      string
	CellId      string
	ProcessGuid string
	Index       *int32
}

func (this *ActualLRPsRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPsRequest)
	if !ok {
		that2, ok := that.(ActualLRPsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Domain != that1.Domain {
		return false
	}
	if this.CellId != that1.CellId {
		return false
	}
	if this.ProcessGuid != that1.ProcessGuid {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	return true
}
func (m *ActualLRPsRequest) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}
func (m *ActualLRPsRequest) SetDomain(value string) {
	if m != nil {
		m.Domain = value
	}
}
func (m *ActualLRPsRequest) GetCellId() string {
	if m != nil {
		return m.CellId
	}
	return ""
}
func (m *ActualLRPsRequest) SetCellId(value string) {
	if m != nil {
		m.CellId = value
	}
}
func (m *ActualLRPsRequest) GetProcessGuid() string {
	if m != nil {
		return m.ProcessGuid
	}
	return ""
}
func (m *ActualLRPsRequest) SetProcessGuid(value string) {
	if m != nil {
		m.ProcessGuid = value
	}
}
func (m *ActualLRPsRequest) IndexExists() bool {
	return m != nil && m.Index != nil
}
func (m *ActualLRPsRequest) GetIndex() *int32 {
	if m != nil && m.Index != nil {
		return m.Index
	}
	return nil
}
func (m *ActualLRPsRequest) SetIndex(value *int32) {
	if m != nil {
		m.Index = value
	}
}
func (x *ActualLRPsRequest) ToProto() *ProtoActualLRPsRequest {
	proto := &ProtoActualLRPsRequest{
		Domain:      x.Domain,
		CellId:      x.CellId,
		ProcessGuid: x.ProcessGuid,
		Index:       &x.Index,
	}
	return proto
}

func ActualLRPsRequestProtoMap(values []*ActualLRPsRequest) []*ProtoActualLRPsRequest {
	result := make([]*ProtoActualLRPsRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}
