// Code generated by protoc-gen-go-bbs. DO NOT EDIT.
// versions:
// - protoc-gen-go-bbs v0.0.1
// - protoc            v5.27.0--rc1
// source: actual_lrp_requests.proto

package models

// Prevent copylock errors when using ProtoActualLRPLifecycleResponse directly
type ActualLRPLifecycleResponse struct {
	Error *Error
}

func (x *ActualLRPLifecycleResponse) ToProto() *ProtoActualLRPLifecycleResponse {
	proto := &ProtoActualLRPLifecycleResponse{
		Error: x.Error.ToProto(),
	}
	return proto
}

func ActualLRPLifecycleResponseProtoMap(values []*ActualLRPLifecycleResponse) []*ProtoActualLRPLifecycleResponse {
	result := make([]*ProtoActualLRPLifecycleResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPGroupsResponse directly
type ActualLRPGroupsResponse struct {
	Error           *Error
	ActualLrpGroups []*ActualLRPGroup
}

func (x *ActualLRPGroupsResponse) ToProto() *ProtoActualLRPGroupsResponse {
	proto := &ProtoActualLRPGroupsResponse{
		Error:           x.Error.ToProto(),
		ActualLrpGroups: ActualLRPGroupProtoMap(x.ActualLrpGroups),
	}
	return proto
}

func ActualLRPGroupsResponseProtoMap(values []*ActualLRPGroupsResponse) []*ProtoActualLRPGroupsResponse {
	result := make([]*ProtoActualLRPGroupsResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPGroupResponse directly
type ActualLRPGroupResponse struct {
	Error          *Error
	ActualLrpGroup *ActualLRPGroup
}

func (x *ActualLRPGroupResponse) ToProto() *ProtoActualLRPGroupResponse {
	proto := &ProtoActualLRPGroupResponse{
		Error:          x.Error.ToProto(),
		ActualLrpGroup: x.ActualLrpGroup.ToProto(),
	}
	return proto
}

func ActualLRPGroupResponseProtoMap(values []*ActualLRPGroupResponse) []*ProtoActualLRPGroupResponse {
	result := make([]*ProtoActualLRPGroupResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPGroupsRequest directly
type ActualLRPGroupsRequest struct {
	Domain string
	CellId string
}

func (x *ActualLRPGroupsRequest) ToProto() *ProtoActualLRPGroupsRequest {
	proto := &ProtoActualLRPGroupsRequest{
		Domain: x.Domain,
		CellId: x.CellId,
	}
	return proto
}

func ActualLRPGroupsRequestProtoMap(values []*ActualLRPGroupsRequest) []*ProtoActualLRPGroupsRequest {
	result := make([]*ProtoActualLRPGroupsRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPGroupsByProcessGuidRequest directly
type ActualLRPGroupsByProcessGuidRequest struct {
	ProcessGuid string
}

func (x *ActualLRPGroupsByProcessGuidRequest) ToProto() *ProtoActualLRPGroupsByProcessGuidRequest {
	proto := &ProtoActualLRPGroupsByProcessGuidRequest{
		ProcessGuid: x.ProcessGuid,
	}
	return proto
}

func ActualLRPGroupsByProcessGuidRequestProtoMap(values []*ActualLRPGroupsByProcessGuidRequest) []*ProtoActualLRPGroupsByProcessGuidRequest {
	result := make([]*ProtoActualLRPGroupsByProcessGuidRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPGroupByProcessGuidAndIndexRequest directly
type ActualLRPGroupByProcessGuidAndIndexRequest struct {
	ProcessGuid string
	Index       int32
}

func (x *ActualLRPGroupByProcessGuidAndIndexRequest) ToProto() *ProtoActualLRPGroupByProcessGuidAndIndexRequest {
	proto := &ProtoActualLRPGroupByProcessGuidAndIndexRequest{
		ProcessGuid: x.ProcessGuid,
		Index:       x.Index,
	}
	return proto
}

func ActualLRPGroupByProcessGuidAndIndexRequestProtoMap(values []*ActualLRPGroupByProcessGuidAndIndexRequest) []*ProtoActualLRPGroupByProcessGuidAndIndexRequest {
	result := make([]*ProtoActualLRPGroupByProcessGuidAndIndexRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoClaimActualLRPRequest directly
type ClaimActualLRPRequest struct {
	ProcessGuid          string
	Index                int32
	ActualLrpInstanceKey *ActualLRPInstanceKey
}

func (x *ClaimActualLRPRequest) ToProto() *ProtoClaimActualLRPRequest {
	proto := &ProtoClaimActualLRPRequest{
		ProcessGuid:          x.ProcessGuid,
		Index:                x.Index,
		ActualLrpInstanceKey: x.ActualLrpInstanceKey.ToProto(),
	}
	return proto
}

func ClaimActualLRPRequestProtoMap(values []*ClaimActualLRPRequest) []*ProtoClaimActualLRPRequest {
	result := make([]*ProtoClaimActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoStartActualLRPRequest directly
type StartActualLRPRequest struct {
	ActualLrpKey            *ActualLRPKey
	ActualLrpInstanceKey    *ActualLRPInstanceKey
	ActualLrpNetInfo        *ActualLRPNetInfo
	ActualLrpInternalRoutes []*ActualLRPInternalRoute
	MetricTags              map[string]string
	Routable                bool
	AvailabilityZone        string
}

func (x *StartActualLRPRequest) ToProto() *ProtoStartActualLRPRequest {
	proto := &ProtoStartActualLRPRequest{
		ActualLrpKey:            x.ActualLrpKey.ToProto(),
		ActualLrpInstanceKey:    x.ActualLrpInstanceKey.ToProto(),
		ActualLrpNetInfo:        x.ActualLrpNetInfo.ToProto(),
		ActualLrpInternalRoutes: ActualLRPInternalRouteProtoMap(x.ActualLrpInternalRoutes),
		MetricTags:              x.MetricTags,
		Routable:                &x.Routable,
		AvailabilityZone:        x.AvailabilityZone,
	}
	return proto
}

func StartActualLRPRequestProtoMap(values []*StartActualLRPRequest) []*ProtoStartActualLRPRequest {
	result := make([]*ProtoStartActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoCrashActualLRPRequest directly
type CrashActualLRPRequest struct {
	ActualLrpKey         *ActualLRPKey
	ActualLrpInstanceKey *ActualLRPInstanceKey
	ErrorMessage         string
}

func (x *CrashActualLRPRequest) ToProto() *ProtoCrashActualLRPRequest {
	proto := &ProtoCrashActualLRPRequest{
		ActualLrpKey:         x.ActualLrpKey.ToProto(),
		ActualLrpInstanceKey: x.ActualLrpInstanceKey.ToProto(),
		ErrorMessage:         x.ErrorMessage,
	}
	return proto
}

func CrashActualLRPRequestProtoMap(values []*CrashActualLRPRequest) []*ProtoCrashActualLRPRequest {
	result := make([]*ProtoCrashActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoFailActualLRPRequest directly
type FailActualLRPRequest struct {
	ActualLrpKey *ActualLRPKey
	ErrorMessage string
}

func (x *FailActualLRPRequest) ToProto() *ProtoFailActualLRPRequest {
	proto := &ProtoFailActualLRPRequest{
		ActualLrpKey: x.ActualLrpKey.ToProto(),
		ErrorMessage: x.ErrorMessage,
	}
	return proto
}

func FailActualLRPRequestProtoMap(values []*FailActualLRPRequest) []*ProtoFailActualLRPRequest {
	result := make([]*ProtoFailActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoRetireActualLRPRequest directly
type RetireActualLRPRequest struct {
	ActualLrpKey *ActualLRPKey
}

func (x *RetireActualLRPRequest) ToProto() *ProtoRetireActualLRPRequest {
	proto := &ProtoRetireActualLRPRequest{
		ActualLrpKey: x.ActualLrpKey.ToProto(),
	}
	return proto
}

func RetireActualLRPRequestProtoMap(values []*RetireActualLRPRequest) []*ProtoRetireActualLRPRequest {
	result := make([]*ProtoRetireActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoRemoveActualLRPRequest directly
type RemoveActualLRPRequest struct {
	ProcessGuid          string
	Index                int32
	ActualLrpInstanceKey *ActualLRPInstanceKey
}

func (x *RemoveActualLRPRequest) ToProto() *ProtoRemoveActualLRPRequest {
	proto := &ProtoRemoveActualLRPRequest{
		ProcessGuid:          x.ProcessGuid,
		Index:                x.Index,
		ActualLrpInstanceKey: x.ActualLrpInstanceKey.ToProto(),
	}
	return proto
}

func RemoveActualLRPRequestProtoMap(values []*RemoveActualLRPRequest) []*ProtoRemoveActualLRPRequest {
	result := make([]*ProtoRemoveActualLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPsResponse directly
type ActualLRPsResponse struct {
	Error      *Error
	ActualLrps []*ActualLRP
}

func (x *ActualLRPsResponse) ToProto() *ProtoActualLRPsResponse {
	proto := &ProtoActualLRPsResponse{
		Error:      x.Error.ToProto(),
		ActualLrps: ActualLRPProtoMap(x.ActualLrps),
	}
	return proto
}

func ActualLRPsResponseProtoMap(values []*ActualLRPsResponse) []*ProtoActualLRPsResponse {
	result := make([]*ProtoActualLRPsResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPsRequest directly
type ActualLRPsRequest struct {
	Domain      string
	CellId      string
	ProcessGuid string
	Index       int32
}

func (x *ActualLRPsRequest) ToProto() *ProtoActualLRPsRequest {
	proto := &ProtoActualLRPsRequest{
		Domain:      x.Domain,
		CellId:      x.CellId,
		ProcessGuid: x.ProcessGuid,
		Index:       &x.Index,
	}
	return proto
}

func ActualLRPsRequestProtoMap(values []*ActualLRPsRequest) []*ProtoActualLRPsRequest {
	result := make([]*ProtoActualLRPsRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}
