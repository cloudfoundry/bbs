// Code generated by protoc-gen-go-bbs. DO NOT EDIT.
// versions:
// - protoc-gen-go-bbs v0.0.1
// - protoc            v5.27.0--rc1
// source: actions.proto

package models

// Prevent copylock errors when using ProtoAction directly
type Action struct {
	DownloadAction     *DownloadAction
	UploadAction       *UploadAction
	RunAction          *RunAction
	TimeoutAction      *TimeoutAction
	EmitProgressAction *EmitProgressAction
	TryAction          *TryAction
	ParallelAction     *ParallelAction
	SerialAction       *SerialAction
	CodependentAction  *CodependentAction
}

func (x *Action) ToProto() *ProtoAction {
	proto := &ProtoAction{
		DownloadAction:     x.DownloadAction.ToProto(),
		UploadAction:       x.UploadAction.ToProto(),
		RunAction:          x.RunAction.ToProto(),
		TimeoutAction:      x.TimeoutAction.ToProto(),
		EmitProgressAction: x.EmitProgressAction.ToProto(),
		TryAction:          x.TryAction.ToProto(),
		ParallelAction:     x.ParallelAction.ToProto(),
		SerialAction:       x.SerialAction.ToProto(),
		CodependentAction:  x.CodependentAction.ToProto(),
	}
	return proto
}

func ActionProtoMap(values []*Action) []*ProtoAction {
	result := make([]*ProtoAction, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDownloadAction directly
type DownloadAction struct {
	Artifact          string
	From              string
	To                string
	CacheKey          string
	LogSource         string
	User              string
	ChecksumAlgorithm string
	ChecksumValue     string
}

func (x *DownloadAction) ToProto() *ProtoDownloadAction {
	proto := &ProtoDownloadAction{
		Artifact:          x.Artifact,
		From:              x.From,
		To:                x.To,
		CacheKey:          x.CacheKey,
		LogSource:         x.LogSource,
		User:              x.User,
		ChecksumAlgorithm: x.ChecksumAlgorithm,
		ChecksumValue:     x.ChecksumValue,
	}
	return proto
}

func DownloadActionProtoMap(values []*DownloadAction) []*ProtoDownloadAction {
	result := make([]*ProtoDownloadAction, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoUploadAction directly
type UploadAction struct {
	Artifact  string
	From      string
	To        string
	LogSource string
	User      string
}

func (x *UploadAction) ToProto() *ProtoUploadAction {
	proto := &ProtoUploadAction{
		Artifact:  x.Artifact,
		From:      x.From,
		To:        x.To,
		LogSource: x.LogSource,
		User:      x.User,
	}
	return proto
}

func UploadActionProtoMap(values []*UploadAction) []*ProtoUploadAction {
	result := make([]*ProtoUploadAction, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoRunAction directly
type RunAction struct {
	Path              string
	Args              []string
	Dir               string
	Env               []*EnvironmentVariable
	ResourceLimits    *ResourceLimits
	User              string
	LogSource         string
	SuppressLogOutput bool
}

func (x *RunAction) ToProto() *ProtoRunAction {
	proto := &ProtoRunAction{
		Path:              x.Path,
		Args:              x.Args,
		Dir:               x.Dir,
		Env:               EnvironmentVariableProtoMap(x.Env),
		ResourceLimits:    x.ResourceLimits.ToProto(),
		User:              x.User,
		LogSource:         x.LogSource,
		SuppressLogOutput: x.SuppressLogOutput,
	}
	return proto
}

func RunActionProtoMap(values []*RunAction) []*ProtoRunAction {
	result := make([]*ProtoRunAction, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoTimeoutAction directly
type TimeoutAction struct {
	Action              *Action
	DeprecatedTimeoutNs int64
	LogSource           string
	TimeoutMs           int64
}

func (x *TimeoutAction) ToProto() *ProtoTimeoutAction {
	proto := &ProtoTimeoutAction{
		Action:              x.Action.ToProto(),
		DeprecatedTimeoutNs: x.DeprecatedTimeoutNs,
		LogSource:           x.LogSource,
		TimeoutMs:           x.TimeoutMs,
	}
	return proto
}

func TimeoutActionProtoMap(values []*TimeoutAction) []*ProtoTimeoutAction {
	result := make([]*ProtoTimeoutAction, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoEmitProgressAction directly
type EmitProgressAction struct {
	Action               *Action
	StartMessage         string
	SuccessMessage       string
	FailureMessagePrefix string
	LogSource            string
}

func (x *EmitProgressAction) ToProto() *ProtoEmitProgressAction {
	proto := &ProtoEmitProgressAction{
		Action:               x.Action.ToProto(),
		StartMessage:         x.StartMessage,
		SuccessMessage:       x.SuccessMessage,
		FailureMessagePrefix: x.FailureMessagePrefix,
		LogSource:            x.LogSource,
	}
	return proto
}

func EmitProgressActionProtoMap(values []*EmitProgressAction) []*ProtoEmitProgressAction {
	result := make([]*ProtoEmitProgressAction, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoTryAction directly
type TryAction struct {
	Action    *Action
	LogSource string
}

func (x *TryAction) ToProto() *ProtoTryAction {
	proto := &ProtoTryAction{
		Action:    x.Action.ToProto(),
		LogSource: x.LogSource,
	}
	return proto
}

func TryActionProtoMap(values []*TryAction) []*ProtoTryAction {
	result := make([]*ProtoTryAction, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoParallelAction directly
type ParallelAction struct {
	Actions   []*Action
	LogSource string
}

func (x *ParallelAction) ToProto() *ProtoParallelAction {
	proto := &ProtoParallelAction{
		Actions:   ActionProtoMap(x.Actions),
		LogSource: x.LogSource,
	}
	return proto
}

func ParallelActionProtoMap(values []*ParallelAction) []*ProtoParallelAction {
	result := make([]*ProtoParallelAction, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoSerialAction directly
type SerialAction struct {
	Actions   []*Action
	LogSource string
}

func (x *SerialAction) ToProto() *ProtoSerialAction {
	proto := &ProtoSerialAction{
		Actions:   ActionProtoMap(x.Actions),
		LogSource: x.LogSource,
	}
	return proto
}

func SerialActionProtoMap(values []*SerialAction) []*ProtoSerialAction {
	result := make([]*ProtoSerialAction, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoCodependentAction directly
type CodependentAction struct {
	Actions   []*Action
	LogSource string
}

func (x *CodependentAction) ToProto() *ProtoCodependentAction {
	proto := &ProtoCodependentAction{
		Actions:   ActionProtoMap(x.Actions),
		LogSource: x.LogSource,
	}
	return proto
}

func CodependentActionProtoMap(values []*CodependentAction) []*ProtoCodependentAction {
	result := make([]*ProtoCodependentAction, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoResourceLimits directly
type ResourceLimits struct {
	Nofile uint64
	Nproc  uint64
}

func (x *ResourceLimits) ToProto() *ProtoResourceLimits {
	proto := &ProtoResourceLimits{
		Nofile: &x.Nofile,
		Nproc:  &x.Nproc,
	}
	return proto
}

func ResourceLimitsProtoMap(values []*ResourceLimits) []*ProtoResourceLimits {
	result := make([]*ProtoResourceLimits, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}
