// Code generated by protoc-gen-go-bbs. DO NOT EDIT.
// versions:
// - protoc-gen-go-bbs v0.0.1
// - protoc            v5.27.0--rc1
// source: desired_lrp.proto

package models

import (
	bytes "bytes"
)

// Prevent copylock errors when using ProtoDesiredLRPSchedulingInfo directly
type DesiredLRPSchedulingInfo struct {
	DesiredLRPKey      *DesiredLRPKey
	Annotation         string
	Instances          int32
	DesiredLRPResource *DesiredLRPResource
	Routes             *Routes
	ModificationTag    *ModificationTag
	VolumePlacement    *VolumePlacement
	ProtoPlacementTags []string
}

func (this *DesiredLRPSchedulingInfo) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRPSchedulingInfo)
	if !ok {
		that2, ok := that.(DesiredLRPSchedulingInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.DesiredLRPKey.Equal(that1.DesiredLRPKey) {
		return false
	}
	if this.Annotation != that1.Annotation {
		return false
	}
	if this.Instances != that1.Instances {
		return false
	}
	if !this.DesiredLRPResource.Equal(that1.DesiredLRPResource) {
		return false
	}
	if !this.Routes.Equal(that1.Routes) {
		return false
	}
	if !this.ModificationTag.Equal(that1.ModificationTag) {
		return false
	}
	if !this.VolumePlacement.Equal(that1.VolumePlacement) {
		return false
	}
	if len(this.ProtoPlacementTags) != len(that1.ProtoPlacementTags) {
		return false
	}
	for i := range this.ProtoPlacementTags {
		if this.ProtoPlacementTags[i] != that1.ProtoPlacementTags[i] {
			return false
		}
	}
	return true
}
func (m *DesiredLRPSchedulingInfo) GetDesiredLRPKey() *DesiredLRPKey {
	if m != nil {
		return m.DesiredLRPKey
	}
	return nil
}
func (m *DesiredLRPSchedulingInfo) SetDesiredLRPKey(value *DesiredLRPKey) {
	if m != nil {
		m.DesiredLRPKey = value
	}
}
func (m *DesiredLRPSchedulingInfo) GetAnnotation() string {
	if m != nil {
		return m.Annotation
	}
	return ""
}
func (m *DesiredLRPSchedulingInfo) SetAnnotation(value string) {
	if m != nil {
		m.Annotation = value
	}
}
func (m *DesiredLRPSchedulingInfo) GetInstances() int32 {
	if m != nil {
		return m.Instances
	}
	return 0
}
func (m *DesiredLRPSchedulingInfo) SetInstances(value int32) {
	if m != nil {
		m.Instances = value
	}
}
func (m *DesiredLRPSchedulingInfo) GetDesiredLRPResource() *DesiredLRPResource {
	if m != nil {
		return m.DesiredLRPResource
	}
	return nil
}
func (m *DesiredLRPSchedulingInfo) SetDesiredLRPResource(value *DesiredLRPResource) {
	if m != nil {
		m.DesiredLRPResource = value
	}
}
func (m *DesiredLRPSchedulingInfo) GetRoutes() *Routes {
	if m != nil {
		return m.Routes
	}
	return nil
}
func (m *DesiredLRPSchedulingInfo) SetRoutes(value *Routes) {
	if m != nil {
		m.Routes = value
	}
}
func (m *DesiredLRPSchedulingInfo) GetModificationTag() *ModificationTag {
	if m != nil {
		return m.ModificationTag
	}
	return nil
}
func (m *DesiredLRPSchedulingInfo) SetModificationTag(value *ModificationTag) {
	if m != nil {
		m.ModificationTag = value
	}
}
func (m *DesiredLRPSchedulingInfo) GetVolumePlacement() *VolumePlacement {
	if m != nil {
		return m.VolumePlacement
	}
	return nil
}
func (m *DesiredLRPSchedulingInfo) SetVolumePlacement(value *VolumePlacement) {
	if m != nil {
		m.VolumePlacement = value
	}
}
func (m *DesiredLRPSchedulingInfo) GetProtoPlacementTags() []string {
	if m != nil {
		return m.ProtoPlacementTags
	}
	return nil
}
func (m *DesiredLRPSchedulingInfo) SetProtoPlacementTags(value []string) {
	if m != nil {
		m.ProtoPlacementTags = value
	}
}
func (x *DesiredLRPSchedulingInfo) ToProto() *ProtoDesiredLRPSchedulingInfo {
	proto := &ProtoDesiredLRPSchedulingInfo{
		DesiredLrpKey:      x.DesiredLRPKey.ToProto(),
		Annotation:         x.Annotation,
		Instances:          x.Instances,
		DesiredLrpResource: x.DesiredLRPResource.ToProto(),
		Routes:             x.Routes.ToProto(),
		ModificationTag:    x.ModificationTag.ToProto(),
		VolumePlacement:    x.VolumePlacement.ToProto(),
		ProtoPlacementTags: x.ProtoPlacementTags,
	}
	return proto
}

func DesiredLRPSchedulingInfoProtoMap(values []*DesiredLRPSchedulingInfo) []*ProtoDesiredLRPSchedulingInfo {
	result := make([]*ProtoDesiredLRPSchedulingInfo, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPRunInfo directly
type DesiredLRPRunInfo struct {
	DesiredLRPKey                 *DesiredLRPKey
	EnvironmentVariables          []*EnvironmentVariable
	Setup                         *Action
	Action                        *Action
	Monitor                       *Action
	DeprecatedStartTimeoutS       uint32
	Privileged                    bool
	CpuWeight                     uint32
	Ports                         []uint32
	EgressRules                   []*SecurityGroupRule
	LogSource                     string
	MetricsGuid                   string
	CreatedAt                     int64
	CachedDependencies            []*CachedDependency
	LegacyDownloadUser            string
	TrustedSystemCertificatesPath string
	VolumeMounts                  []*VolumeMount
	Network                       *Network
	StartTimeoutMs                int64
	CertificateProperties         *CertificateProperties
	ImageUsername                 string
	ImagePassword                 string
	CheckDefinition               *CheckDefinition
	ImageLayers                   []*ImageLayer
	MetricTags                    map[string]*ProtoMetricTagValue
	Sidecars                      []*Sidecar
	LogRateLimit                  *LogRateLimit
}

func (this *DesiredLRPRunInfo) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRPRunInfo)
	if !ok {
		that2, ok := that.(DesiredLRPRunInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.DesiredLRPKey.Equal(that1.DesiredLRPKey) {
		return false
	}
	if len(this.EnvironmentVariables) != len(that1.EnvironmentVariables) {
		return false
	}
	for i := range this.EnvironmentVariables {
		if !this.EnvironmentVariables[i].Equal(that1.EnvironmentVariables[i]) {
			return false
		}
	}
	if !this.Setup.Equal(that1.Setup) {
		return false
	}
	if !this.Action.Equal(that1.Action) {
		return false
	}
	if !this.Monitor.Equal(that1.Monitor) {
		return false
	}
	if this.DeprecatedStartTimeoutS != that1.DeprecatedStartTimeoutS {
		return false
	}
	if this.Privileged != that1.Privileged {
		return false
	}
	if this.CpuWeight != that1.CpuWeight {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if this.Ports[i] != that1.Ports[i] {
			return false
		}
	}
	if len(this.EgressRules) != len(that1.EgressRules) {
		return false
	}
	for i := range this.EgressRules {
		if !this.EgressRules[i].Equal(that1.EgressRules[i]) {
			return false
		}
	}
	if this.LogSource != that1.LogSource {
		return false
	}
	if this.MetricsGuid != that1.MetricsGuid {
		return false
	}
	if this.CreatedAt != that1.CreatedAt {
		return false
	}
	if len(this.CachedDependencies) != len(that1.CachedDependencies) {
		return false
	}
	for i := range this.CachedDependencies {
		if !this.CachedDependencies[i].Equal(that1.CachedDependencies[i]) {
			return false
		}
	}
	if this.LegacyDownloadUser != that1.LegacyDownloadUser {
		return false
	}
	if this.TrustedSystemCertificatesPath != that1.TrustedSystemCertificatesPath {
		return false
	}
	if len(this.VolumeMounts) != len(that1.VolumeMounts) {
		return false
	}
	for i := range this.VolumeMounts {
		if !this.VolumeMounts[i].Equal(that1.VolumeMounts[i]) {
			return false
		}
	}
	if !this.Network.Equal(that1.Network) {
		return false
	}
	if this.StartTimeoutMs != that1.StartTimeoutMs {
		return false
	}
	if !this.CertificateProperties.Equal(that1.CertificateProperties) {
		return false
	}
	if this.ImageUsername != that1.ImageUsername {
		return false
	}
	if this.ImagePassword != that1.ImagePassword {
		return false
	}
	if !this.CheckDefinition.Equal(that1.CheckDefinition) {
		return false
	}
	if len(this.ImageLayers) != len(that1.ImageLayers) {
		return false
	}
	for i := range this.ImageLayers {
		if !this.ImageLayers[i].Equal(that1.ImageLayers[i]) {
			return false
		}
	}
	if len(this.MetricTags) != len(that1.MetricTags) {
		return false
	}
	for i := range this.MetricTags {
		if this.MetricTags[i] != that1.MetricTags[i] {
			return false
		}
	}
	if len(this.Sidecars) != len(that1.Sidecars) {
		return false
	}
	for i := range this.Sidecars {
		if !this.Sidecars[i].Equal(that1.Sidecars[i]) {
			return false
		}
	}
	if !this.LogRateLimit.Equal(that1.LogRateLimit) {
		return false
	}
	return true
}
func (m *DesiredLRPRunInfo) GetDesiredLRPKey() *DesiredLRPKey {
	if m != nil {
		return m.DesiredLRPKey
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetDesiredLRPKey(value *DesiredLRPKey) {
	if m != nil {
		m.DesiredLRPKey = value
	}
}
func (m *DesiredLRPRunInfo) GetEnvironmentVariables() []*EnvironmentVariable {
	if m != nil {
		return m.EnvironmentVariables
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetEnvironmentVariables(value []*EnvironmentVariable) {
	if m != nil {
		m.EnvironmentVariables = value
	}
}
func (m *DesiredLRPRunInfo) GetSetup() *Action {
	if m != nil {
		return m.Setup
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetSetup(value *Action) {
	if m != nil {
		m.Setup = value
	}
}
func (m *DesiredLRPRunInfo) GetAction() *Action {
	if m != nil {
		return m.Action
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetAction(value *Action) {
	if m != nil {
		m.Action = value
	}
}
func (m *DesiredLRPRunInfo) GetMonitor() *Action {
	if m != nil {
		return m.Monitor
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetMonitor(value *Action) {
	if m != nil {
		m.Monitor = value
	}
}

// DEPRECATED: DO NOT USE
func (m *DesiredLRPRunInfo) GetDeprecatedStartTimeoutS() uint32 {
	if m != nil {
		return m.DeprecatedStartTimeoutS
	}
	return 0
}
func (m *DesiredLRPRunInfo) SetDeprecatedStartTimeoutS(value uint32) {
	if m != nil {
		m.DeprecatedStartTimeoutS = value
	}
}
func (m *DesiredLRPRunInfo) GetPrivileged() bool {
	if m != nil {
		return m.Privileged
	}
	return false
}
func (m *DesiredLRPRunInfo) SetPrivileged(value bool) {
	if m != nil {
		m.Privileged = value
	}
}
func (m *DesiredLRPRunInfo) GetCpuWeight() uint32 {
	if m != nil {
		return m.CpuWeight
	}
	return 0
}
func (m *DesiredLRPRunInfo) SetCpuWeight(value uint32) {
	if m != nil {
		m.CpuWeight = value
	}
}
func (m *DesiredLRPRunInfo) GetPorts() []uint32 {
	if m != nil {
		return m.Ports
	}
	return 0
}
func (m *DesiredLRPRunInfo) SetPorts(value []uint32) {
	if m != nil {
		m.Ports = value
	}
}
func (m *DesiredLRPRunInfo) GetEgressRules() []*SecurityGroupRule {
	if m != nil {
		return m.EgressRules
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetEgressRules(value []*SecurityGroupRule) {
	if m != nil {
		m.EgressRules = value
	}
}
func (m *DesiredLRPRunInfo) GetLogSource() string {
	if m != nil {
		return m.LogSource
	}
	return ""
}
func (m *DesiredLRPRunInfo) SetLogSource(value string) {
	if m != nil {
		m.LogSource = value
	}
}

// DEPRECATED: DO NOT USE
func (m *DesiredLRPRunInfo) GetMetricsGuid() string {
	if m != nil {
		return m.MetricsGuid
	}
	return ""
}
func (m *DesiredLRPRunInfo) SetMetricsGuid(value string) {
	if m != nil {
		m.MetricsGuid = value
	}
}
func (m *DesiredLRPRunInfo) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}
func (m *DesiredLRPRunInfo) SetCreatedAt(value int64) {
	if m != nil {
		m.CreatedAt = value
	}
}
func (m *DesiredLRPRunInfo) GetCachedDependencies() []*CachedDependency {
	if m != nil {
		return m.CachedDependencies
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetCachedDependencies(value []*CachedDependency) {
	if m != nil {
		m.CachedDependencies = value
	}
}

// DEPRECATED: DO NOT USE
func (m *DesiredLRPRunInfo) GetLegacyDownloadUser() string {
	if m != nil {
		return m.LegacyDownloadUser
	}
	return ""
}
func (m *DesiredLRPRunInfo) SetLegacyDownloadUser(value string) {
	if m != nil {
		m.LegacyDownloadUser = value
	}
}
func (m *DesiredLRPRunInfo) GetTrustedSystemCertificatesPath() string {
	if m != nil {
		return m.TrustedSystemCertificatesPath
	}
	return ""
}
func (m *DesiredLRPRunInfo) SetTrustedSystemCertificatesPath(value string) {
	if m != nil {
		m.TrustedSystemCertificatesPath = value
	}
}
func (m *DesiredLRPRunInfo) GetVolumeMounts() []*VolumeMount {
	if m != nil {
		return m.VolumeMounts
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetVolumeMounts(value []*VolumeMount) {
	if m != nil {
		m.VolumeMounts = value
	}
}
func (m *DesiredLRPRunInfo) GetNetwork() *Network {
	if m != nil {
		return m.Network
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetNetwork(value *Network) {
	if m != nil {
		m.Network = value
	}
}
func (m *DesiredLRPRunInfo) GetStartTimeoutMs() int64 {
	if m != nil {
		return m.StartTimeoutMs
	}
	return 0
}
func (m *DesiredLRPRunInfo) SetStartTimeoutMs(value int64) {
	if m != nil {
		m.StartTimeoutMs = value
	}
}
func (m *DesiredLRPRunInfo) CertificatePropertiesExists() bool {
	return m != nil && m.CertificateProperties != nil
}
func (m *DesiredLRPRunInfo) GetCertificateProperties() *CertificateProperties {
	if m != nil && m.CertificateProperties != nil {
		return m.CertificateProperties
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetCertificateProperties(value *CertificateProperties) {
	if m != nil {
		m.CertificateProperties = value
	}
}
func (m *DesiredLRPRunInfo) GetImageUsername() string {
	if m != nil {
		return m.ImageUsername
	}
	return ""
}
func (m *DesiredLRPRunInfo) SetImageUsername(value string) {
	if m != nil {
		m.ImageUsername = value
	}
}
func (m *DesiredLRPRunInfo) GetImagePassword() string {
	if m != nil {
		return m.ImagePassword
	}
	return ""
}
func (m *DesiredLRPRunInfo) SetImagePassword(value string) {
	if m != nil {
		m.ImagePassword = value
	}
}
func (m *DesiredLRPRunInfo) GetCheckDefinition() *CheckDefinition {
	if m != nil {
		return m.CheckDefinition
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetCheckDefinition(value *CheckDefinition) {
	if m != nil {
		m.CheckDefinition = value
	}
}
func (m *DesiredLRPRunInfo) GetImageLayers() []*ImageLayer {
	if m != nil {
		return m.ImageLayers
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetImageLayers(value []*ImageLayer) {
	if m != nil {
		m.ImageLayers = value
	}
}
func (m *DesiredLRPRunInfo) GetMetricTags() map[string]*ProtoMetricTagValue {
	if m != nil {
		return m.MetricTags
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetMetricTags(value map[string]*ProtoMetricTagValue) {
	if m != nil {
		m.MetricTags = value
	}
}
func (m *DesiredLRPRunInfo) GetSidecars() []*Sidecar {
	if m != nil {
		return m.Sidecars
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetSidecars(value []*Sidecar) {
	if m != nil {
		m.Sidecars = value
	}
}
func (m *DesiredLRPRunInfo) GetLogRateLimit() *LogRateLimit {
	if m != nil {
		return m.LogRateLimit
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetLogRateLimit(value *LogRateLimit) {
	if m != nil {
		m.LogRateLimit = value
	}
}
func (x *DesiredLRPRunInfo) ToProto() *ProtoDesiredLRPRunInfo {
	proto := &ProtoDesiredLRPRunInfo{
		DesiredLrpKey:                 x.DesiredLRPKey.ToProto(),
		EnvironmentVariables:          EnvironmentVariableProtoMap(x.EnvironmentVariables),
		Setup:                         x.Action.ToProto(),
		Action:                        x.Action.ToProto(),
		Monitor:                       x.Action.ToProto(),
		DeprecatedStartTimeoutS:       x.DeprecatedStartTimeoutS,
		Privileged:                    x.Privileged,
		CpuWeight:                     x.CpuWeight,
		Ports:                         x.Ports,
		EgressRules:                   SecurityGroupRuleProtoMap(x.EgressRules),
		LogSource:                     x.LogSource,
		MetricsGuid:                   x.MetricsGuid,
		CreatedAt:                     x.CreatedAt,
		CachedDependencies:            CachedDependencyProtoMap(x.CachedDependencies),
		LegacyDownloadUser:            x.LegacyDownloadUser,
		TrustedSystemCertificatesPath: x.TrustedSystemCertificatesPath,
		VolumeMounts:                  VolumeMountProtoMap(x.VolumeMounts),
		Network:                       x.Network.ToProto(),
		StartTimeoutMs:                x.StartTimeoutMs,
		CertificateProperties:         x.CertificateProperties.ToProto(),
		ImageUsername:                 x.ImageUsername,
		ImagePassword:                 x.ImagePassword,
		CheckDefinition:               x.CheckDefinition.ToProto(),
		ImageLayers:                   ImageLayerProtoMap(x.ImageLayers),
		MetricTags:                    x.MetricTags,
		Sidecars:                      SidecarProtoMap(x.Sidecars),
		LogRateLimit:                  x.LogRateLimit.ToProto(),
	}
	return proto
}

func DesiredLRPRunInfoProtoMap(values []*DesiredLRPRunInfo) []*ProtoDesiredLRPRunInfo {
	result := make([]*ProtoDesiredLRPRunInfo, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoRoutes directly
type Routes struct {
	Routes map[string][]byte
}

func (this *Routes) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Routes)
	if !ok {
		that2, ok := that.(Routes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !bytes.Equal(this.Routes[i], that1.Routes[i]) {
			return false
		}
	}
	return true
}
func (m *Routes) GetRoutes() map[string][]byte {
	if m != nil {
		return m.Routes
	}
	return nil
}
func (m *Routes) SetRoutes(value map[string][]byte) {
	if m != nil {
		m.Routes = value
	}
}
func (x *Routes) ToProto() *ProtoRoutes {
	proto := &ProtoRoutes{
		Routes: x.Routes,
	}
	return proto
}

func RoutesProtoMap(values []*Routes) []*ProtoRoutes {
	result := make([]*ProtoRoutes, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPUpdate directly
type DesiredLRPUpdate struct {
	Instances  *int32
	Routes     *Routes
	Annotation *string
	MetricTags map[string]*ProtoMetricTagValue
}

func (this *DesiredLRPUpdate) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRPUpdate)
	if !ok {
		that2, ok := that.(DesiredLRPUpdate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Instances != that1.Instances {
		return false
	}
	if !this.Routes.Equal(that1.Routes) {
		return false
	}
	if this.Annotation != that1.Annotation {
		return false
	}
	if len(this.MetricTags) != len(that1.MetricTags) {
		return false
	}
	for i := range this.MetricTags {
		if this.MetricTags[i] != that1.MetricTags[i] {
			return false
		}
	}
	return true
}
func (m *DesiredLRPUpdate) InstancesExists() bool {
	return m != nil && m.Instances != nil
}
func (m *DesiredLRPUpdate) GetInstances() *int32 {
	if m != nil && m.Instances != nil {
		return m.Instances
	}
	return nil
}
func (m *DesiredLRPUpdate) SetInstances(value *int32) {
	if m != nil {
		m.Instances = value
	}
}
func (m *DesiredLRPUpdate) RoutesExists() bool {
	return m != nil && m.Routes != nil
}
func (m *DesiredLRPUpdate) GetRoutes() *Routes {
	if m != nil && m.Routes != nil {
		return m.Routes
	}
	return nil
}
func (m *DesiredLRPUpdate) SetRoutes(value *Routes) {
	if m != nil {
		m.Routes = value
	}
}
func (m *DesiredLRPUpdate) AnnotationExists() bool {
	return m != nil && m.Annotation != nil
}
func (m *DesiredLRPUpdate) GetAnnotation() *string {
	if m != nil && m.Annotation != nil {
		return m.Annotation
	}
	return nil
}
func (m *DesiredLRPUpdate) SetAnnotation(value *string) {
	if m != nil {
		m.Annotation = value
	}
}
func (m *DesiredLRPUpdate) GetMetricTags() map[string]*ProtoMetricTagValue {
	if m != nil {
		return m.MetricTags
	}
	return nil
}
func (m *DesiredLRPUpdate) SetMetricTags(value map[string]*ProtoMetricTagValue) {
	if m != nil {
		m.MetricTags = value
	}
}
func (x *DesiredLRPUpdate) ToProto() *ProtoDesiredLRPUpdate {
	proto := &ProtoDesiredLRPUpdate{
		Instances:  x.Instances,
		Routes:     x.Routes.ToProto(),
		Annotation: x.Annotation,
		MetricTags: x.MetricTags,
	}
	return proto
}

func DesiredLRPUpdateProtoMap(values []*DesiredLRPUpdate) []*ProtoDesiredLRPUpdate {
	result := make([]*ProtoDesiredLRPUpdate, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPKey directly
type DesiredLRPKey struct {
	ProcessGuid string
	Domain      string
	LogGuid     string
}

func (this *DesiredLRPKey) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRPKey)
	if !ok {
		that2, ok := that.(DesiredLRPKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.ProcessGuid != that1.ProcessGuid {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	if this.LogGuid != that1.LogGuid {
		return false
	}
	return true
}
func (m *DesiredLRPKey) GetProcessGuid() string {
	if m != nil {
		return m.ProcessGuid
	}
	return ""
}
func (m *DesiredLRPKey) SetProcessGuid(value string) {
	if m != nil {
		m.ProcessGuid = value
	}
}
func (m *DesiredLRPKey) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}
func (m *DesiredLRPKey) SetDomain(value string) {
	if m != nil {
		m.Domain = value
	}
}
func (m *DesiredLRPKey) GetLogGuid() string {
	if m != nil {
		return m.LogGuid
	}
	return ""
}
func (m *DesiredLRPKey) SetLogGuid(value string) {
	if m != nil {
		m.LogGuid = value
	}
}
func (x *DesiredLRPKey) ToProto() *ProtoDesiredLRPKey {
	proto := &ProtoDesiredLRPKey{
		ProcessGuid: x.ProcessGuid,
		Domain:      x.Domain,
		LogGuid:     x.LogGuid,
	}
	return proto
}

func DesiredLRPKeyProtoMap(values []*DesiredLRPKey) []*ProtoDesiredLRPKey {
	result := make([]*ProtoDesiredLRPKey, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPResource directly
type DesiredLRPResource struct {
	MemoryMb int32
	DiskMb   int32
	RootFs   string
	MaxPids  int32
}

func (this *DesiredLRPResource) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRPResource)
	if !ok {
		that2, ok := that.(DesiredLRPResource)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.MemoryMb != that1.MemoryMb {
		return false
	}
	if this.DiskMb != that1.DiskMb {
		return false
	}
	if this.RootFs != that1.RootFs {
		return false
	}
	if this.MaxPids != that1.MaxPids {
		return false
	}
	return true
}
func (m *DesiredLRPResource) GetMemoryMb() int32 {
	if m != nil {
		return m.MemoryMb
	}
	return 0
}
func (m *DesiredLRPResource) SetMemoryMb(value int32) {
	if m != nil {
		m.MemoryMb = value
	}
}
func (m *DesiredLRPResource) GetDiskMb() int32 {
	if m != nil {
		return m.DiskMb
	}
	return 0
}
func (m *DesiredLRPResource) SetDiskMb(value int32) {
	if m != nil {
		m.DiskMb = value
	}
}
func (m *DesiredLRPResource) GetRootFs() string {
	if m != nil {
		return m.RootFs
	}
	return ""
}
func (m *DesiredLRPResource) SetRootFs(value string) {
	if m != nil {
		m.RootFs = value
	}
}
func (m *DesiredLRPResource) GetMaxPids() int32 {
	if m != nil {
		return m.MaxPids
	}
	return 0
}
func (m *DesiredLRPResource) SetMaxPids(value int32) {
	if m != nil {
		m.MaxPids = value
	}
}
func (x *DesiredLRPResource) ToProto() *ProtoDesiredLRPResource {
	proto := &ProtoDesiredLRPResource{
		MemoryMb: x.MemoryMb,
		DiskMb:   x.DiskMb,
		RootFs:   x.RootFs,
		MaxPids:  x.MaxPids,
	}
	return proto
}

func DesiredLRPResourceProtoMap(values []*DesiredLRPResource) []*ProtoDesiredLRPResource {
	result := make([]*ProtoDesiredLRPResource, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRP directly
type DesiredLRP struct {
	ProcessGuid                   string
	Domain                        string
	RootFs                        string
	Instances                     int32
	EnvironmentVariables          []*EnvironmentVariable
	Setup                         *Action
	Action                        *Action
	StartTimeoutMs                int64
	DeprecatedStartTimeoutS       uint32
	Monitor                       *Action
	DiskMb                        int32
	MemoryMb                      int32
	CpuWeight                     uint32
	Privileged                    bool
	Ports                         []uint32
	Routes                        *Routes
	LogSource                     string
	LogGuid                       string
	MetricsGuid                   string
	Annotation                    string
	EgressRules                   []*SecurityGroupRule
	ModificationTag               *ModificationTag
	CachedDependencies            []*CachedDependency
	LegacyDownloadUser            string
	TrustedSystemCertificatesPath string
	VolumeMounts                  []*VolumeMount
	Network                       *Network
	ProtoPlacementTags            []string
	MaxPids                       int32
	CertificateProperties         *CertificateProperties
	ImageUsername                 string
	ImagePassword                 string
	CheckDefinition               *CheckDefinition
	ImageLayers                   []*ImageLayer
	MetricTags                    map[string]*ProtoMetricTagValue
	Sidecars                      []*Sidecar
	LogRateLimit                  *LogRateLimit
}

func (this *DesiredLRP) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRP)
	if !ok {
		that2, ok := that.(DesiredLRP)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.ProcessGuid != that1.ProcessGuid {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	if this.RootFs != that1.RootFs {
		return false
	}
	if this.Instances != that1.Instances {
		return false
	}
	if len(this.EnvironmentVariables) != len(that1.EnvironmentVariables) {
		return false
	}
	for i := range this.EnvironmentVariables {
		if !this.EnvironmentVariables[i].Equal(that1.EnvironmentVariables[i]) {
			return false
		}
	}
	if !this.Setup.Equal(that1.Setup) {
		return false
	}
	if !this.Action.Equal(that1.Action) {
		return false
	}
	if this.StartTimeoutMs != that1.StartTimeoutMs {
		return false
	}
	if this.DeprecatedStartTimeoutS != that1.DeprecatedStartTimeoutS {
		return false
	}
	if !this.Monitor.Equal(that1.Monitor) {
		return false
	}
	if this.DiskMb != that1.DiskMb {
		return false
	}
	if this.MemoryMb != that1.MemoryMb {
		return false
	}
	if this.CpuWeight != that1.CpuWeight {
		return false
	}
	if this.Privileged != that1.Privileged {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if this.Ports[i] != that1.Ports[i] {
			return false
		}
	}
	if !this.Routes.Equal(that1.Routes) {
		return false
	}
	if this.LogSource != that1.LogSource {
		return false
	}
	if this.LogGuid != that1.LogGuid {
		return false
	}
	if this.MetricsGuid != that1.MetricsGuid {
		return false
	}
	if this.Annotation != that1.Annotation {
		return false
	}
	if len(this.EgressRules) != len(that1.EgressRules) {
		return false
	}
	for i := range this.EgressRules {
		if !this.EgressRules[i].Equal(that1.EgressRules[i]) {
			return false
		}
	}
	if !this.ModificationTag.Equal(that1.ModificationTag) {
		return false
	}
	if len(this.CachedDependencies) != len(that1.CachedDependencies) {
		return false
	}
	for i := range this.CachedDependencies {
		if !this.CachedDependencies[i].Equal(that1.CachedDependencies[i]) {
			return false
		}
	}
	if this.LegacyDownloadUser != that1.LegacyDownloadUser {
		return false
	}
	if this.TrustedSystemCertificatesPath != that1.TrustedSystemCertificatesPath {
		return false
	}
	if len(this.VolumeMounts) != len(that1.VolumeMounts) {
		return false
	}
	for i := range this.VolumeMounts {
		if !this.VolumeMounts[i].Equal(that1.VolumeMounts[i]) {
			return false
		}
	}
	if !this.Network.Equal(that1.Network) {
		return false
	}
	if len(this.ProtoPlacementTags) != len(that1.ProtoPlacementTags) {
		return false
	}
	for i := range this.ProtoPlacementTags {
		if this.ProtoPlacementTags[i] != that1.ProtoPlacementTags[i] {
			return false
		}
	}
	if this.MaxPids != that1.MaxPids {
		return false
	}
	if !this.CertificateProperties.Equal(that1.CertificateProperties) {
		return false
	}
	if this.ImageUsername != that1.ImageUsername {
		return false
	}
	if this.ImagePassword != that1.ImagePassword {
		return false
	}
	if !this.CheckDefinition.Equal(that1.CheckDefinition) {
		return false
	}
	if len(this.ImageLayers) != len(that1.ImageLayers) {
		return false
	}
	for i := range this.ImageLayers {
		if !this.ImageLayers[i].Equal(that1.ImageLayers[i]) {
			return false
		}
	}
	if len(this.MetricTags) != len(that1.MetricTags) {
		return false
	}
	for i := range this.MetricTags {
		if this.MetricTags[i] != that1.MetricTags[i] {
			return false
		}
	}
	if len(this.Sidecars) != len(that1.Sidecars) {
		return false
	}
	for i := range this.Sidecars {
		if !this.Sidecars[i].Equal(that1.Sidecars[i]) {
			return false
		}
	}
	if !this.LogRateLimit.Equal(that1.LogRateLimit) {
		return false
	}
	return true
}
func (m *DesiredLRP) GetProcessGuid() string {
	if m != nil {
		return m.ProcessGuid
	}
	return ""
}
func (m *DesiredLRP) SetProcessGuid(value string) {
	if m != nil {
		m.ProcessGuid = value
	}
}
func (m *DesiredLRP) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}
func (m *DesiredLRP) SetDomain(value string) {
	if m != nil {
		m.Domain = value
	}
}
func (m *DesiredLRP) GetRootFs() string {
	if m != nil {
		return m.RootFs
	}
	return ""
}
func (m *DesiredLRP) SetRootFs(value string) {
	if m != nil {
		m.RootFs = value
	}
}
func (m *DesiredLRP) GetInstances() int32 {
	if m != nil {
		return m.Instances
	}
	return 0
}
func (m *DesiredLRP) SetInstances(value int32) {
	if m != nil {
		m.Instances = value
	}
}
func (m *DesiredLRP) GetEnvironmentVariables() []*EnvironmentVariable {
	if m != nil {
		return m.EnvironmentVariables
	}
	return nil
}
func (m *DesiredLRP) SetEnvironmentVariables(value []*EnvironmentVariable) {
	if m != nil {
		m.EnvironmentVariables = value
	}
}
func (m *DesiredLRP) GetSetup() *Action {
	if m != nil {
		return m.Setup
	}
	return nil
}
func (m *DesiredLRP) SetSetup(value *Action) {
	if m != nil {
		m.Setup = value
	}
}
func (m *DesiredLRP) GetAction() *Action {
	if m != nil {
		return m.Action
	}
	return nil
}
func (m *DesiredLRP) SetAction(value *Action) {
	if m != nil {
		m.Action = value
	}
}
func (m *DesiredLRP) GetStartTimeoutMs() int64 {
	if m != nil {
		return m.StartTimeoutMs
	}
	return 0
}
func (m *DesiredLRP) SetStartTimeoutMs(value int64) {
	if m != nil {
		m.StartTimeoutMs = value
	}
}

// DEPRECATED: DO NOT USE
func (m *DesiredLRP) GetDeprecatedStartTimeoutS() uint32 {
	if m != nil {
		return m.DeprecatedStartTimeoutS
	}
	return 0
}
func (m *DesiredLRP) SetDeprecatedStartTimeoutS(value uint32) {
	if m != nil {
		m.DeprecatedStartTimeoutS = value
	}
}
func (m *DesiredLRP) GetMonitor() *Action {
	if m != nil {
		return m.Monitor
	}
	return nil
}
func (m *DesiredLRP) SetMonitor(value *Action) {
	if m != nil {
		m.Monitor = value
	}
}
func (m *DesiredLRP) GetDiskMb() int32 {
	if m != nil {
		return m.DiskMb
	}
	return 0
}
func (m *DesiredLRP) SetDiskMb(value int32) {
	if m != nil {
		m.DiskMb = value
	}
}
func (m *DesiredLRP) GetMemoryMb() int32 {
	if m != nil {
		return m.MemoryMb
	}
	return 0
}
func (m *DesiredLRP) SetMemoryMb(value int32) {
	if m != nil {
		m.MemoryMb = value
	}
}
func (m *DesiredLRP) GetCpuWeight() uint32 {
	if m != nil {
		return m.CpuWeight
	}
	return 0
}
func (m *DesiredLRP) SetCpuWeight(value uint32) {
	if m != nil {
		m.CpuWeight = value
	}
}
func (m *DesiredLRP) GetPrivileged() bool {
	if m != nil {
		return m.Privileged
	}
	return false
}
func (m *DesiredLRP) SetPrivileged(value bool) {
	if m != nil {
		m.Privileged = value
	}
}
func (m *DesiredLRP) GetPorts() []uint32 {
	if m != nil {
		return m.Ports
	}
	return 0
}
func (m *DesiredLRP) SetPorts(value []uint32) {
	if m != nil {
		m.Ports = value
	}
}
func (m *DesiredLRP) RoutesExists() bool {
	return m != nil && m.Routes != nil
}
func (m *DesiredLRP) GetRoutes() *Routes {
	if m != nil && m.Routes != nil {
		return m.Routes
	}
	return nil
}
func (m *DesiredLRP) SetRoutes(value *Routes) {
	if m != nil {
		m.Routes = value
	}
}
func (m *DesiredLRP) GetLogSource() string {
	if m != nil {
		return m.LogSource
	}
	return ""
}
func (m *DesiredLRP) SetLogSource(value string) {
	if m != nil {
		m.LogSource = value
	}
}
func (m *DesiredLRP) GetLogGuid() string {
	if m != nil {
		return m.LogGuid
	}
	return ""
}
func (m *DesiredLRP) SetLogGuid(value string) {
	if m != nil {
		m.LogGuid = value
	}
}

// DEPRECATED: DO NOT USE
func (m *DesiredLRP) GetMetricsGuid() string {
	if m != nil {
		return m.MetricsGuid
	}
	return ""
}
func (m *DesiredLRP) SetMetricsGuid(value string) {
	if m != nil {
		m.MetricsGuid = value
	}
}
func (m *DesiredLRP) GetAnnotation() string {
	if m != nil {
		return m.Annotation
	}
	return ""
}
func (m *DesiredLRP) SetAnnotation(value string) {
	if m != nil {
		m.Annotation = value
	}
}
func (m *DesiredLRP) GetEgressRules() []*SecurityGroupRule {
	if m != nil {
		return m.EgressRules
	}
	return nil
}
func (m *DesiredLRP) SetEgressRules(value []*SecurityGroupRule) {
	if m != nil {
		m.EgressRules = value
	}
}
func (m *DesiredLRP) GetModificationTag() *ModificationTag {
	if m != nil {
		return m.ModificationTag
	}
	return nil
}
func (m *DesiredLRP) SetModificationTag(value *ModificationTag) {
	if m != nil {
		m.ModificationTag = value
	}
}
func (m *DesiredLRP) GetCachedDependencies() []*CachedDependency {
	if m != nil {
		return m.CachedDependencies
	}
	return nil
}
func (m *DesiredLRP) SetCachedDependencies(value []*CachedDependency) {
	if m != nil {
		m.CachedDependencies = value
	}
}

// DEPRECATED: DO NOT USE
func (m *DesiredLRP) GetLegacyDownloadUser() string {
	if m != nil {
		return m.LegacyDownloadUser
	}
	return ""
}
func (m *DesiredLRP) SetLegacyDownloadUser(value string) {
	if m != nil {
		m.LegacyDownloadUser = value
	}
}
func (m *DesiredLRP) GetTrustedSystemCertificatesPath() string {
	if m != nil {
		return m.TrustedSystemCertificatesPath
	}
	return ""
}
func (m *DesiredLRP) SetTrustedSystemCertificatesPath(value string) {
	if m != nil {
		m.TrustedSystemCertificatesPath = value
	}
}
func (m *DesiredLRP) GetVolumeMounts() []*VolumeMount {
	if m != nil {
		return m.VolumeMounts
	}
	return nil
}
func (m *DesiredLRP) SetVolumeMounts(value []*VolumeMount) {
	if m != nil {
		m.VolumeMounts = value
	}
}
func (m *DesiredLRP) GetNetwork() *Network {
	if m != nil {
		return m.Network
	}
	return nil
}
func (m *DesiredLRP) SetNetwork(value *Network) {
	if m != nil {
		m.Network = value
	}
}
func (m *DesiredLRP) GetProtoPlacementTags() []string {
	if m != nil {
		return m.ProtoPlacementTags
	}
	return nil
}
func (m *DesiredLRP) SetProtoPlacementTags(value []string) {
	if m != nil {
		m.ProtoPlacementTags = value
	}
}
func (m *DesiredLRP) GetMaxPids() int32 {
	if m != nil {
		return m.MaxPids
	}
	return 0
}
func (m *DesiredLRP) SetMaxPids(value int32) {
	if m != nil {
		m.MaxPids = value
	}
}
func (m *DesiredLRP) CertificatePropertiesExists() bool {
	return m != nil && m.CertificateProperties != nil
}
func (m *DesiredLRP) GetCertificateProperties() *CertificateProperties {
	if m != nil && m.CertificateProperties != nil {
		return m.CertificateProperties
	}
	return nil
}
func (m *DesiredLRP) SetCertificateProperties(value *CertificateProperties) {
	if m != nil {
		m.CertificateProperties = value
	}
}
func (m *DesiredLRP) GetImageUsername() string {
	if m != nil {
		return m.ImageUsername
	}
	return ""
}
func (m *DesiredLRP) SetImageUsername(value string) {
	if m != nil {
		m.ImageUsername = value
	}
}
func (m *DesiredLRP) GetImagePassword() string {
	if m != nil {
		return m.ImagePassword
	}
	return ""
}
func (m *DesiredLRP) SetImagePassword(value string) {
	if m != nil {
		m.ImagePassword = value
	}
}
func (m *DesiredLRP) GetCheckDefinition() *CheckDefinition {
	if m != nil {
		return m.CheckDefinition
	}
	return nil
}
func (m *DesiredLRP) SetCheckDefinition(value *CheckDefinition) {
	if m != nil {
		m.CheckDefinition = value
	}
}
func (m *DesiredLRP) GetImageLayers() []*ImageLayer {
	if m != nil {
		return m.ImageLayers
	}
	return nil
}
func (m *DesiredLRP) SetImageLayers(value []*ImageLayer) {
	if m != nil {
		m.ImageLayers = value
	}
}
func (m *DesiredLRP) GetMetricTags() map[string]*ProtoMetricTagValue {
	if m != nil {
		return m.MetricTags
	}
	return nil
}
func (m *DesiredLRP) SetMetricTags(value map[string]*ProtoMetricTagValue) {
	if m != nil {
		m.MetricTags = value
	}
}
func (m *DesiredLRP) GetSidecars() []*Sidecar {
	if m != nil {
		return m.Sidecars
	}
	return nil
}
func (m *DesiredLRP) SetSidecars(value []*Sidecar) {
	if m != nil {
		m.Sidecars = value
	}
}
func (m *DesiredLRP) GetLogRateLimit() *LogRateLimit {
	if m != nil {
		return m.LogRateLimit
	}
	return nil
}
func (m *DesiredLRP) SetLogRateLimit(value *LogRateLimit) {
	if m != nil {
		m.LogRateLimit = value
	}
}
func (x *DesiredLRP) ToProto() *ProtoDesiredLRP {
	proto := &ProtoDesiredLRP{
		ProcessGuid:                   x.ProcessGuid,
		Domain:                        x.Domain,
		RootFs:                        x.RootFs,
		Instances:                     x.Instances,
		EnvironmentVariables:          EnvironmentVariableProtoMap(x.EnvironmentVariables),
		Setup:                         x.Action.ToProto(),
		Action:                        x.Action.ToProto(),
		StartTimeoutMs:                x.StartTimeoutMs,
		DeprecatedStartTimeoutS:       x.DeprecatedStartTimeoutS,
		Monitor:                       x.Action.ToProto(),
		DiskMb:                        x.DiskMb,
		MemoryMb:                      x.MemoryMb,
		CpuWeight:                     x.CpuWeight,
		Privileged:                    x.Privileged,
		Ports:                         x.Ports,
		Routes:                        x.Routes.ToProto(),
		LogSource:                     x.LogSource,
		LogGuid:                       x.LogGuid,
		MetricsGuid:                   x.MetricsGuid,
		Annotation:                    x.Annotation,
		EgressRules:                   SecurityGroupRuleProtoMap(x.EgressRules),
		ModificationTag:               x.ModificationTag.ToProto(),
		CachedDependencies:            CachedDependencyProtoMap(x.CachedDependencies),
		LegacyDownloadUser:            x.LegacyDownloadUser,
		TrustedSystemCertificatesPath: x.TrustedSystemCertificatesPath,
		VolumeMounts:                  VolumeMountProtoMap(x.VolumeMounts),
		Network:                       x.Network.ToProto(),
		ProtoPlacementTags:            x.ProtoPlacementTags,
		MaxPids:                       x.MaxPids,
		CertificateProperties:         x.CertificateProperties.ToProto(),
		ImageUsername:                 x.ImageUsername,
		ImagePassword:                 x.ImagePassword,
		CheckDefinition:               x.CheckDefinition.ToProto(),
		ImageLayers:                   ImageLayerProtoMap(x.ImageLayers),
		MetricTags:                    x.MetricTags,
		Sidecars:                      SidecarProtoMap(x.Sidecars),
		LogRateLimit:                  x.LogRateLimit.ToProto(),
	}
	return proto
}

func DesiredLRPProtoMap(values []*DesiredLRP) []*ProtoDesiredLRP {
	result := make([]*ProtoDesiredLRP, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}
