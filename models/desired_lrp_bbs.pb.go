// Code generated by protoc-gen-go-bbs. DO NOT EDIT.
// versions:
// - protoc-gen-go-bbs v0.0.1
// - protoc            v5.27.0--rc1
// source: desired_lrp.proto

package models

// Prevent copylock errors when using ProtoDesiredLRPSchedulingInfo directly
type DesiredLRPSchedulingInfo struct {
	DesiredLrpKey      *DesiredLRPKey
	Annotation         string
	Instances          int32
	DesiredLrpResource *DesiredLRPResource
	Routes             *Routes
	ModificationTag    *ModificationTag
	VolumePlacement    *VolumePlacement
	ProtoPlacementTags []string
}

func (x *DesiredLRPSchedulingInfo) ToProto() *ProtoDesiredLRPSchedulingInfo {
	proto := &ProtoDesiredLRPSchedulingInfo{
		DesiredLrpKey:      x.DesiredLrpKey.ToProto(),
		Annotation:         x.Annotation,
		Instances:          x.Instances,
		DesiredLrpResource: x.DesiredLrpResource.ToProto(),
		Routes:             x.Routes.ToProto(),
		ModificationTag:    x.ModificationTag.ToProto(),
		VolumePlacement:    x.VolumePlacement.ToProto(),
		ProtoPlacementTags: x.ProtoPlacementTags,
	}
	return proto
}

func DesiredLRPSchedulingInfoProtoMap(values []*DesiredLRPSchedulingInfo) []*ProtoDesiredLRPSchedulingInfo {
	result := make([]*ProtoDesiredLRPSchedulingInfo, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPRunInfo directly
type DesiredLRPRunInfo struct {
	DesiredLrpKey                 *DesiredLRPKey
	EnvironmentVariables          []*EnvironmentVariable
	Setup                         *Action
	Action                        *Action
	Monitor                       *Action
	DeprecatedStartTimeoutS       uint32
	Privileged                    bool
	CpuWeight                     uint32
	Ports                         []uint32
	EgressRules                   []*SecurityGroupRule
	LogSource                     string
	MetricsGuid                   string
	CreatedAt                     int64
	CachedDependencies            []*CachedDependency
	LegacyDownloadUser            string
	TrustedSystemCertificatesPath string
	VolumeMounts                  []*VolumeMount
	Network                       *Network
	StartTimeoutMs                int64
	CertificateProperties         *CertificateProperties
	ImageUsername                 string
	ImagePassword                 string
	CheckDefinition               *CheckDefinition
	ImageLayers                   []*ImageLayer
	MetricTags                    map[string]*ProtoMetricTagValue
	Sidecars                      []*Sidecar
	LogRateLimit                  *LogRateLimit
}

func (x *DesiredLRPRunInfo) ToProto() *ProtoDesiredLRPRunInfo {
	proto := &ProtoDesiredLRPRunInfo{
		DesiredLrpKey:                 x.DesiredLrpKey.ToProto(),
		EnvironmentVariables:          EnvironmentVariableProtoMap(x.EnvironmentVariables),
		Setup:                         x.Setup.ToProto(),
		Action:                        x.Action.ToProto(),
		Monitor:                       x.Monitor.ToProto(),
		DeprecatedStartTimeoutS:       x.DeprecatedStartTimeoutS,
		Privileged:                    x.Privileged,
		CpuWeight:                     x.CpuWeight,
		Ports:                         x.Ports,
		EgressRules:                   SecurityGroupRuleProtoMap(x.EgressRules),
		LogSource:                     x.LogSource,
		MetricsGuid:                   x.MetricsGuid,
		CreatedAt:                     x.CreatedAt,
		CachedDependencies:            CachedDependencyProtoMap(x.CachedDependencies),
		LegacyDownloadUser:            x.LegacyDownloadUser,
		TrustedSystemCertificatesPath: x.TrustedSystemCertificatesPath,
		VolumeMounts:                  VolumeMountProtoMap(x.VolumeMounts),
		Network:                       x.Network.ToProto(),
		StartTimeoutMs:                x.StartTimeoutMs,
		CertificateProperties:         x.CertificateProperties.ToProto(),
		ImageUsername:                 x.ImageUsername,
		ImagePassword:                 x.ImagePassword,
		CheckDefinition:               x.CheckDefinition.ToProto(),
		ImageLayers:                   ImageLayerProtoMap(x.ImageLayers),
		MetricTags:                    x.MetricTags,
		Sidecars:                      SidecarProtoMap(x.Sidecars),
		LogRateLimit:                  x.LogRateLimit.ToProto(),
	}
	return proto
}

func DesiredLRPRunInfoProtoMap(values []*DesiredLRPRunInfo) []*ProtoDesiredLRPRunInfo {
	result := make([]*ProtoDesiredLRPRunInfo, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPUpdate directly
type DesiredLRPUpdate struct {
	Instances  int32
	Routes     *Routes
	Annotation string
	MetricTags map[string]*ProtoMetricTagValue
}

func (x *DesiredLRPUpdate) ToProto() *ProtoDesiredLRPUpdate {
	proto := &ProtoDesiredLRPUpdate{
		Instances:  &x.Instances,
		Routes:     x.Routes.ToProto(),
		Annotation: &x.Annotation,
		MetricTags: x.MetricTags,
	}
	return proto
}

func DesiredLRPUpdateProtoMap(values []*DesiredLRPUpdate) []*ProtoDesiredLRPUpdate {
	result := make([]*ProtoDesiredLRPUpdate, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPKey directly
type DesiredLRPKey struct {
	ProcessGuid string
	Domain      string
	LogGuid     string
}

func (x *DesiredLRPKey) ToProto() *ProtoDesiredLRPKey {
	proto := &ProtoDesiredLRPKey{
		ProcessGuid: x.ProcessGuid,
		Domain:      x.Domain,
		LogGuid:     x.LogGuid,
	}
	return proto
}

func DesiredLRPKeyProtoMap(values []*DesiredLRPKey) []*ProtoDesiredLRPKey {
	result := make([]*ProtoDesiredLRPKey, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPResource directly
type DesiredLRPResource struct {
	MemoryMb int32
	DiskMb   int32
	RootFs   string
	MaxPids  int32
}

func (x *DesiredLRPResource) ToProto() *ProtoDesiredLRPResource {
	proto := &ProtoDesiredLRPResource{
		MemoryMb: x.MemoryMb,
		DiskMb:   x.DiskMb,
		RootFs:   x.RootFs,
		MaxPids:  x.MaxPids,
	}
	return proto
}

func DesiredLRPResourceProtoMap(values []*DesiredLRPResource) []*ProtoDesiredLRPResource {
	result := make([]*ProtoDesiredLRPResource, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRP directly
type DesiredLRP struct {
	ProcessGuid                   string
	Domain                        string
	RootFs                        string
	Instances                     int32
	EnvironmentVariables          []*EnvironmentVariable
	Setup                         *Action
	Action                        *Action
	StartTimeoutMs                int64
	DeprecatedStartTimeoutS       uint32
	Monitor                       *Action
	DiskMb                        int32
	MemoryMb                      int32
	CpuWeight                     uint32
	Privileged                    bool
	Ports                         []uint32
	Routes                        *Routes
	LogSource                     string
	LogGuid                       string
	MetricsGuid                   string
	Annotation                    string
	EgressRules                   []*SecurityGroupRule
	ModificationTag               *ModificationTag
	CachedDependencies            []*CachedDependency
	LegacyDownloadUser            string
	TrustedSystemCertificatesPath string
	VolumeMounts                  []*VolumeMount
	Network                       *Network
	ProtoPlacementTags            []string
	MaxPids                       int32
	CertificateProperties         *CertificateProperties
	ImageUsername                 string
	ImagePassword                 string
	CheckDefinition               *CheckDefinition
	ImageLayers                   []*ImageLayer
	MetricTags                    map[string]*ProtoMetricTagValue
	Sidecars                      []*Sidecar
	LogRateLimit                  *LogRateLimit
}

func (x *DesiredLRP) ToProto() *ProtoDesiredLRP {
	proto := &ProtoDesiredLRP{
		ProcessGuid:                   x.ProcessGuid,
		Domain:                        x.Domain,
		RootFs:                        x.RootFs,
		Instances:                     x.Instances,
		EnvironmentVariables:          EnvironmentVariableProtoMap(x.EnvironmentVariables),
		Setup:                         x.Setup.ToProto(),
		Action:                        x.Action.ToProto(),
		StartTimeoutMs:                x.StartTimeoutMs,
		DeprecatedStartTimeoutS:       x.DeprecatedStartTimeoutS,
		Monitor:                       x.Monitor.ToProto(),
		DiskMb:                        x.DiskMb,
		MemoryMb:                      x.MemoryMb,
		CpuWeight:                     x.CpuWeight,
		Privileged:                    x.Privileged,
		Ports:                         x.Ports,
		Routes:                        x.Routes.ToProto(),
		LogSource:                     x.LogSource,
		LogGuid:                       x.LogGuid,
		MetricsGuid:                   x.MetricsGuid,
		Annotation:                    x.Annotation,
		EgressRules:                   SecurityGroupRuleProtoMap(x.EgressRules),
		ModificationTag:               x.ModificationTag.ToProto(),
		CachedDependencies:            CachedDependencyProtoMap(x.CachedDependencies),
		LegacyDownloadUser:            x.LegacyDownloadUser,
		TrustedSystemCertificatesPath: x.TrustedSystemCertificatesPath,
		VolumeMounts:                  VolumeMountProtoMap(x.VolumeMounts),
		Network:                       x.Network.ToProto(),
		ProtoPlacementTags:            x.ProtoPlacementTags,
		MaxPids:                       x.MaxPids,
		CertificateProperties:         x.CertificateProperties.ToProto(),
		ImageUsername:                 x.ImageUsername,
		ImagePassword:                 x.ImagePassword,
		CheckDefinition:               x.CheckDefinition.ToProto(),
		ImageLayers:                   ImageLayerProtoMap(x.ImageLayers),
		MetricTags:                    x.MetricTags,
		Sidecars:                      SidecarProtoMap(x.Sidecars),
		LogRateLimit:                  x.LogRateLimit.ToProto(),
	}
	return proto
}

func DesiredLRPProtoMap(values []*DesiredLRP) []*ProtoDesiredLRP {
	result := make([]*ProtoDesiredLRP, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}
