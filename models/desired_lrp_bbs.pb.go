// Code generated by protoc-gen-go-bbs. DO NOT EDIT.
// versions:
// - protoc-gen-go-bbs v0.0.1
// - protoc            v5.29.3
// source: desired_lrp.proto

package models

// Prevent copylock errors when using ProtoDesiredLRPSchedulingInfo directly
type DesiredLRPSchedulingInfo struct {
	DesiredLrpKey      DesiredLRPKey      `json:"desired_lrp_key"`
	Annotation         string             `json:"annotation"`
	Instances          int32              `json:"instances"`
	DesiredLrpResource DesiredLRPResource `json:"desired_lrp_resource"`
	Routes             *Routes            `json:"routes,omitempty"`
	ModificationTag    ModificationTag    `json:"modification_tag"`
	VolumePlacement    *VolumePlacement   `json:"volume_placement,omitempty"`
	PlacementTags      []string           `json:"placement_tags,omitempty"`
}

func (this *DesiredLRPSchedulingInfo) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRPSchedulingInfo)
	if !ok {
		that2, ok := that.(DesiredLRPSchedulingInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.DesiredLrpKey.Equal(that1.DesiredLrpKey) {
		return false
	}
	if this.Annotation != that1.Annotation {
		return false
	}
	if this.Instances != that1.Instances {
		return false
	}
	if !this.DesiredLrpResource.Equal(that1.DesiredLrpResource) {
		return false
	}
	if this.Routes == nil {
		if that1.Routes != nil {
			return false
		}
	} else if !this.Routes.Equal(*that1.Routes) {
		return false
	}
	if !this.ModificationTag.Equal(that1.ModificationTag) {
		return false
	}
	if this.VolumePlacement == nil {
		if that1.VolumePlacement != nil {
			return false
		}
	} else if !this.VolumePlacement.Equal(*that1.VolumePlacement) {
		return false
	}
	if this.PlacementTags == nil {
		if that1.PlacementTags != nil {
			return false
		}
	} else if len(this.PlacementTags) != len(that1.PlacementTags) {
		return false
	}
	for i := range this.PlacementTags {
		if this.PlacementTags[i] != that1.PlacementTags[i] {
			return false
		}
	}
	return true
}
func (m *DesiredLRPSchedulingInfo) SetDesiredLrpKey(value DesiredLRPKey) {
	if m != nil {
		m.DesiredLrpKey = value
	}
}
func (m *DesiredLRPSchedulingInfo) GetAnnotation() string {
	if m != nil {
		return m.Annotation
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *DesiredLRPSchedulingInfo) SetAnnotation(value string) {
	if m != nil {
		m.Annotation = value
	}
}
func (m *DesiredLRPSchedulingInfo) GetInstances() int32 {
	if m != nil {
		return m.Instances
	}
	var defaultValue int32
	defaultValue = 0
	return defaultValue
}
func (m *DesiredLRPSchedulingInfo) SetInstances(value int32) {
	if m != nil {
		m.Instances = value
	}
}
func (m *DesiredLRPSchedulingInfo) SetDesiredLrpResource(value DesiredLRPResource) {
	if m != nil {
		m.DesiredLrpResource = value
	}
}
func (m *DesiredLRPSchedulingInfo) GetRoutes() *Routes {
	if m != nil {
		return m.Routes
	}
	return nil
}
func (m *DesiredLRPSchedulingInfo) SetRoutes(value *Routes) {
	if m != nil {
		m.Routes = value
	}
}
func (m *DesiredLRPSchedulingInfo) SetModificationTag(value ModificationTag) {
	if m != nil {
		m.ModificationTag = value
	}
}
func (m *DesiredLRPSchedulingInfo) GetVolumePlacement() *VolumePlacement {
	if m != nil {
		return m.VolumePlacement
	}
	return nil
}
func (m *DesiredLRPSchedulingInfo) SetVolumePlacement(value *VolumePlacement) {
	if m != nil {
		m.VolumePlacement = value
	}
}
func (m *DesiredLRPSchedulingInfo) GetPlacementTags() []string {
	if m != nil {
		return m.PlacementTags
	}
	return nil
}
func (m *DesiredLRPSchedulingInfo) SetPlacementTags(value []string) {
	if m != nil {
		m.PlacementTags = value
	}
}
func (x *DesiredLRPSchedulingInfo) ToProto() *ProtoDesiredLRPSchedulingInfo {
	if x == nil {
		return nil
	}

	proto := &ProtoDesiredLRPSchedulingInfo{
		DesiredLrpKey:      x.DesiredLrpKey.ToProto(),
		Annotation:         x.Annotation,
		Instances:          x.Instances,
		DesiredLrpResource: x.DesiredLrpResource.ToProto(),
		Routes:             x.Routes.ToProto(),
		ModificationTag:    x.ModificationTag.ToProto(),
		VolumePlacement:    x.VolumePlacement.ToProto(),
		PlacementTags:      x.PlacementTags,
	}
	return proto
}

func (x *ProtoDesiredLRPSchedulingInfo) FromProto() *DesiredLRPSchedulingInfo {
	if x == nil {
		return nil
	}

	copysafe := &DesiredLRPSchedulingInfo{
		DesiredLrpKey:      *x.DesiredLrpKey.FromProto(),
		Annotation:         x.Annotation,
		Instances:          x.Instances,
		DesiredLrpResource: *x.DesiredLrpResource.FromProto(),
		Routes:             x.Routes.FromProto(),
		ModificationTag:    *x.ModificationTag.FromProto(),
		VolumePlacement:    x.VolumePlacement.FromProto(),
		PlacementTags:      x.PlacementTags,
	}
	return copysafe
}

func DesiredLRPSchedulingInfoToProtoSlice(values []*DesiredLRPSchedulingInfo) []*ProtoDesiredLRPSchedulingInfo {
	if values == nil {
		return nil
	}
	result := make([]*ProtoDesiredLRPSchedulingInfo, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func DesiredLRPSchedulingInfoFromProtoSlice(values []*ProtoDesiredLRPSchedulingInfo) []*DesiredLRPSchedulingInfo {
	if values == nil {
		return nil
	}
	result := make([]*DesiredLRPSchedulingInfo, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPRunInfo directly
type DesiredLRPRunInfo struct {
	DesiredLrpKey        DesiredLRPKey          `json:"desired_lrp_key"`
	EnvironmentVariables []*EnvironmentVariable `json:"env"`
	Setup                *Action                `json:"setup,omitempty"`
	Action               *Action                `json:"action,omitempty"`
	Monitor              *Action                `json:"monitor,omitempty"`
	// Deprecated: marked deprecated in desired_lrp.proto
	DeprecatedStartTimeoutS uint32               `json:"start_timeout,omitempty"`
	Privileged              bool                 `json:"privileged"`
	CpuWeight               uint32               `json:"cpu_weight"`
	Ports                   []uint32             `json:"ports,omitempty"`
	EgressRules             []*SecurityGroupRule `json:"egress_rules,omitempty"`
	LogSource               string               `json:"log_source"`
	// Deprecated: marked deprecated in desired_lrp.proto
	MetricsGuid        string              `json:"metrics_guid"`
	CreatedAt          int64               `json:"created_at"`
	CachedDependencies []*CachedDependency `json:"cachedDependencies,omitempty"`
	// Deprecated: marked deprecated in desired_lrp.proto
	LegacyDownloadUser            string                 `json:"legacy_download_user,omitempty"`
	TrustedSystemCertificatesPath string                 `json:"trusted_system_certificates_path,omitempty"`
	VolumeMounts                  []*VolumeMount         `json:"volume_mounts,omitempty"`
	Network                       *Network               `json:"network,omitempty"`
	StartTimeoutMs                int64                  `json:"start_timeout_ms"`
	CertificateProperties         *CertificateProperties `json:"certificate_properties,omitempty"`
	ImageUsername                 string                 `json:"image_username,omitempty"`
	ImagePassword                 string                 `json:"image_password,omitempty"`
	CheckDefinition               *CheckDefinition       `json:"check_definition,omitempty"`
	ImageLayers                   []*ImageLayer          `json:"image_layers,omitempty"`
	// Deprecated: marked deprecated in desired_lrp.proto
	MetricTags   map[string]*MetricTagValue `json:"metric_tags,omitempty"`
	Sidecars     []*Sidecar                 `json:"sidecars,omitempty"`
	LogRateLimit *LogRateLimit              `json:"log_rate_limit,omitempty"`
}

func (this *DesiredLRPRunInfo) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRPRunInfo)
	if !ok {
		that2, ok := that.(DesiredLRPRunInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.DesiredLrpKey.Equal(that1.DesiredLrpKey) {
		return false
	}
	if this.EnvironmentVariables == nil {
		if that1.EnvironmentVariables != nil {
			return false
		}
	} else if len(this.EnvironmentVariables) != len(that1.EnvironmentVariables) {
		return false
	}
	for i := range this.EnvironmentVariables {
		if !this.EnvironmentVariables[i].Equal(that1.EnvironmentVariables[i]) {
			return false
		}
	}
	if this.Setup == nil {
		if that1.Setup != nil {
			return false
		}
	} else if !this.Setup.Equal(*that1.Setup) {
		return false
	}
	if this.Action == nil {
		if that1.Action != nil {
			return false
		}
	} else if !this.Action.Equal(*that1.Action) {
		return false
	}
	if this.Monitor == nil {
		if that1.Monitor != nil {
			return false
		}
	} else if !this.Monitor.Equal(*that1.Monitor) {
		return false
	}
	if this.DeprecatedStartTimeoutS != that1.DeprecatedStartTimeoutS {
		return false
	}
	if this.Privileged != that1.Privileged {
		return false
	}
	if this.CpuWeight != that1.CpuWeight {
		return false
	}
	if this.Ports == nil {
		if that1.Ports != nil {
			return false
		}
	} else if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if this.Ports[i] != that1.Ports[i] {
			return false
		}
	}
	if this.EgressRules == nil {
		if that1.EgressRules != nil {
			return false
		}
	} else if len(this.EgressRules) != len(that1.EgressRules) {
		return false
	}
	for i := range this.EgressRules {
		if !this.EgressRules[i].Equal(that1.EgressRules[i]) {
			return false
		}
	}
	if this.LogSource != that1.LogSource {
		return false
	}
	if this.MetricsGuid != that1.MetricsGuid {
		return false
	}
	if this.CreatedAt != that1.CreatedAt {
		return false
	}
	if this.CachedDependencies == nil {
		if that1.CachedDependencies != nil {
			return false
		}
	} else if len(this.CachedDependencies) != len(that1.CachedDependencies) {
		return false
	}
	for i := range this.CachedDependencies {
		if !this.CachedDependencies[i].Equal(that1.CachedDependencies[i]) {
			return false
		}
	}
	if this.LegacyDownloadUser != that1.LegacyDownloadUser {
		return false
	}
	if this.TrustedSystemCertificatesPath != that1.TrustedSystemCertificatesPath {
		return false
	}
	if this.VolumeMounts == nil {
		if that1.VolumeMounts != nil {
			return false
		}
	} else if len(this.VolumeMounts) != len(that1.VolumeMounts) {
		return false
	}
	for i := range this.VolumeMounts {
		if !this.VolumeMounts[i].Equal(that1.VolumeMounts[i]) {
			return false
		}
	}
	if this.Network == nil {
		if that1.Network != nil {
			return false
		}
	} else if !this.Network.Equal(*that1.Network) {
		return false
	}
	if this.StartTimeoutMs != that1.StartTimeoutMs {
		return false
	}
	if this.CertificateProperties == nil {
		if that1.CertificateProperties != nil {
			return false
		}
	} else if !this.CertificateProperties.Equal(*that1.CertificateProperties) {
		return false
	}
	if this.ImageUsername != that1.ImageUsername {
		return false
	}
	if this.ImagePassword != that1.ImagePassword {
		return false
	}
	if this.CheckDefinition == nil {
		if that1.CheckDefinition != nil {
			return false
		}
	} else if !this.CheckDefinition.Equal(*that1.CheckDefinition) {
		return false
	}
	if this.ImageLayers == nil {
		if that1.ImageLayers != nil {
			return false
		}
	} else if len(this.ImageLayers) != len(that1.ImageLayers) {
		return false
	}
	for i := range this.ImageLayers {
		if !this.ImageLayers[i].Equal(that1.ImageLayers[i]) {
			return false
		}
	}
	if this.MetricTags == nil {
		if that1.MetricTags != nil {
			return false
		}
	} else if len(this.MetricTags) != len(that1.MetricTags) {
		return false
	}
	for i := range this.MetricTags {
		if !this.MetricTags[i].Equal(that1.MetricTags[i]) {
			return false
		}
	}
	if this.Sidecars == nil {
		if that1.Sidecars != nil {
			return false
		}
	} else if len(this.Sidecars) != len(that1.Sidecars) {
		return false
	}
	for i := range this.Sidecars {
		if !this.Sidecars[i].Equal(that1.Sidecars[i]) {
			return false
		}
	}
	if this.LogRateLimit == nil {
		if that1.LogRateLimit != nil {
			return false
		}
	} else if !this.LogRateLimit.Equal(*that1.LogRateLimit) {
		return false
	}
	return true
}
func (m *DesiredLRPRunInfo) SetDesiredLrpKey(value DesiredLRPKey) {
	if m != nil {
		m.DesiredLrpKey = value
	}
}
func (m *DesiredLRPRunInfo) GetEnvironmentVariables() []*EnvironmentVariable {
	if m != nil {
		return m.EnvironmentVariables
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetEnvironmentVariables(value []*EnvironmentVariable) {
	if m != nil {
		m.EnvironmentVariables = value
	}
}
func (m *DesiredLRPRunInfo) GetSetup() *Action {
	if m != nil {
		return m.Setup
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetSetup(value *Action) {
	if m != nil {
		m.Setup = value
	}
}
func (m *DesiredLRPRunInfo) GetAction() *Action {
	if m != nil {
		return m.Action
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetAction(value *Action) {
	if m != nil {
		m.Action = value
	}
}
func (m *DesiredLRPRunInfo) GetMonitor() *Action {
	if m != nil {
		return m.Monitor
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetMonitor(value *Action) {
	if m != nil {
		m.Monitor = value
	}
}

// Deprecated: marked deprecated in desired_lrp.proto
func (m *DesiredLRPRunInfo) GetDeprecatedStartTimeoutS() uint32 {
	if m != nil {
		return m.DeprecatedStartTimeoutS
	}
	var defaultValue uint32
	defaultValue = 0
	return defaultValue
}

// Deprecated: marked deprecated in desired_lrp.proto
func (m *DesiredLRPRunInfo) SetDeprecatedStartTimeoutS(value uint32) {
	if m != nil {
		m.DeprecatedStartTimeoutS = value
	}
}
func (m *DesiredLRPRunInfo) GetPrivileged() bool {
	if m != nil {
		return m.Privileged
	}
	var defaultValue bool
	defaultValue = false
	return defaultValue
}
func (m *DesiredLRPRunInfo) SetPrivileged(value bool) {
	if m != nil {
		m.Privileged = value
	}
}
func (m *DesiredLRPRunInfo) GetCpuWeight() uint32 {
	if m != nil {
		return m.CpuWeight
	}
	var defaultValue uint32
	defaultValue = 0
	return defaultValue
}
func (m *DesiredLRPRunInfo) SetCpuWeight(value uint32) {
	if m != nil {
		m.CpuWeight = value
	}
}
func (m *DesiredLRPRunInfo) GetPorts() []uint32 {
	if m != nil {
		return m.Ports
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetPorts(value []uint32) {
	if m != nil {
		m.Ports = value
	}
}
func (m *DesiredLRPRunInfo) GetEgressRules() []*SecurityGroupRule {
	if m != nil {
		return m.EgressRules
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetEgressRules(value []*SecurityGroupRule) {
	if m != nil {
		m.EgressRules = value
	}
}
func (m *DesiredLRPRunInfo) GetLogSource() string {
	if m != nil {
		return m.LogSource
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *DesiredLRPRunInfo) SetLogSource(value string) {
	if m != nil {
		m.LogSource = value
	}
}

// Deprecated: marked deprecated in desired_lrp.proto
func (m *DesiredLRPRunInfo) GetMetricsGuid() string {
	if m != nil {
		return m.MetricsGuid
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}

// Deprecated: marked deprecated in desired_lrp.proto
func (m *DesiredLRPRunInfo) SetMetricsGuid(value string) {
	if m != nil {
		m.MetricsGuid = value
	}
}
func (m *DesiredLRPRunInfo) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	var defaultValue int64
	defaultValue = 0
	return defaultValue
}
func (m *DesiredLRPRunInfo) SetCreatedAt(value int64) {
	if m != nil {
		m.CreatedAt = value
	}
}
func (m *DesiredLRPRunInfo) GetCachedDependencies() []*CachedDependency {
	if m != nil {
		return m.CachedDependencies
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetCachedDependencies(value []*CachedDependency) {
	if m != nil {
		m.CachedDependencies = value
	}
}

// Deprecated: marked deprecated in desired_lrp.proto
func (m *DesiredLRPRunInfo) GetLegacyDownloadUser() string {
	if m != nil {
		return m.LegacyDownloadUser
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}

// Deprecated: marked deprecated in desired_lrp.proto
func (m *DesiredLRPRunInfo) SetLegacyDownloadUser(value string) {
	if m != nil {
		m.LegacyDownloadUser = value
	}
}
func (m *DesiredLRPRunInfo) GetTrustedSystemCertificatesPath() string {
	if m != nil {
		return m.TrustedSystemCertificatesPath
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *DesiredLRPRunInfo) SetTrustedSystemCertificatesPath(value string) {
	if m != nil {
		m.TrustedSystemCertificatesPath = value
	}
}
func (m *DesiredLRPRunInfo) GetVolumeMounts() []*VolumeMount {
	if m != nil {
		return m.VolumeMounts
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetVolumeMounts(value []*VolumeMount) {
	if m != nil {
		m.VolumeMounts = value
	}
}
func (m *DesiredLRPRunInfo) GetNetwork() *Network {
	if m != nil {
		return m.Network
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetNetwork(value *Network) {
	if m != nil {
		m.Network = value
	}
}
func (m *DesiredLRPRunInfo) GetStartTimeoutMs() int64 {
	if m != nil {
		return m.StartTimeoutMs
	}
	var defaultValue int64
	defaultValue = 0
	return defaultValue
}
func (m *DesiredLRPRunInfo) SetStartTimeoutMs(value int64) {
	if m != nil {
		m.StartTimeoutMs = value
	}
}
func (m *DesiredLRPRunInfo) CertificatePropertiesExists() bool {
	return m != nil && m.CertificateProperties != nil
}
func (m *DesiredLRPRunInfo) GetCertificateProperties() *CertificateProperties {
	if m != nil && m.CertificateProperties != nil {
		return m.CertificateProperties
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetCertificateProperties(value *CertificateProperties) {
	if m != nil {
		m.CertificateProperties = value
	}
}
func (m *DesiredLRPRunInfo) GetImageUsername() string {
	if m != nil {
		return m.ImageUsername
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *DesiredLRPRunInfo) SetImageUsername(value string) {
	if m != nil {
		m.ImageUsername = value
	}
}
func (m *DesiredLRPRunInfo) GetImagePassword() string {
	if m != nil {
		return m.ImagePassword
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *DesiredLRPRunInfo) SetImagePassword(value string) {
	if m != nil {
		m.ImagePassword = value
	}
}
func (m *DesiredLRPRunInfo) GetCheckDefinition() *CheckDefinition {
	if m != nil {
		return m.CheckDefinition
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetCheckDefinition(value *CheckDefinition) {
	if m != nil {
		m.CheckDefinition = value
	}
}
func (m *DesiredLRPRunInfo) GetImageLayers() []*ImageLayer {
	if m != nil {
		return m.ImageLayers
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetImageLayers(value []*ImageLayer) {
	if m != nil {
		m.ImageLayers = value
	}
}

// Deprecated: marked deprecated in desired_lrp.proto
func (m *DesiredLRPRunInfo) GetMetricTags() map[string]*MetricTagValue {
	if m != nil {
		return m.MetricTags
	}
	return nil
}

// Deprecated: marked deprecated in desired_lrp.proto
func (m *DesiredLRPRunInfo) SetMetricTags(value map[string]*MetricTagValue) {
	if m != nil {
		m.MetricTags = value
	}
}
func (m *DesiredLRPRunInfo) GetSidecars() []*Sidecar {
	if m != nil {
		return m.Sidecars
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetSidecars(value []*Sidecar) {
	if m != nil {
		m.Sidecars = value
	}
}
func (m *DesiredLRPRunInfo) GetLogRateLimit() *LogRateLimit {
	if m != nil {
		return m.LogRateLimit
	}
	return nil
}
func (m *DesiredLRPRunInfo) SetLogRateLimit(value *LogRateLimit) {
	if m != nil {
		m.LogRateLimit = value
	}
}
func (x *DesiredLRPRunInfo) ToProto() *ProtoDesiredLRPRunInfo {
	if x == nil {
		return nil
	}

	proto := &ProtoDesiredLRPRunInfo{
		DesiredLrpKey:                 x.DesiredLrpKey.ToProto(),
		EnvironmentVariables:          EnvironmentVariableToProtoSlice(x.EnvironmentVariables),
		Setup:                         x.Setup.ToProto(),
		Action:                        x.Action.ToProto(),
		Monitor:                       x.Monitor.ToProto(),
		DeprecatedStartTimeoutS:       x.DeprecatedStartTimeoutS,
		Privileged:                    x.Privileged,
		CpuWeight:                     x.CpuWeight,
		Ports:                         x.Ports,
		EgressRules:                   SecurityGroupRuleToProtoSlice(x.EgressRules),
		LogSource:                     x.LogSource,
		MetricsGuid:                   x.MetricsGuid,
		CreatedAt:                     x.CreatedAt,
		CachedDependencies:            CachedDependencyToProtoSlice(x.CachedDependencies),
		LegacyDownloadUser:            x.LegacyDownloadUser,
		TrustedSystemCertificatesPath: x.TrustedSystemCertificatesPath,
		VolumeMounts:                  VolumeMountToProtoSlice(x.VolumeMounts),
		Network:                       x.Network.ToProto(),
		StartTimeoutMs:                x.StartTimeoutMs,
		CertificateProperties:         x.CertificateProperties.ToProto(),
		ImageUsername:                 x.ImageUsername,
		ImagePassword:                 x.ImagePassword,
		CheckDefinition:               x.CheckDefinition.ToProto(),
		ImageLayers:                   ImageLayerToProtoSlice(x.ImageLayers),
		MetricTags:                    DesiredLRPRunInfoMetricTagsToProtoMap(x.MetricTags),
		Sidecars:                      SidecarToProtoSlice(x.Sidecars),
		LogRateLimit:                  x.LogRateLimit.ToProto(),
	}
	return proto
}

func (x *ProtoDesiredLRPRunInfo) FromProto() *DesiredLRPRunInfo {
	if x == nil {
		return nil
	}

	copysafe := &DesiredLRPRunInfo{
		DesiredLrpKey:                 *x.DesiredLrpKey.FromProto(),
		EnvironmentVariables:          EnvironmentVariableFromProtoSlice(x.EnvironmentVariables),
		Setup:                         x.Setup.FromProto(),
		Action:                        x.Action.FromProto(),
		Monitor:                       x.Monitor.FromProto(),
		DeprecatedStartTimeoutS:       x.DeprecatedStartTimeoutS,
		Privileged:                    x.Privileged,
		CpuWeight:                     x.CpuWeight,
		Ports:                         x.Ports,
		EgressRules:                   SecurityGroupRuleFromProtoSlice(x.EgressRules),
		LogSource:                     x.LogSource,
		MetricsGuid:                   x.MetricsGuid,
		CreatedAt:                     x.CreatedAt,
		CachedDependencies:            CachedDependencyFromProtoSlice(x.CachedDependencies),
		LegacyDownloadUser:            x.LegacyDownloadUser,
		TrustedSystemCertificatesPath: x.TrustedSystemCertificatesPath,
		VolumeMounts:                  VolumeMountFromProtoSlice(x.VolumeMounts),
		Network:                       x.Network.FromProto(),
		StartTimeoutMs:                x.StartTimeoutMs,
		CertificateProperties:         x.CertificateProperties.FromProto(),
		ImageUsername:                 x.ImageUsername,
		ImagePassword:                 x.ImagePassword,
		CheckDefinition:               x.CheckDefinition.FromProto(),
		ImageLayers:                   ImageLayerFromProtoSlice(x.ImageLayers),
		MetricTags:                    DesiredLRPRunInfoMetricTagsFromProtoMap(x.MetricTags),
		Sidecars:                      SidecarFromProtoSlice(x.Sidecars),
		LogRateLimit:                  x.LogRateLimit.FromProto(),
	}
	return copysafe
}

func DesiredLRPRunInfoToProtoSlice(values []*DesiredLRPRunInfo) []*ProtoDesiredLRPRunInfo {
	if values == nil {
		return nil
	}
	result := make([]*ProtoDesiredLRPRunInfo, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func DesiredLRPRunInfoMetricTagsToProtoMap(values map[string]*MetricTagValue) map[string]*ProtoMetricTagValue {
	if values == nil {
		return nil
	}
	result := make(map[string]*ProtoMetricTagValue, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func DesiredLRPRunInfoFromProtoSlice(values []*ProtoDesiredLRPRunInfo) []*DesiredLRPRunInfo {
	if values == nil {
		return nil
	}
	result := make([]*DesiredLRPRunInfo, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

func DesiredLRPRunInfoMetricTagsFromProtoMap(values map[string]*ProtoMetricTagValue) map[string]*MetricTagValue {
	if values == nil {
		return nil
	}
	result := make(map[string]*MetricTagValue, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPUpdate directly
type DesiredLRPUpdate struct {
	Instances  *int32                     `json:"instances,omitempty"`
	Routes     *Routes                    `json:"routes,omitempty"`
	Annotation *string                    `json:"annotation,omitempty"`
	MetricTags map[string]*MetricTagValue `json:"metric_tags,omitempty"`
}

func (this *DesiredLRPUpdate) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRPUpdate)
	if !ok {
		that2, ok := that.(DesiredLRPUpdate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Instances == nil {
		if that1.Instances != nil {
			return false
		}
	} else if *this.Instances != *that1.Instances {
		return false
	}
	if this.Routes == nil {
		if that1.Routes != nil {
			return false
		}
	} else if !this.Routes.Equal(*that1.Routes) {
		return false
	}
	if this.Annotation == nil {
		if that1.Annotation != nil {
			return false
		}
	} else if *this.Annotation != *that1.Annotation {
		return false
	}
	if this.MetricTags == nil {
		if that1.MetricTags != nil {
			return false
		}
	} else if len(this.MetricTags) != len(that1.MetricTags) {
		return false
	}
	for i := range this.MetricTags {
		if !this.MetricTags[i].Equal(that1.MetricTags[i]) {
			return false
		}
	}
	return true
}
func (m *DesiredLRPUpdate) InstancesExists() bool {
	return m != nil && m.Instances != nil
}
func (m *DesiredLRPUpdate) GetInstances() *int32 {
	if m != nil && m.Instances != nil {
		return m.Instances
	}
	var defaultValue int32
	defaultValue = 0
	return &defaultValue
}
func (m *DesiredLRPUpdate) SetInstances(value *int32) {
	if m != nil {
		m.Instances = value
	}
}
func (m *DesiredLRPUpdate) RoutesExists() bool {
	return m != nil && m.Routes != nil
}
func (m *DesiredLRPUpdate) GetRoutes() *Routes {
	if m != nil && m.Routes != nil {
		return m.Routes
	}
	return nil
}
func (m *DesiredLRPUpdate) SetRoutes(value *Routes) {
	if m != nil {
		m.Routes = value
	}
}
func (m *DesiredLRPUpdate) AnnotationExists() bool {
	return m != nil && m.Annotation != nil
}
func (m *DesiredLRPUpdate) GetAnnotation() *string {
	if m != nil && m.Annotation != nil {
		return m.Annotation
	}
	var defaultValue string
	defaultValue = ""
	return &defaultValue
}
func (m *DesiredLRPUpdate) SetAnnotation(value *string) {
	if m != nil {
		m.Annotation = value
	}
}
func (m *DesiredLRPUpdate) GetMetricTags() map[string]*MetricTagValue {
	if m != nil {
		return m.MetricTags
	}
	return nil
}
func (m *DesiredLRPUpdate) SetMetricTags(value map[string]*MetricTagValue) {
	if m != nil {
		m.MetricTags = value
	}
}
func (x *DesiredLRPUpdate) ToProto() *ProtoDesiredLRPUpdate {
	if x == nil {
		return nil
	}

	proto := &ProtoDesiredLRPUpdate{
		Instances:  x.Instances,
		Routes:     x.Routes.ToProto(),
		Annotation: x.Annotation,
		MetricTags: DesiredLRPUpdateMetricTagsToProtoMap(x.MetricTags),
	}
	return proto
}

func (x *ProtoDesiredLRPUpdate) FromProto() *DesiredLRPUpdate {
	if x == nil {
		return nil
	}

	copysafe := &DesiredLRPUpdate{
		Instances:  x.Instances,
		Routes:     x.Routes.FromProto(),
		Annotation: x.Annotation,
		MetricTags: DesiredLRPUpdateMetricTagsFromProtoMap(x.MetricTags),
	}
	return copysafe
}

func DesiredLRPUpdateToProtoSlice(values []*DesiredLRPUpdate) []*ProtoDesiredLRPUpdate {
	if values == nil {
		return nil
	}
	result := make([]*ProtoDesiredLRPUpdate, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func DesiredLRPUpdateMetricTagsToProtoMap(values map[string]*MetricTagValue) map[string]*ProtoMetricTagValue {
	if values == nil {
		return nil
	}
	result := make(map[string]*ProtoMetricTagValue, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func DesiredLRPUpdateFromProtoSlice(values []*ProtoDesiredLRPUpdate) []*DesiredLRPUpdate {
	if values == nil {
		return nil
	}
	result := make([]*DesiredLRPUpdate, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

func DesiredLRPUpdateMetricTagsFromProtoMap(values map[string]*ProtoMetricTagValue) map[string]*MetricTagValue {
	if values == nil {
		return nil
	}
	result := make(map[string]*MetricTagValue, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPKey directly
type DesiredLRPKey struct {
	ProcessGuid string `json:"process_guid"`
	Domain      string `json:"domain"`
	LogGuid     string `json:"log_guid"`
}

func (this *DesiredLRPKey) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRPKey)
	if !ok {
		that2, ok := that.(DesiredLRPKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.ProcessGuid != that1.ProcessGuid {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	if this.LogGuid != that1.LogGuid {
		return false
	}
	return true
}
func (m *DesiredLRPKey) GetProcessGuid() string {
	if m != nil {
		return m.ProcessGuid
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *DesiredLRPKey) SetProcessGuid(value string) {
	if m != nil {
		m.ProcessGuid = value
	}
}
func (m *DesiredLRPKey) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *DesiredLRPKey) SetDomain(value string) {
	if m != nil {
		m.Domain = value
	}
}
func (m *DesiredLRPKey) GetLogGuid() string {
	if m != nil {
		return m.LogGuid
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *DesiredLRPKey) SetLogGuid(value string) {
	if m != nil {
		m.LogGuid = value
	}
}
func (x *DesiredLRPKey) ToProto() *ProtoDesiredLRPKey {
	if x == nil {
		return nil
	}

	proto := &ProtoDesiredLRPKey{
		ProcessGuid: x.ProcessGuid,
		Domain:      x.Domain,
		LogGuid:     x.LogGuid,
	}
	return proto
}

func (x *ProtoDesiredLRPKey) FromProto() *DesiredLRPKey {
	if x == nil {
		return nil
	}

	copysafe := &DesiredLRPKey{
		ProcessGuid: x.ProcessGuid,
		Domain:      x.Domain,
		LogGuid:     x.LogGuid,
	}
	return copysafe
}

func DesiredLRPKeyToProtoSlice(values []*DesiredLRPKey) []*ProtoDesiredLRPKey {
	if values == nil {
		return nil
	}
	result := make([]*ProtoDesiredLRPKey, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func DesiredLRPKeyFromProtoSlice(values []*ProtoDesiredLRPKey) []*DesiredLRPKey {
	if values == nil {
		return nil
	}
	result := make([]*DesiredLRPKey, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPResource directly
type DesiredLRPResource struct {
	MemoryMb int32  `json:"memory_mb"`
	DiskMb   int32  `json:"disk_mb"`
	RootFs   string `json:"rootfs"`
	MaxPids  int32  `json:"max_pids"`
}

func (this *DesiredLRPResource) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRPResource)
	if !ok {
		that2, ok := that.(DesiredLRPResource)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.MemoryMb != that1.MemoryMb {
		return false
	}
	if this.DiskMb != that1.DiskMb {
		return false
	}
	if this.RootFs != that1.RootFs {
		return false
	}
	if this.MaxPids != that1.MaxPids {
		return false
	}
	return true
}
func (m *DesiredLRPResource) GetMemoryMb() int32 {
	if m != nil {
		return m.MemoryMb
	}
	var defaultValue int32
	defaultValue = 0
	return defaultValue
}
func (m *DesiredLRPResource) SetMemoryMb(value int32) {
	if m != nil {
		m.MemoryMb = value
	}
}
func (m *DesiredLRPResource) GetDiskMb() int32 {
	if m != nil {
		return m.DiskMb
	}
	var defaultValue int32
	defaultValue = 0
	return defaultValue
}
func (m *DesiredLRPResource) SetDiskMb(value int32) {
	if m != nil {
		m.DiskMb = value
	}
}
func (m *DesiredLRPResource) GetRootFs() string {
	if m != nil {
		return m.RootFs
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *DesiredLRPResource) SetRootFs(value string) {
	if m != nil {
		m.RootFs = value
	}
}
func (m *DesiredLRPResource) GetMaxPids() int32 {
	if m != nil {
		return m.MaxPids
	}
	var defaultValue int32
	defaultValue = 0
	return defaultValue
}
func (m *DesiredLRPResource) SetMaxPids(value int32) {
	if m != nil {
		m.MaxPids = value
	}
}
func (x *DesiredLRPResource) ToProto() *ProtoDesiredLRPResource {
	if x == nil {
		return nil
	}

	proto := &ProtoDesiredLRPResource{
		MemoryMb: x.MemoryMb,
		DiskMb:   x.DiskMb,
		RootFs:   x.RootFs,
		MaxPids:  x.MaxPids,
	}
	return proto
}

func (x *ProtoDesiredLRPResource) FromProto() *DesiredLRPResource {
	if x == nil {
		return nil
	}

	copysafe := &DesiredLRPResource{
		MemoryMb: x.MemoryMb,
		DiskMb:   x.DiskMb,
		RootFs:   x.RootFs,
		MaxPids:  x.MaxPids,
	}
	return copysafe
}

func DesiredLRPResourceToProtoSlice(values []*DesiredLRPResource) []*ProtoDesiredLRPResource {
	if values == nil {
		return nil
	}
	result := make([]*ProtoDesiredLRPResource, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func DesiredLRPResourceFromProtoSlice(values []*ProtoDesiredLRPResource) []*DesiredLRPResource {
	if values == nil {
		return nil
	}
	result := make([]*DesiredLRPResource, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRP directly
type DesiredLRP struct {
	ProcessGuid          string                 `json:"process_guid"`
	Domain               string                 `json:"domain"`
	RootFs               string                 `json:"rootfs"`
	Instances            int32                  `json:"instances"`
	EnvironmentVariables []*EnvironmentVariable `json:"env"`
	Setup                *Action                `json:"setup,omitempty"`
	Action               *Action                `json:"action,omitempty"`
	StartTimeoutMs       int64                  `json:"start_timeout_ms"`
	// Deprecated: marked deprecated in desired_lrp.proto
	DeprecatedStartTimeoutS uint32   `json:"deprecated_timeout_ns,omitempty"`
	Monitor                 *Action  `json:"monitor,omitempty"`
	DiskMb                  int32    `json:"disk_mb"`
	MemoryMb                int32    `json:"memory_mb"`
	CpuWeight               uint32   `json:"cpu_weight"`
	Privileged              bool     `json:"privileged"`
	Ports                   []uint32 `json:"ports,omitempty"`
	Routes                  *Routes  `json:"routes,omitempty"`
	LogSource               string   `json:"log_source"`
	LogGuid                 string   `json:"log_guid"`
	// Deprecated: marked deprecated in desired_lrp.proto
	MetricsGuid        string               `json:"metrics_guid"`
	Annotation         string               `json:"annotation"`
	EgressRules        []*SecurityGroupRule `json:"egress_rules,omitempty"`
	ModificationTag    *ModificationTag     `json:"modification_tag,omitempty"`
	CachedDependencies []*CachedDependency  `json:"cached_dependencies,omitempty"`
	// Deprecated: marked deprecated in desired_lrp.proto
	LegacyDownloadUser            string                     `json:"legacy_download_user,omitempty"`
	TrustedSystemCertificatesPath string                     `json:"trusted_system_certificates_path,omitempty"`
	VolumeMounts                  []*VolumeMount             `json:"volume_mounts,omitempty"`
	Network                       *Network                   `json:"network,omitempty"`
	PlacementTags                 []string                   `json:"placement_tags,omitempty"`
	MaxPids                       int32                      `json:"max_pids"`
	CertificateProperties         *CertificateProperties     `json:"certificate_properties,omitempty"`
	ImageUsername                 string                     `json:"image_username,omitempty"`
	ImagePassword                 string                     `json:"image_password,omitempty"`
	CheckDefinition               *CheckDefinition           `json:"check_definition,omitempty"`
	ImageLayers                   []*ImageLayer              `json:"image_layers,omitempty"`
	MetricTags                    map[string]*MetricTagValue `json:"metric_tags,omitempty"`
	Sidecars                      []*Sidecar                 `json:"sidecars,omitempty"`
	LogRateLimit                  *LogRateLimit              `json:"log_rate_limit,omitempty"`
}

func (this *DesiredLRP) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRP)
	if !ok {
		that2, ok := that.(DesiredLRP)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.ProcessGuid != that1.ProcessGuid {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	if this.RootFs != that1.RootFs {
		return false
	}
	if this.Instances != that1.Instances {
		return false
	}
	if this.EnvironmentVariables == nil {
		if that1.EnvironmentVariables != nil {
			return false
		}
	} else if len(this.EnvironmentVariables) != len(that1.EnvironmentVariables) {
		return false
	}
	for i := range this.EnvironmentVariables {
		if !this.EnvironmentVariables[i].Equal(that1.EnvironmentVariables[i]) {
			return false
		}
	}
	if this.Setup == nil {
		if that1.Setup != nil {
			return false
		}
	} else if !this.Setup.Equal(*that1.Setup) {
		return false
	}
	if this.Action == nil {
		if that1.Action != nil {
			return false
		}
	} else if !this.Action.Equal(*that1.Action) {
		return false
	}
	if this.StartTimeoutMs != that1.StartTimeoutMs {
		return false
	}
	if this.DeprecatedStartTimeoutS != that1.DeprecatedStartTimeoutS {
		return false
	}
	if this.Monitor == nil {
		if that1.Monitor != nil {
			return false
		}
	} else if !this.Monitor.Equal(*that1.Monitor) {
		return false
	}
	if this.DiskMb != that1.DiskMb {
		return false
	}
	if this.MemoryMb != that1.MemoryMb {
		return false
	}
	if this.CpuWeight != that1.CpuWeight {
		return false
	}
	if this.Privileged != that1.Privileged {
		return false
	}
	if this.Ports == nil {
		if that1.Ports != nil {
			return false
		}
	} else if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if this.Ports[i] != that1.Ports[i] {
			return false
		}
	}
	if this.Routes == nil {
		if that1.Routes != nil {
			return false
		}
	} else if !this.Routes.Equal(*that1.Routes) {
		return false
	}
	if this.LogSource != that1.LogSource {
		return false
	}
	if this.LogGuid != that1.LogGuid {
		return false
	}
	if this.MetricsGuid != that1.MetricsGuid {
		return false
	}
	if this.Annotation != that1.Annotation {
		return false
	}
	if this.EgressRules == nil {
		if that1.EgressRules != nil {
			return false
		}
	} else if len(this.EgressRules) != len(that1.EgressRules) {
		return false
	}
	for i := range this.EgressRules {
		if !this.EgressRules[i].Equal(that1.EgressRules[i]) {
			return false
		}
	}
	if this.ModificationTag == nil {
		if that1.ModificationTag != nil {
			return false
		}
	} else if !this.ModificationTag.Equal(*that1.ModificationTag) {
		return false
	}
	if this.CachedDependencies == nil {
		if that1.CachedDependencies != nil {
			return false
		}
	} else if len(this.CachedDependencies) != len(that1.CachedDependencies) {
		return false
	}
	for i := range this.CachedDependencies {
		if !this.CachedDependencies[i].Equal(that1.CachedDependencies[i]) {
			return false
		}
	}
	if this.LegacyDownloadUser != that1.LegacyDownloadUser {
		return false
	}
	if this.TrustedSystemCertificatesPath != that1.TrustedSystemCertificatesPath {
		return false
	}
	if this.VolumeMounts == nil {
		if that1.VolumeMounts != nil {
			return false
		}
	} else if len(this.VolumeMounts) != len(that1.VolumeMounts) {
		return false
	}
	for i := range this.VolumeMounts {
		if !this.VolumeMounts[i].Equal(that1.VolumeMounts[i]) {
			return false
		}
	}
	if this.Network == nil {
		if that1.Network != nil {
			return false
		}
	} else if !this.Network.Equal(*that1.Network) {
		return false
	}
	if this.PlacementTags == nil {
		if that1.PlacementTags != nil {
			return false
		}
	} else if len(this.PlacementTags) != len(that1.PlacementTags) {
		return false
	}
	for i := range this.PlacementTags {
		if this.PlacementTags[i] != that1.PlacementTags[i] {
			return false
		}
	}
	if this.MaxPids != that1.MaxPids {
		return false
	}
	if this.CertificateProperties == nil {
		if that1.CertificateProperties != nil {
			return false
		}
	} else if !this.CertificateProperties.Equal(*that1.CertificateProperties) {
		return false
	}
	if this.ImageUsername != that1.ImageUsername {
		return false
	}
	if this.ImagePassword != that1.ImagePassword {
		return false
	}
	if this.CheckDefinition == nil {
		if that1.CheckDefinition != nil {
			return false
		}
	} else if !this.CheckDefinition.Equal(*that1.CheckDefinition) {
		return false
	}
	if this.ImageLayers == nil {
		if that1.ImageLayers != nil {
			return false
		}
	} else if len(this.ImageLayers) != len(that1.ImageLayers) {
		return false
	}
	for i := range this.ImageLayers {
		if !this.ImageLayers[i].Equal(that1.ImageLayers[i]) {
			return false
		}
	}
	if this.MetricTags == nil {
		if that1.MetricTags != nil {
			return false
		}
	} else if len(this.MetricTags) != len(that1.MetricTags) {
		return false
	}
	for i := range this.MetricTags {
		if !this.MetricTags[i].Equal(that1.MetricTags[i]) {
			return false
		}
	}
	if this.Sidecars == nil {
		if that1.Sidecars != nil {
			return false
		}
	} else if len(this.Sidecars) != len(that1.Sidecars) {
		return false
	}
	for i := range this.Sidecars {
		if !this.Sidecars[i].Equal(that1.Sidecars[i]) {
			return false
		}
	}
	if this.LogRateLimit == nil {
		if that1.LogRateLimit != nil {
			return false
		}
	} else if !this.LogRateLimit.Equal(*that1.LogRateLimit) {
		return false
	}
	return true
}
func (m *DesiredLRP) GetProcessGuid() string {
	if m != nil {
		return m.ProcessGuid
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *DesiredLRP) SetProcessGuid(value string) {
	if m != nil {
		m.ProcessGuid = value
	}
}
func (m *DesiredLRP) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *DesiredLRP) SetDomain(value string) {
	if m != nil {
		m.Domain = value
	}
}
func (m *DesiredLRP) GetRootFs() string {
	if m != nil {
		return m.RootFs
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *DesiredLRP) SetRootFs(value string) {
	if m != nil {
		m.RootFs = value
	}
}
func (m *DesiredLRP) GetInstances() int32 {
	if m != nil {
		return m.Instances
	}
	var defaultValue int32
	defaultValue = 0
	return defaultValue
}
func (m *DesiredLRP) SetInstances(value int32) {
	if m != nil {
		m.Instances = value
	}
}
func (m *DesiredLRP) GetEnvironmentVariables() []*EnvironmentVariable {
	if m != nil {
		return m.EnvironmentVariables
	}
	return nil
}
func (m *DesiredLRP) SetEnvironmentVariables(value []*EnvironmentVariable) {
	if m != nil {
		m.EnvironmentVariables = value
	}
}
func (m *DesiredLRP) GetSetup() *Action {
	if m != nil {
		return m.Setup
	}
	return nil
}
func (m *DesiredLRP) SetSetup(value *Action) {
	if m != nil {
		m.Setup = value
	}
}
func (m *DesiredLRP) GetAction() *Action {
	if m != nil {
		return m.Action
	}
	return nil
}
func (m *DesiredLRP) SetAction(value *Action) {
	if m != nil {
		m.Action = value
	}
}
func (m *DesiredLRP) GetStartTimeoutMs() int64 {
	if m != nil {
		return m.StartTimeoutMs
	}
	var defaultValue int64
	defaultValue = 0
	return defaultValue
}
func (m *DesiredLRP) SetStartTimeoutMs(value int64) {
	if m != nil {
		m.StartTimeoutMs = value
	}
}

// Deprecated: marked deprecated in desired_lrp.proto
func (m *DesiredLRP) GetDeprecatedStartTimeoutS() uint32 {
	if m != nil {
		return m.DeprecatedStartTimeoutS
	}
	var defaultValue uint32
	defaultValue = 0
	return defaultValue
}

// Deprecated: marked deprecated in desired_lrp.proto
func (m *DesiredLRP) SetDeprecatedStartTimeoutS(value uint32) {
	if m != nil {
		m.DeprecatedStartTimeoutS = value
	}
}
func (m *DesiredLRP) GetMonitor() *Action {
	if m != nil {
		return m.Monitor
	}
	return nil
}
func (m *DesiredLRP) SetMonitor(value *Action) {
	if m != nil {
		m.Monitor = value
	}
}
func (m *DesiredLRP) GetDiskMb() int32 {
	if m != nil {
		return m.DiskMb
	}
	var defaultValue int32
	defaultValue = 0
	return defaultValue
}
func (m *DesiredLRP) SetDiskMb(value int32) {
	if m != nil {
		m.DiskMb = value
	}
}
func (m *DesiredLRP) GetMemoryMb() int32 {
	if m != nil {
		return m.MemoryMb
	}
	var defaultValue int32
	defaultValue = 0
	return defaultValue
}
func (m *DesiredLRP) SetMemoryMb(value int32) {
	if m != nil {
		m.MemoryMb = value
	}
}
func (m *DesiredLRP) GetCpuWeight() uint32 {
	if m != nil {
		return m.CpuWeight
	}
	var defaultValue uint32
	defaultValue = 0
	return defaultValue
}
func (m *DesiredLRP) SetCpuWeight(value uint32) {
	if m != nil {
		m.CpuWeight = value
	}
}
func (m *DesiredLRP) GetPrivileged() bool {
	if m != nil {
		return m.Privileged
	}
	var defaultValue bool
	defaultValue = false
	return defaultValue
}
func (m *DesiredLRP) SetPrivileged(value bool) {
	if m != nil {
		m.Privileged = value
	}
}
func (m *DesiredLRP) GetPorts() []uint32 {
	if m != nil {
		return m.Ports
	}
	return nil
}
func (m *DesiredLRP) SetPorts(value []uint32) {
	if m != nil {
		m.Ports = value
	}
}
func (m *DesiredLRP) RoutesExists() bool {
	return m != nil && m.Routes != nil
}
func (m *DesiredLRP) GetRoutes() *Routes {
	if m != nil && m.Routes != nil {
		return m.Routes
	}
	return nil
}
func (m *DesiredLRP) SetRoutes(value *Routes) {
	if m != nil {
		m.Routes = value
	}
}
func (m *DesiredLRP) GetLogSource() string {
	if m != nil {
		return m.LogSource
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *DesiredLRP) SetLogSource(value string) {
	if m != nil {
		m.LogSource = value
	}
}
func (m *DesiredLRP) GetLogGuid() string {
	if m != nil {
		return m.LogGuid
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *DesiredLRP) SetLogGuid(value string) {
	if m != nil {
		m.LogGuid = value
	}
}

// Deprecated: marked deprecated in desired_lrp.proto
func (m *DesiredLRP) GetMetricsGuid() string {
	if m != nil {
		return m.MetricsGuid
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}

// Deprecated: marked deprecated in desired_lrp.proto
func (m *DesiredLRP) SetMetricsGuid(value string) {
	if m != nil {
		m.MetricsGuid = value
	}
}
func (m *DesiredLRP) GetAnnotation() string {
	if m != nil {
		return m.Annotation
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *DesiredLRP) SetAnnotation(value string) {
	if m != nil {
		m.Annotation = value
	}
}
func (m *DesiredLRP) GetEgressRules() []*SecurityGroupRule {
	if m != nil {
		return m.EgressRules
	}
	return nil
}
func (m *DesiredLRP) SetEgressRules(value []*SecurityGroupRule) {
	if m != nil {
		m.EgressRules = value
	}
}
func (m *DesiredLRP) GetModificationTag() *ModificationTag {
	if m != nil {
		return m.ModificationTag
	}
	return nil
}
func (m *DesiredLRP) SetModificationTag(value *ModificationTag) {
	if m != nil {
		m.ModificationTag = value
	}
}
func (m *DesiredLRP) GetCachedDependencies() []*CachedDependency {
	if m != nil {
		return m.CachedDependencies
	}
	return nil
}
func (m *DesiredLRP) SetCachedDependencies(value []*CachedDependency) {
	if m != nil {
		m.CachedDependencies = value
	}
}

// Deprecated: marked deprecated in desired_lrp.proto
func (m *DesiredLRP) GetLegacyDownloadUser() string {
	if m != nil {
		return m.LegacyDownloadUser
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}

// Deprecated: marked deprecated in desired_lrp.proto
func (m *DesiredLRP) SetLegacyDownloadUser(value string) {
	if m != nil {
		m.LegacyDownloadUser = value
	}
}
func (m *DesiredLRP) GetTrustedSystemCertificatesPath() string {
	if m != nil {
		return m.TrustedSystemCertificatesPath
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *DesiredLRP) SetTrustedSystemCertificatesPath(value string) {
	if m != nil {
		m.TrustedSystemCertificatesPath = value
	}
}
func (m *DesiredLRP) GetVolumeMounts() []*VolumeMount {
	if m != nil {
		return m.VolumeMounts
	}
	return nil
}
func (m *DesiredLRP) SetVolumeMounts(value []*VolumeMount) {
	if m != nil {
		m.VolumeMounts = value
	}
}
func (m *DesiredLRP) GetNetwork() *Network {
	if m != nil {
		return m.Network
	}
	return nil
}
func (m *DesiredLRP) SetNetwork(value *Network) {
	if m != nil {
		m.Network = value
	}
}
func (m *DesiredLRP) GetPlacementTags() []string {
	if m != nil {
		return m.PlacementTags
	}
	return nil
}
func (m *DesiredLRP) SetPlacementTags(value []string) {
	if m != nil {
		m.PlacementTags = value
	}
}
func (m *DesiredLRP) GetMaxPids() int32 {
	if m != nil {
		return m.MaxPids
	}
	var defaultValue int32
	defaultValue = 0
	return defaultValue
}
func (m *DesiredLRP) SetMaxPids(value int32) {
	if m != nil {
		m.MaxPids = value
	}
}
func (m *DesiredLRP) CertificatePropertiesExists() bool {
	return m != nil && m.CertificateProperties != nil
}
func (m *DesiredLRP) GetCertificateProperties() *CertificateProperties {
	if m != nil && m.CertificateProperties != nil {
		return m.CertificateProperties
	}
	return nil
}
func (m *DesiredLRP) SetCertificateProperties(value *CertificateProperties) {
	if m != nil {
		m.CertificateProperties = value
	}
}
func (m *DesiredLRP) GetImageUsername() string {
	if m != nil {
		return m.ImageUsername
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *DesiredLRP) SetImageUsername(value string) {
	if m != nil {
		m.ImageUsername = value
	}
}
func (m *DesiredLRP) GetImagePassword() string {
	if m != nil {
		return m.ImagePassword
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *DesiredLRP) SetImagePassword(value string) {
	if m != nil {
		m.ImagePassword = value
	}
}
func (m *DesiredLRP) GetCheckDefinition() *CheckDefinition {
	if m != nil {
		return m.CheckDefinition
	}
	return nil
}
func (m *DesiredLRP) SetCheckDefinition(value *CheckDefinition) {
	if m != nil {
		m.CheckDefinition = value
	}
}
func (m *DesiredLRP) GetImageLayers() []*ImageLayer {
	if m != nil {
		return m.ImageLayers
	}
	return nil
}
func (m *DesiredLRP) SetImageLayers(value []*ImageLayer) {
	if m != nil {
		m.ImageLayers = value
	}
}
func (m *DesiredLRP) GetMetricTags() map[string]*MetricTagValue {
	if m != nil {
		return m.MetricTags
	}
	return nil
}
func (m *DesiredLRP) SetMetricTags(value map[string]*MetricTagValue) {
	if m != nil {
		m.MetricTags = value
	}
}
func (m *DesiredLRP) GetSidecars() []*Sidecar {
	if m != nil {
		return m.Sidecars
	}
	return nil
}
func (m *DesiredLRP) SetSidecars(value []*Sidecar) {
	if m != nil {
		m.Sidecars = value
	}
}
func (m *DesiredLRP) GetLogRateLimit() *LogRateLimit {
	if m != nil {
		return m.LogRateLimit
	}
	return nil
}
func (m *DesiredLRP) SetLogRateLimit(value *LogRateLimit) {
	if m != nil {
		m.LogRateLimit = value
	}
}
func (x *DesiredLRP) ToProto() *ProtoDesiredLRP {
	if x == nil {
		return nil
	}

	proto := &ProtoDesiredLRP{
		ProcessGuid:                   x.ProcessGuid,
		Domain:                        x.Domain,
		RootFs:                        x.RootFs,
		Instances:                     x.Instances,
		EnvironmentVariables:          EnvironmentVariableToProtoSlice(x.EnvironmentVariables),
		Setup:                         x.Setup.ToProto(),
		Action:                        x.Action.ToProto(),
		StartTimeoutMs:                x.StartTimeoutMs,
		DeprecatedStartTimeoutS:       x.DeprecatedStartTimeoutS,
		Monitor:                       x.Monitor.ToProto(),
		DiskMb:                        x.DiskMb,
		MemoryMb:                      x.MemoryMb,
		CpuWeight:                     x.CpuWeight,
		Privileged:                    x.Privileged,
		Ports:                         x.Ports,
		Routes:                        x.Routes.ToProto(),
		LogSource:                     x.LogSource,
		LogGuid:                       x.LogGuid,
		MetricsGuid:                   x.MetricsGuid,
		Annotation:                    x.Annotation,
		EgressRules:                   SecurityGroupRuleToProtoSlice(x.EgressRules),
		ModificationTag:               x.ModificationTag.ToProto(),
		CachedDependencies:            CachedDependencyToProtoSlice(x.CachedDependencies),
		LegacyDownloadUser:            x.LegacyDownloadUser,
		TrustedSystemCertificatesPath: x.TrustedSystemCertificatesPath,
		VolumeMounts:                  VolumeMountToProtoSlice(x.VolumeMounts),
		Network:                       x.Network.ToProto(),
		PlacementTags:                 x.PlacementTags,
		MaxPids:                       x.MaxPids,
		CertificateProperties:         x.CertificateProperties.ToProto(),
		ImageUsername:                 x.ImageUsername,
		ImagePassword:                 x.ImagePassword,
		CheckDefinition:               x.CheckDefinition.ToProto(),
		ImageLayers:                   ImageLayerToProtoSlice(x.ImageLayers),
		MetricTags:                    DesiredLRPMetricTagsToProtoMap(x.MetricTags),
		Sidecars:                      SidecarToProtoSlice(x.Sidecars),
		LogRateLimit:                  x.LogRateLimit.ToProto(),
	}
	return proto
}

func (x *ProtoDesiredLRP) FromProto() *DesiredLRP {
	if x == nil {
		return nil
	}

	copysafe := &DesiredLRP{
		ProcessGuid:                   x.ProcessGuid,
		Domain:                        x.Domain,
		RootFs:                        x.RootFs,
		Instances:                     x.Instances,
		EnvironmentVariables:          EnvironmentVariableFromProtoSlice(x.EnvironmentVariables),
		Setup:                         x.Setup.FromProto(),
		Action:                        x.Action.FromProto(),
		StartTimeoutMs:                x.StartTimeoutMs,
		DeprecatedStartTimeoutS:       x.DeprecatedStartTimeoutS,
		Monitor:                       x.Monitor.FromProto(),
		DiskMb:                        x.DiskMb,
		MemoryMb:                      x.MemoryMb,
		CpuWeight:                     x.CpuWeight,
		Privileged:                    x.Privileged,
		Ports:                         x.Ports,
		Routes:                        x.Routes.FromProto(),
		LogSource:                     x.LogSource,
		LogGuid:                       x.LogGuid,
		MetricsGuid:                   x.MetricsGuid,
		Annotation:                    x.Annotation,
		EgressRules:                   SecurityGroupRuleFromProtoSlice(x.EgressRules),
		ModificationTag:               x.ModificationTag.FromProto(),
		CachedDependencies:            CachedDependencyFromProtoSlice(x.CachedDependencies),
		LegacyDownloadUser:            x.LegacyDownloadUser,
		TrustedSystemCertificatesPath: x.TrustedSystemCertificatesPath,
		VolumeMounts:                  VolumeMountFromProtoSlice(x.VolumeMounts),
		Network:                       x.Network.FromProto(),
		PlacementTags:                 x.PlacementTags,
		MaxPids:                       x.MaxPids,
		CertificateProperties:         x.CertificateProperties.FromProto(),
		ImageUsername:                 x.ImageUsername,
		ImagePassword:                 x.ImagePassword,
		CheckDefinition:               x.CheckDefinition.FromProto(),
		ImageLayers:                   ImageLayerFromProtoSlice(x.ImageLayers),
		MetricTags:                    DesiredLRPMetricTagsFromProtoMap(x.MetricTags),
		Sidecars:                      SidecarFromProtoSlice(x.Sidecars),
		LogRateLimit:                  x.LogRateLimit.FromProto(),
	}
	return copysafe
}

func DesiredLRPToProtoSlice(values []*DesiredLRP) []*ProtoDesiredLRP {
	if values == nil {
		return nil
	}
	result := make([]*ProtoDesiredLRP, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func DesiredLRPMetricTagsToProtoMap(values map[string]*MetricTagValue) map[string]*ProtoMetricTagValue {
	if values == nil {
		return nil
	}
	result := make(map[string]*ProtoMetricTagValue, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func DesiredLRPFromProtoSlice(values []*ProtoDesiredLRP) []*DesiredLRP {
	if values == nil {
		return nil
	}
	result := make([]*DesiredLRP, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

func DesiredLRPMetricTagsFromProtoMap(values map[string]*ProtoMetricTagValue) map[string]*MetricTagValue {
	if values == nil {
		return nil
	}
	result := make(map[string]*MetricTagValue, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}
