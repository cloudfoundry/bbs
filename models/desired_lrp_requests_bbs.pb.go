// Code generated by protoc-gen-go-bbs. DO NOT EDIT.
// versions:
// - protoc-gen-go-bbs v0.0.1
// - protoc            v5.27.0--rc1
// source: desired_lrp_requests.proto

package models

// Prevent copylock errors when using ProtoDesiredLRPLifecycleResponse directly
type DesiredLRPLifecycleResponse struct {
	Error *Error
}

func (m *DesiredLRPLifecycleResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *DesiredLRPLifecycleResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (x *DesiredLRPLifecycleResponse) ToProto() *ProtoDesiredLRPLifecycleResponse {
	proto := &ProtoDesiredLRPLifecycleResponse{
		Error: x.Error.ToProto(),
	}
	return proto
}

func DesiredLRPLifecycleResponseProtoMap(values []*DesiredLRPLifecycleResponse) []*ProtoDesiredLRPLifecycleResponse {
	result := make([]*ProtoDesiredLRPLifecycleResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPsResponse directly
type DesiredLRPsResponse struct {
	Error       *Error
	DesiredLrps []*DesiredLRP
}

func (m *DesiredLRPsResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *DesiredLRPsResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (m *DesiredLRPsResponse) GetDesiredLrps() []*DesiredLRP {
	if m != nil {
		return m.DesiredLrps
	}
	return nil
}
func (m *DesiredLRPsResponse) SetDesiredLrps(value []*DesiredLRP) {
	if m != nil {
		m.DesiredLrps = value
	}
}
func (x *DesiredLRPsResponse) ToProto() *ProtoDesiredLRPsResponse {
	proto := &ProtoDesiredLRPsResponse{
		Error:       x.Error.ToProto(),
		DesiredLrps: DesiredLRPProtoMap(x.DesiredLrps),
	}
	return proto
}

func DesiredLRPsResponseProtoMap(values []*DesiredLRPsResponse) []*ProtoDesiredLRPsResponse {
	result := make([]*ProtoDesiredLRPsResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPsRequest directly
type DesiredLRPsRequest struct {
	Domain       string
	ProcessGuids []string
}

func (m *DesiredLRPsRequest) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}
func (m *DesiredLRPsRequest) SetDomain(value string) {
	if m != nil {
		m.Domain = value
	}
}
func (m *DesiredLRPsRequest) GetProcessGuids() []string {
	if m != nil {
		return m.ProcessGuids
	}
	return nil
}
func (m *DesiredLRPsRequest) SetProcessGuids(value []string) {
	if m != nil {
		m.ProcessGuids = value
	}
}
func (x *DesiredLRPsRequest) ToProto() *ProtoDesiredLRPsRequest {
	proto := &ProtoDesiredLRPsRequest{
		Domain:       x.Domain,
		ProcessGuids: x.ProcessGuids,
	}
	return proto
}

func DesiredLRPsRequestProtoMap(values []*DesiredLRPsRequest) []*ProtoDesiredLRPsRequest {
	result := make([]*ProtoDesiredLRPsRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPResponse directly
type DesiredLRPResponse struct {
	Error      *Error
	DesiredLrp *DesiredLRP
}

func (m *DesiredLRPResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *DesiredLRPResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (m *DesiredLRPResponse) GetDesiredLrp() *DesiredLRP {
	if m != nil {
		return m.DesiredLrp
	}
	return nil
}
func (m *DesiredLRPResponse) SetDesiredLrp(value *DesiredLRP) {
	if m != nil {
		m.DesiredLrp = value
	}
}
func (x *DesiredLRPResponse) ToProto() *ProtoDesiredLRPResponse {
	proto := &ProtoDesiredLRPResponse{
		Error:      x.Error.ToProto(),
		DesiredLrp: x.DesiredLrp.ToProto(),
	}
	return proto
}

func DesiredLRPResponseProtoMap(values []*DesiredLRPResponse) []*ProtoDesiredLRPResponse {
	result := make([]*ProtoDesiredLRPResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPSchedulingInfosResponse directly
type DesiredLRPSchedulingInfosResponse struct {
	Error                     *Error
	DesiredLrpSchedulingInfos []*DesiredLRPSchedulingInfo
}

func (m *DesiredLRPSchedulingInfosResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *DesiredLRPSchedulingInfosResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (m *DesiredLRPSchedulingInfosResponse) GetDesiredLrpSchedulingInfos() []*DesiredLRPSchedulingInfo {
	if m != nil {
		return m.DesiredLrpSchedulingInfos
	}
	return nil
}
func (m *DesiredLRPSchedulingInfosResponse) SetDesiredLrpSchedulingInfos(value []*DesiredLRPSchedulingInfo) {
	if m != nil {
		m.DesiredLrpSchedulingInfos = value
	}
}
func (x *DesiredLRPSchedulingInfosResponse) ToProto() *ProtoDesiredLRPSchedulingInfosResponse {
	proto := &ProtoDesiredLRPSchedulingInfosResponse{
		Error:                     x.Error.ToProto(),
		DesiredLrpSchedulingInfos: DesiredLRPSchedulingInfoProtoMap(x.DesiredLrpSchedulingInfos),
	}
	return proto
}

func DesiredLRPSchedulingInfosResponseProtoMap(values []*DesiredLRPSchedulingInfosResponse) []*ProtoDesiredLRPSchedulingInfosResponse {
	result := make([]*ProtoDesiredLRPSchedulingInfosResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPSchedulingInfoByProcessGuidResponse directly
type DesiredLRPSchedulingInfoByProcessGuidResponse struct {
	Error                    *Error
	DesiredLrpSchedulingInfo *DesiredLRPSchedulingInfo
}

func (m *DesiredLRPSchedulingInfoByProcessGuidResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *DesiredLRPSchedulingInfoByProcessGuidResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (m *DesiredLRPSchedulingInfoByProcessGuidResponse) GetDesiredLrpSchedulingInfo() *DesiredLRPSchedulingInfo {
	if m != nil {
		return m.DesiredLrpSchedulingInfo
	}
	return nil
}
func (m *DesiredLRPSchedulingInfoByProcessGuidResponse) SetDesiredLrpSchedulingInfo(value *DesiredLRPSchedulingInfo) {
	if m != nil {
		m.DesiredLrpSchedulingInfo = value
	}
}
func (x *DesiredLRPSchedulingInfoByProcessGuidResponse) ToProto() *ProtoDesiredLRPSchedulingInfoByProcessGuidResponse {
	proto := &ProtoDesiredLRPSchedulingInfoByProcessGuidResponse{
		Error:                    x.Error.ToProto(),
		DesiredLrpSchedulingInfo: x.DesiredLrpSchedulingInfo.ToProto(),
	}
	return proto
}

func DesiredLRPSchedulingInfoByProcessGuidResponseProtoMap(values []*DesiredLRPSchedulingInfoByProcessGuidResponse) []*ProtoDesiredLRPSchedulingInfoByProcessGuidResponse {
	result := make([]*ProtoDesiredLRPSchedulingInfoByProcessGuidResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPByProcessGuidRequest directly
type DesiredLRPByProcessGuidRequest struct {
	ProcessGuid string
}

func (m *DesiredLRPByProcessGuidRequest) GetProcessGuid() string {
	if m != nil {
		return m.ProcessGuid
	}
	return ""
}
func (m *DesiredLRPByProcessGuidRequest) SetProcessGuid(value string) {
	if m != nil {
		m.ProcessGuid = value
	}
}
func (x *DesiredLRPByProcessGuidRequest) ToProto() *ProtoDesiredLRPByProcessGuidRequest {
	proto := &ProtoDesiredLRPByProcessGuidRequest{
		ProcessGuid: x.ProcessGuid,
	}
	return proto
}

func DesiredLRPByProcessGuidRequestProtoMap(values []*DesiredLRPByProcessGuidRequest) []*ProtoDesiredLRPByProcessGuidRequest {
	result := make([]*ProtoDesiredLRPByProcessGuidRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesireLRPRequest directly
type DesireLRPRequest struct {
	DesiredLrp *DesiredLRP
}

func (m *DesireLRPRequest) GetDesiredLrp() *DesiredLRP {
	if m != nil {
		return m.DesiredLrp
	}
	return nil
}
func (m *DesireLRPRequest) SetDesiredLrp(value *DesiredLRP) {
	if m != nil {
		m.DesiredLrp = value
	}
}
func (x *DesireLRPRequest) ToProto() *ProtoDesireLRPRequest {
	proto := &ProtoDesireLRPRequest{
		DesiredLrp: x.DesiredLrp.ToProto(),
	}
	return proto
}

func DesireLRPRequestProtoMap(values []*DesireLRPRequest) []*ProtoDesireLRPRequest {
	result := make([]*ProtoDesireLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoUpdateDesiredLRPRequest directly
type UpdateDesiredLRPRequest struct {
	ProcessGuid string
	Update      *DesiredLRPUpdate
}

func (m *UpdateDesiredLRPRequest) GetProcessGuid() string {
	if m != nil {
		return m.ProcessGuid
	}
	return ""
}
func (m *UpdateDesiredLRPRequest) SetProcessGuid(value string) {
	if m != nil {
		m.ProcessGuid = value
	}
}
func (m *UpdateDesiredLRPRequest) GetUpdate() *DesiredLRPUpdate {
	if m != nil {
		return m.Update
	}
	return nil
}
func (m *UpdateDesiredLRPRequest) SetUpdate(value *DesiredLRPUpdate) {
	if m != nil {
		m.Update = value
	}
}
func (x *UpdateDesiredLRPRequest) ToProto() *ProtoUpdateDesiredLRPRequest {
	proto := &ProtoUpdateDesiredLRPRequest{
		ProcessGuid: x.ProcessGuid,
		Update:      x.Update.ToProto(),
	}
	return proto
}

func UpdateDesiredLRPRequestProtoMap(values []*UpdateDesiredLRPRequest) []*ProtoUpdateDesiredLRPRequest {
	result := make([]*ProtoUpdateDesiredLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoRemoveDesiredLRPRequest directly
type RemoveDesiredLRPRequest struct {
	ProcessGuid string
}

func (m *RemoveDesiredLRPRequest) GetProcessGuid() string {
	if m != nil {
		return m.ProcessGuid
	}
	return ""
}
func (m *RemoveDesiredLRPRequest) SetProcessGuid(value string) {
	if m != nil {
		m.ProcessGuid = value
	}
}
func (x *RemoveDesiredLRPRequest) ToProto() *ProtoRemoveDesiredLRPRequest {
	proto := &ProtoRemoveDesiredLRPRequest{
		ProcessGuid: x.ProcessGuid,
	}
	return proto
}

func RemoveDesiredLRPRequestProtoMap(values []*RemoveDesiredLRPRequest) []*ProtoRemoveDesiredLRPRequest {
	result := make([]*ProtoRemoveDesiredLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}
