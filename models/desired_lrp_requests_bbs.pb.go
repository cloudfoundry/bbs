// Code generated by protoc-gen-go-bbs. DO NOT EDIT.
// versions:
// - protoc-gen-go-bbs v0.0.1
// - protoc            v5.27.0--rc1
// source: desired_lrp_requests.proto

package models

// Prevent copylock errors when using ProtoDesiredLRPLifecycleResponse directly
type DesiredLRPLifecycleResponse struct {
	Error *Error
}

func (this *DesiredLRPLifecycleResponse) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRPLifecycleResponse)
	if !ok {
		that2, ok := that.(DesiredLRPLifecycleResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.Error.Equal(that1.Error) {
		return false
	}
	return true
}
func (m *DesiredLRPLifecycleResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *DesiredLRPLifecycleResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (x *DesiredLRPLifecycleResponse) ToProto() *ProtoDesiredLRPLifecycleResponse {
	proto := &ProtoDesiredLRPLifecycleResponse{
		Error: x.Error.ToProto(),
	}
	return proto
}

func DesiredLRPLifecycleResponseProtoMap(values []*DesiredLRPLifecycleResponse) []*ProtoDesiredLRPLifecycleResponse {
	result := make([]*ProtoDesiredLRPLifecycleResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPsResponse directly
type DesiredLRPsResponse struct {
	Error       *Error
	DesiredLRPs []*DesiredLRP
}

func (this *DesiredLRPsResponse) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRPsResponse)
	if !ok {
		that2, ok := that.(DesiredLRPsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.Error.Equal(that1.Error) {
		return false
	}
	if len(this.DesiredLRPs) != len(that1.DesiredLRPs) {
		return false
	}
	for i := range this.DesiredLRPs {
		if !this.DesiredLRPs[i].Equal(that1.DesiredLRPs[i]) {
			return false
		}
	}
	return true
}
func (m *DesiredLRPsResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *DesiredLRPsResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (m *DesiredLRPsResponse) GetDesiredLRPs() []*DesiredLRP {
	if m != nil {
		return m.DesiredLRPs
	}
	return nil
}
func (m *DesiredLRPsResponse) SetDesiredLRPs(value []*DesiredLRP) {
	if m != nil {
		m.DesiredLRPs = value
	}
}
func (x *DesiredLRPsResponse) ToProto() *ProtoDesiredLRPsResponse {
	proto := &ProtoDesiredLRPsResponse{
		Error:       x.Error.ToProto(),
		DesiredLrps: DesiredLRPProtoMap(x.DesiredLRPs),
	}
	return proto
}

func DesiredLRPsResponseProtoMap(values []*DesiredLRPsResponse) []*ProtoDesiredLRPsResponse {
	result := make([]*ProtoDesiredLRPsResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPsRequest directly
type DesiredLRPsRequest struct {
	Domain       string
	ProcessGuids []string
}

func (this *DesiredLRPsRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRPsRequest)
	if !ok {
		that2, ok := that.(DesiredLRPsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Domain != that1.Domain {
		return false
	}
	if len(this.ProcessGuids) != len(that1.ProcessGuids) {
		return false
	}
	for i := range this.ProcessGuids {
		if this.ProcessGuids[i] != that1.ProcessGuids[i] {
			return false
		}
	}
	return true
}
func (m *DesiredLRPsRequest) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}
func (m *DesiredLRPsRequest) SetDomain(value string) {
	if m != nil {
		m.Domain = value
	}
}
func (m *DesiredLRPsRequest) GetProcessGuids() []string {
	if m != nil {
		return m.ProcessGuids
	}
	return nil
}
func (m *DesiredLRPsRequest) SetProcessGuids(value []string) {
	if m != nil {
		m.ProcessGuids = value
	}
}
func (x *DesiredLRPsRequest) ToProto() *ProtoDesiredLRPsRequest {
	proto := &ProtoDesiredLRPsRequest{
		Domain:       x.Domain,
		ProcessGuids: x.ProcessGuids,
	}
	return proto
}

func DesiredLRPsRequestProtoMap(values []*DesiredLRPsRequest) []*ProtoDesiredLRPsRequest {
	result := make([]*ProtoDesiredLRPsRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPResponse directly
type DesiredLRPResponse struct {
	Error      *Error
	DesiredLRP *DesiredLRP
}

func (this *DesiredLRPResponse) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRPResponse)
	if !ok {
		that2, ok := that.(DesiredLRPResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.Error.Equal(that1.Error) {
		return false
	}
	if !this.DesiredLRP.Equal(that1.DesiredLRP) {
		return false
	}
	return true
}
func (m *DesiredLRPResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *DesiredLRPResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (m *DesiredLRPResponse) GetDesiredLRP() *DesiredLRP {
	if m != nil {
		return m.DesiredLRP
	}
	return nil
}
func (m *DesiredLRPResponse) SetDesiredLRP(value *DesiredLRP) {
	if m != nil {
		m.DesiredLRP = value
	}
}
func (x *DesiredLRPResponse) ToProto() *ProtoDesiredLRPResponse {
	proto := &ProtoDesiredLRPResponse{
		Error:      x.Error.ToProto(),
		DesiredLrp: x.DesiredLRP.ToProto(),
	}
	return proto
}

func DesiredLRPResponseProtoMap(values []*DesiredLRPResponse) []*ProtoDesiredLRPResponse {
	result := make([]*ProtoDesiredLRPResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPSchedulingInfosResponse directly
type DesiredLRPSchedulingInfosResponse struct {
	Error                     *Error
	DesiredLRPSchedulingInfos []*DesiredLRPSchedulingInfo
}

func (this *DesiredLRPSchedulingInfosResponse) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRPSchedulingInfosResponse)
	if !ok {
		that2, ok := that.(DesiredLRPSchedulingInfosResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.Error.Equal(that1.Error) {
		return false
	}
	if len(this.DesiredLRPSchedulingInfos) != len(that1.DesiredLRPSchedulingInfos) {
		return false
	}
	for i := range this.DesiredLRPSchedulingInfos {
		if !this.DesiredLRPSchedulingInfos[i].Equal(that1.DesiredLRPSchedulingInfos[i]) {
			return false
		}
	}
	return true
}
func (m *DesiredLRPSchedulingInfosResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *DesiredLRPSchedulingInfosResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (m *DesiredLRPSchedulingInfosResponse) GetDesiredLRPSchedulingInfos() []*DesiredLRPSchedulingInfo {
	if m != nil {
		return m.DesiredLRPSchedulingInfos
	}
	return nil
}
func (m *DesiredLRPSchedulingInfosResponse) SetDesiredLRPSchedulingInfos(value []*DesiredLRPSchedulingInfo) {
	if m != nil {
		m.DesiredLRPSchedulingInfos = value
	}
}
func (x *DesiredLRPSchedulingInfosResponse) ToProto() *ProtoDesiredLRPSchedulingInfosResponse {
	proto := &ProtoDesiredLRPSchedulingInfosResponse{
		Error:                     x.Error.ToProto(),
		DesiredLrpSchedulingInfos: DesiredLRPSchedulingInfoProtoMap(x.DesiredLRPSchedulingInfos),
	}
	return proto
}

func DesiredLRPSchedulingInfosResponseProtoMap(values []*DesiredLRPSchedulingInfosResponse) []*ProtoDesiredLRPSchedulingInfosResponse {
	result := make([]*ProtoDesiredLRPSchedulingInfosResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPSchedulingInfoByProcessGuidResponse directly
type DesiredLRPSchedulingInfoByProcessGuidResponse struct {
	Error                    *Error
	DesiredLRPSchedulingInfo *DesiredLRPSchedulingInfo
}

func (this *DesiredLRPSchedulingInfoByProcessGuidResponse) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRPSchedulingInfoByProcessGuidResponse)
	if !ok {
		that2, ok := that.(DesiredLRPSchedulingInfoByProcessGuidResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.Error.Equal(that1.Error) {
		return false
	}
	if !this.DesiredLRPSchedulingInfo.Equal(that1.DesiredLRPSchedulingInfo) {
		return false
	}
	return true
}
func (m *DesiredLRPSchedulingInfoByProcessGuidResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}
func (m *DesiredLRPSchedulingInfoByProcessGuidResponse) SetError(value *Error) {
	if m != nil {
		m.Error = value
	}
}
func (m *DesiredLRPSchedulingInfoByProcessGuidResponse) GetDesiredLRPSchedulingInfo() *DesiredLRPSchedulingInfo {
	if m != nil {
		return m.DesiredLRPSchedulingInfo
	}
	return nil
}
func (m *DesiredLRPSchedulingInfoByProcessGuidResponse) SetDesiredLRPSchedulingInfo(value *DesiredLRPSchedulingInfo) {
	if m != nil {
		m.DesiredLRPSchedulingInfo = value
	}
}
func (x *DesiredLRPSchedulingInfoByProcessGuidResponse) ToProto() *ProtoDesiredLRPSchedulingInfoByProcessGuidResponse {
	proto := &ProtoDesiredLRPSchedulingInfoByProcessGuidResponse{
		Error:                    x.Error.ToProto(),
		DesiredLrpSchedulingInfo: x.DesiredLRPSchedulingInfo.ToProto(),
	}
	return proto
}

func DesiredLRPSchedulingInfoByProcessGuidResponseProtoMap(values []*DesiredLRPSchedulingInfoByProcessGuidResponse) []*ProtoDesiredLRPSchedulingInfoByProcessGuidResponse {
	result := make([]*ProtoDesiredLRPSchedulingInfoByProcessGuidResponse, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesiredLRPByProcessGuidRequest directly
type DesiredLRPByProcessGuidRequest struct {
	ProcessGuid string
}

func (this *DesiredLRPByProcessGuidRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesiredLRPByProcessGuidRequest)
	if !ok {
		that2, ok := that.(DesiredLRPByProcessGuidRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.ProcessGuid != that1.ProcessGuid {
		return false
	}
	return true
}
func (m *DesiredLRPByProcessGuidRequest) GetProcessGuid() string {
	if m != nil {
		return m.ProcessGuid
	}
	return ""
}
func (m *DesiredLRPByProcessGuidRequest) SetProcessGuid(value string) {
	if m != nil {
		m.ProcessGuid = value
	}
}
func (x *DesiredLRPByProcessGuidRequest) ToProto() *ProtoDesiredLRPByProcessGuidRequest {
	proto := &ProtoDesiredLRPByProcessGuidRequest{
		ProcessGuid: x.ProcessGuid,
	}
	return proto
}

func DesiredLRPByProcessGuidRequestProtoMap(values []*DesiredLRPByProcessGuidRequest) []*ProtoDesiredLRPByProcessGuidRequest {
	result := make([]*ProtoDesiredLRPByProcessGuidRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoDesireLRPRequest directly
type DesireLRPRequest struct {
	DesiredLRP *DesiredLRP
}

func (this *DesireLRPRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DesireLRPRequest)
	if !ok {
		that2, ok := that.(DesireLRPRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.DesiredLRP.Equal(that1.DesiredLRP) {
		return false
	}
	return true
}
func (m *DesireLRPRequest) GetDesiredLRP() *DesiredLRP {
	if m != nil {
		return m.DesiredLRP
	}
	return nil
}
func (m *DesireLRPRequest) SetDesiredLRP(value *DesiredLRP) {
	if m != nil {
		m.DesiredLRP = value
	}
}
func (x *DesireLRPRequest) ToProto() *ProtoDesireLRPRequest {
	proto := &ProtoDesireLRPRequest{
		DesiredLrp: x.DesiredLRP.ToProto(),
	}
	return proto
}

func DesireLRPRequestProtoMap(values []*DesireLRPRequest) []*ProtoDesireLRPRequest {
	result := make([]*ProtoDesireLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoUpdateDesiredLRPRequest directly
type UpdateDesiredLRPRequest struct {
	ProcessGuid string
	Update      *DesiredLRPUpdate
}

func (this *UpdateDesiredLRPRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateDesiredLRPRequest)
	if !ok {
		that2, ok := that.(UpdateDesiredLRPRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.ProcessGuid != that1.ProcessGuid {
		return false
	}
	if !this.Update.Equal(that1.Update) {
		return false
	}
	return true
}
func (m *UpdateDesiredLRPRequest) GetProcessGuid() string {
	if m != nil {
		return m.ProcessGuid
	}
	return ""
}
func (m *UpdateDesiredLRPRequest) SetProcessGuid(value string) {
	if m != nil {
		m.ProcessGuid = value
	}
}
func (m *UpdateDesiredLRPRequest) GetUpdate() *DesiredLRPUpdate {
	if m != nil {
		return m.Update
	}
	return nil
}
func (m *UpdateDesiredLRPRequest) SetUpdate(value *DesiredLRPUpdate) {
	if m != nil {
		m.Update = value
	}
}
func (x *UpdateDesiredLRPRequest) ToProto() *ProtoUpdateDesiredLRPRequest {
	proto := &ProtoUpdateDesiredLRPRequest{
		ProcessGuid: x.ProcessGuid,
		Update:      x.Update.ToProto(),
	}
	return proto
}

func UpdateDesiredLRPRequestProtoMap(values []*UpdateDesiredLRPRequest) []*ProtoUpdateDesiredLRPRequest {
	result := make([]*ProtoUpdateDesiredLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoRemoveDesiredLRPRequest directly
type RemoveDesiredLRPRequest struct {
	ProcessGuid string
}

func (this *RemoveDesiredLRPRequest) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RemoveDesiredLRPRequest)
	if !ok {
		that2, ok := that.(RemoveDesiredLRPRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.ProcessGuid != that1.ProcessGuid {
		return false
	}
	return true
}
func (m *RemoveDesiredLRPRequest) GetProcessGuid() string {
	if m != nil {
		return m.ProcessGuid
	}
	return ""
}
func (m *RemoveDesiredLRPRequest) SetProcessGuid(value string) {
	if m != nil {
		m.ProcessGuid = value
	}
}
func (x *RemoveDesiredLRPRequest) ToProto() *ProtoRemoveDesiredLRPRequest {
	proto := &ProtoRemoveDesiredLRPRequest{
		ProcessGuid: x.ProcessGuid,
	}
	return proto
}

func RemoveDesiredLRPRequestProtoMap(values []*RemoveDesiredLRPRequest) []*ProtoRemoveDesiredLRPRequest {
	result := make([]*ProtoRemoveDesiredLRPRequest, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}
