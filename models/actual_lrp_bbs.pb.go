// Code generated by protoc-gen-go-bbs. DO NOT EDIT.
// versions:
// - protoc-gen-go-bbs v0.0.1
// - protoc            v5.29.3
// source: actual_lrp.proto

package models

import (
	strconv "strconv"
)

// Deprecated: marked deprecated in actual_lrp.proto
// Prevent copylock errors when using ProtoActualLRPGroup directly
type ActualLRPGroup struct {
	Instance   *ActualLRP `json:"instance,omitempty"`
	Evacuating *ActualLRP `json:"evacuating,omitempty"`
}

func (this *ActualLRPGroup) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPGroup)
	if !ok {
		that2, ok := that.(ActualLRPGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Instance == nil {
		if that1.Instance != nil {
			return false
		}
	} else if !this.Instance.Equal(*that1.Instance) {
		return false
	}
	if this.Evacuating == nil {
		if that1.Evacuating != nil {
			return false
		}
	} else if !this.Evacuating.Equal(*that1.Evacuating) {
		return false
	}
	return true
}
func (m *ActualLRPGroup) GetInstance() *ActualLRP {
	if m != nil {
		return m.Instance
	}
	return nil
}
func (m *ActualLRPGroup) SetInstance(value *ActualLRP) {
	if m != nil {
		m.Instance = value
	}
}
func (m *ActualLRPGroup) GetEvacuating() *ActualLRP {
	if m != nil {
		return m.Evacuating
	}
	return nil
}
func (m *ActualLRPGroup) SetEvacuating(value *ActualLRP) {
	if m != nil {
		m.Evacuating = value
	}
}
func (x *ActualLRPGroup) ToProto() *ProtoActualLRPGroup {
	if x == nil {
		return nil
	}

	proto := &ProtoActualLRPGroup{
		Instance:   x.Instance.ToProto(),
		Evacuating: x.Evacuating.ToProto(),
	}
	return proto
}

func (x *ProtoActualLRPGroup) FromProto() *ActualLRPGroup {
	if x == nil {
		return nil
	}

	copysafe := &ActualLRPGroup{
		Instance:   x.Instance.FromProto(),
		Evacuating: x.Evacuating.FromProto(),
	}
	return copysafe
}

func ActualLRPGroupToProtoSlice(values []*ActualLRPGroup) []*ProtoActualLRPGroup {
	if values == nil {
		return nil
	}
	result := make([]*ProtoActualLRPGroup, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func ActualLRPGroupFromProtoSlice(values []*ProtoActualLRPGroup) []*ActualLRPGroup {
	if values == nil {
		return nil
	}
	result := make([]*ActualLRPGroup, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoPortMapping directly
type PortMapping struct {
	ContainerPort         uint32 `json:"container_port"`
	HostPort              uint32 `json:"host_port"`
	ContainerTlsProxyPort uint32 `json:"container_tls_proxy_port"`
	HostTlsProxyPort      uint32 `json:"host_tls_proxy_port"`
}

func (this *PortMapping) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortMapping)
	if !ok {
		that2, ok := that.(PortMapping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.ContainerPort != that1.ContainerPort {
		return false
	}
	if this.HostPort != that1.HostPort {
		return false
	}
	if this.ContainerTlsProxyPort != that1.ContainerTlsProxyPort {
		return false
	}
	if this.HostTlsProxyPort != that1.HostTlsProxyPort {
		return false
	}
	return true
}
func (m *PortMapping) GetContainerPort() uint32 {
	if m != nil {
		return m.ContainerPort
	}
	var defaultValue uint32
	defaultValue = 0
	return defaultValue
}
func (m *PortMapping) SetContainerPort(value uint32) {
	if m != nil {
		m.ContainerPort = value
	}
}
func (m *PortMapping) GetHostPort() uint32 {
	if m != nil {
		return m.HostPort
	}
	var defaultValue uint32
	defaultValue = 0
	return defaultValue
}
func (m *PortMapping) SetHostPort(value uint32) {
	if m != nil {
		m.HostPort = value
	}
}
func (m *PortMapping) GetContainerTlsProxyPort() uint32 {
	if m != nil {
		return m.ContainerTlsProxyPort
	}
	var defaultValue uint32
	defaultValue = 0
	return defaultValue
}
func (m *PortMapping) SetContainerTlsProxyPort(value uint32) {
	if m != nil {
		m.ContainerTlsProxyPort = value
	}
}
func (m *PortMapping) GetHostTlsProxyPort() uint32 {
	if m != nil {
		return m.HostTlsProxyPort
	}
	var defaultValue uint32
	defaultValue = 0
	return defaultValue
}
func (m *PortMapping) SetHostTlsProxyPort(value uint32) {
	if m != nil {
		m.HostTlsProxyPort = value
	}
}
func (x *PortMapping) ToProto() *ProtoPortMapping {
	if x == nil {
		return nil
	}

	proto := &ProtoPortMapping{
		ContainerPort:         x.ContainerPort,
		HostPort:              x.HostPort,
		ContainerTlsProxyPort: x.ContainerTlsProxyPort,
		HostTlsProxyPort:      x.HostTlsProxyPort,
	}
	return proto
}

func (x *ProtoPortMapping) FromProto() *PortMapping {
	if x == nil {
		return nil
	}

	copysafe := &PortMapping{
		ContainerPort:         x.ContainerPort,
		HostPort:              x.HostPort,
		ContainerTlsProxyPort: x.ContainerTlsProxyPort,
		HostTlsProxyPort:      x.HostTlsProxyPort,
	}
	return copysafe
}

func PortMappingToProtoSlice(values []*PortMapping) []*ProtoPortMapping {
	if values == nil {
		return nil
	}
	result := make([]*ProtoPortMapping, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func PortMappingFromProtoSlice(values []*ProtoPortMapping) []*PortMapping {
	if values == nil {
		return nil
	}
	result := make([]*PortMapping, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPKey directly
type ActualLRPKey struct {
	ProcessGuid string `json:"process_guid"`
	Index       int32  `json:"index"`
	Domain      string `json:"domain"`
}

func (this *ActualLRPKey) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPKey)
	if !ok {
		that2, ok := that.(ActualLRPKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.ProcessGuid != that1.ProcessGuid {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	return true
}
func (m *ActualLRPKey) GetProcessGuid() string {
	if m != nil {
		return m.ProcessGuid
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *ActualLRPKey) SetProcessGuid(value string) {
	if m != nil {
		m.ProcessGuid = value
	}
}
func (m *ActualLRPKey) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	var defaultValue int32
	defaultValue = 0
	return defaultValue
}
func (m *ActualLRPKey) SetIndex(value int32) {
	if m != nil {
		m.Index = value
	}
}
func (m *ActualLRPKey) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *ActualLRPKey) SetDomain(value string) {
	if m != nil {
		m.Domain = value
	}
}
func (x *ActualLRPKey) ToProto() *ProtoActualLRPKey {
	if x == nil {
		return nil
	}

	proto := &ProtoActualLRPKey{
		ProcessGuid: x.ProcessGuid,
		Index:       x.Index,
		Domain:      x.Domain,
	}
	return proto
}

func (x *ProtoActualLRPKey) FromProto() *ActualLRPKey {
	if x == nil {
		return nil
	}

	copysafe := &ActualLRPKey{
		ProcessGuid: x.ProcessGuid,
		Index:       x.Index,
		Domain:      x.Domain,
	}
	return copysafe
}

func ActualLRPKeyToProtoSlice(values []*ActualLRPKey) []*ProtoActualLRPKey {
	if values == nil {
		return nil
	}
	result := make([]*ProtoActualLRPKey, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func ActualLRPKeyFromProtoSlice(values []*ProtoActualLRPKey) []*ActualLRPKey {
	if values == nil {
		return nil
	}
	result := make([]*ActualLRPKey, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPInstanceKey directly
type ActualLRPInstanceKey struct {
	InstanceGuid string `json:"instance_guid"`
	CellId       string `json:"cell_id"`
}

func (this *ActualLRPInstanceKey) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPInstanceKey)
	if !ok {
		that2, ok := that.(ActualLRPInstanceKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.InstanceGuid != that1.InstanceGuid {
		return false
	}
	if this.CellId != that1.CellId {
		return false
	}
	return true
}
func (m *ActualLRPInstanceKey) GetInstanceGuid() string {
	if m != nil {
		return m.InstanceGuid
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *ActualLRPInstanceKey) SetInstanceGuid(value string) {
	if m != nil {
		m.InstanceGuid = value
	}
}
func (m *ActualLRPInstanceKey) GetCellId() string {
	if m != nil {
		return m.CellId
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *ActualLRPInstanceKey) SetCellId(value string) {
	if m != nil {
		m.CellId = value
	}
}
func (x *ActualLRPInstanceKey) ToProto() *ProtoActualLRPInstanceKey {
	if x == nil {
		return nil
	}

	proto := &ProtoActualLRPInstanceKey{
		InstanceGuid: x.InstanceGuid,
		CellId:       x.CellId,
	}
	return proto
}

func (x *ProtoActualLRPInstanceKey) FromProto() *ActualLRPInstanceKey {
	if x == nil {
		return nil
	}

	copysafe := &ActualLRPInstanceKey{
		InstanceGuid: x.InstanceGuid,
		CellId:       x.CellId,
	}
	return copysafe
}

func ActualLRPInstanceKeyToProtoSlice(values []*ActualLRPInstanceKey) []*ProtoActualLRPInstanceKey {
	if values == nil {
		return nil
	}
	result := make([]*ProtoActualLRPInstanceKey, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func ActualLRPInstanceKeyFromProtoSlice(values []*ProtoActualLRPInstanceKey) []*ActualLRPInstanceKey {
	if values == nil {
		return nil
	}
	result := make([]*ActualLRPInstanceKey, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

type ActualLRPNetInfo_PreferredAddress int32

const (
	ActualLRPNetInfo_PreferredAddressUnknown  ActualLRPNetInfo_PreferredAddress = 0
	ActualLRPNetInfo_PreferredAddressInstance ActualLRPNetInfo_PreferredAddress = 1
	ActualLRPNetInfo_PreferredAddressHost     ActualLRPNetInfo_PreferredAddress = 2
)

// Enum value maps for ActualLRPNetInfo_PreferredAddress
var (
	ActualLRPNetInfo_PreferredAddress_name = map[int32]string{
		0: "UNKNOWN",
		1: "INSTANCE",
		2: "HOST",
	}
	ActualLRPNetInfo_PreferredAddress_value = map[string]int32{
		"UNKNOWN":  0,
		"INSTANCE": 1,
		"HOST":     2,
	}
)

func (m ActualLRPNetInfo_PreferredAddress) String() string {
	s, ok := ActualLRPNetInfo_PreferredAddress_name[int32(m)]
	if ok {
		return s
	}
	return strconv.Itoa(int(m))
}

// Prevent copylock errors when using ProtoActualLRPNetInfo directly
type ActualLRPNetInfo struct {
	Address          string                            `json:"address"`
	Ports            []*PortMapping                    `json:"ports"`
	InstanceAddress  string                            `json:"instance_address,omitempty"`
	PreferredAddress ActualLRPNetInfo_PreferredAddress `json:"preferred_address"`
}

func (this *ActualLRPNetInfo) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPNetInfo)
	if !ok {
		that2, ok := that.(ActualLRPNetInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Address != that1.Address {
		return false
	}
	if this.Ports == nil {
		if that1.Ports != nil {
			return false
		}
	} else if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if !this.Ports[i].Equal(that1.Ports[i]) {
			return false
		}
	}
	if this.InstanceAddress != that1.InstanceAddress {
		return false
	}
	if this.PreferredAddress != that1.PreferredAddress {
		return false
	}
	return true
}
func (m *ActualLRPNetInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *ActualLRPNetInfo) SetAddress(value string) {
	if m != nil {
		m.Address = value
	}
}
func (m *ActualLRPNetInfo) GetPorts() []*PortMapping {
	if m != nil {
		return m.Ports
	}
	return nil
}
func (m *ActualLRPNetInfo) SetPorts(value []*PortMapping) {
	if m != nil {
		m.Ports = value
	}
}
func (m *ActualLRPNetInfo) GetInstanceAddress() string {
	if m != nil {
		return m.InstanceAddress
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *ActualLRPNetInfo) SetInstanceAddress(value string) {
	if m != nil {
		m.InstanceAddress = value
	}
}
func (m *ActualLRPNetInfo) GetPreferredAddress() ActualLRPNetInfo_PreferredAddress {
	if m != nil {
		return m.PreferredAddress
	}
	var defaultValue ActualLRPNetInfo_PreferredAddress
	defaultValue = 0
	return defaultValue
}
func (m *ActualLRPNetInfo) SetPreferredAddress(value ActualLRPNetInfo_PreferredAddress) {
	if m != nil {
		m.PreferredAddress = value
	}
}
func (x *ActualLRPNetInfo) ToProto() *ProtoActualLRPNetInfo {
	if x == nil {
		return nil
	}

	proto := &ProtoActualLRPNetInfo{
		Address:          x.Address,
		Ports:            PortMappingToProtoSlice(x.Ports),
		InstanceAddress:  x.InstanceAddress,
		PreferredAddress: ProtoActualLRPNetInfo_PreferredAddress(x.PreferredAddress),
	}
	return proto
}

func (x *ProtoActualLRPNetInfo) FromProto() *ActualLRPNetInfo {
	if x == nil {
		return nil
	}

	copysafe := &ActualLRPNetInfo{
		Address:          x.Address,
		Ports:            PortMappingFromProtoSlice(x.Ports),
		InstanceAddress:  x.InstanceAddress,
		PreferredAddress: ActualLRPNetInfo_PreferredAddress(x.PreferredAddress),
	}
	return copysafe
}

func ActualLRPNetInfoToProtoSlice(values []*ActualLRPNetInfo) []*ProtoActualLRPNetInfo {
	if values == nil {
		return nil
	}
	result := make([]*ProtoActualLRPNetInfo, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func ActualLRPNetInfoFromProtoSlice(values []*ProtoActualLRPNetInfo) []*ActualLRPNetInfo {
	if values == nil {
		return nil
	}
	result := make([]*ActualLRPNetInfo, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPInternalRoute directly
type ActualLRPInternalRoute struct {
	Hostname string `json:"hostname"`
}

func (this *ActualLRPInternalRoute) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPInternalRoute)
	if !ok {
		that2, ok := that.(ActualLRPInternalRoute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Hostname != that1.Hostname {
		return false
	}
	return true
}
func (m *ActualLRPInternalRoute) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *ActualLRPInternalRoute) SetHostname(value string) {
	if m != nil {
		m.Hostname = value
	}
}
func (x *ActualLRPInternalRoute) ToProto() *ProtoActualLRPInternalRoute {
	if x == nil {
		return nil
	}

	proto := &ProtoActualLRPInternalRoute{
		Hostname: x.Hostname,
	}
	return proto
}

func (x *ProtoActualLRPInternalRoute) FromProto() *ActualLRPInternalRoute {
	if x == nil {
		return nil
	}

	copysafe := &ActualLRPInternalRoute{
		Hostname: x.Hostname,
	}
	return copysafe
}

func ActualLRPInternalRouteToProtoSlice(values []*ActualLRPInternalRoute) []*ProtoActualLRPInternalRoute {
	if values == nil {
		return nil
	}
	result := make([]*ProtoActualLRPInternalRoute, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func ActualLRPInternalRouteFromProtoSlice(values []*ProtoActualLRPInternalRoute) []*ActualLRPInternalRoute {
	if values == nil {
		return nil
	}
	result := make([]*ActualLRPInternalRoute, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}

type ActualLRP_Presence int32

const (
	ActualLRP_Ordinary   ActualLRP_Presence = 0
	ActualLRP_Evacuating ActualLRP_Presence = 1
	ActualLRP_Suspect    ActualLRP_Presence = 2
)

// Enum value maps for ActualLRP_Presence
var (
	ActualLRP_Presence_name = map[int32]string{
		0: "ORDINARY",
		1: "EVACUATING",
		2: "SUSPECT",
	}
	ActualLRP_Presence_value = map[string]int32{
		"ORDINARY":   0,
		"EVACUATING": 1,
		"SUSPECT":    2,
	}
)

func (m ActualLRP_Presence) String() string {
	s, ok := ActualLRP_Presence_name[int32(m)]
	if ok {
		return s
	}
	return strconv.Itoa(int(m))
}

// Prevent copylock errors when using ProtoActualLRP directly
type ActualLRP struct {
	ActualLrpKey            ActualLRPKey              `json:"actualLrpKey"`
	ActualLrpInstanceKey    ActualLRPInstanceKey      `json:"actualLrpInstanceKey"`
	ActualLrpNetInfo        ActualLRPNetInfo          `json:"actualLrpNetInfo"`
	CrashCount              int32                     `json:"crash_count"`
	CrashReason             string                    `json:"crash_reason,omitempty"`
	State                   string                    `json:"state"`
	PlacementError          string                    `json:"placement_error,omitempty"`
	Since                   int64                     `json:"since"`
	ModificationTag         ModificationTag           `json:"modification_tag"`
	Presence                ActualLRP_Presence        `json:"presence,omitempty"`
	ActualLrpInternalRoutes []*ActualLRPInternalRoute `json:"actualLrpInternalRoutes,omitempty"`
	MetricTags              map[string]string         `json:"metric_tags,omitempty"`
	Routable                *bool                     `json:"routable"`
	AvailabilityZone        string                    `json:"availability_zone"`
}

func (this *ActualLRP) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRP)
	if !ok {
		that2, ok := that.(ActualLRP)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.ActualLrpKey.Equal(that1.ActualLrpKey) {
		return false
	}
	if !this.ActualLrpInstanceKey.Equal(that1.ActualLrpInstanceKey) {
		return false
	}
	if !this.ActualLrpNetInfo.Equal(that1.ActualLrpNetInfo) {
		return false
	}
	if this.CrashCount != that1.CrashCount {
		return false
	}
	if this.CrashReason != that1.CrashReason {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.PlacementError != that1.PlacementError {
		return false
	}
	if this.Since != that1.Since {
		return false
	}
	if !this.ModificationTag.Equal(that1.ModificationTag) {
		return false
	}
	if this.Presence != that1.Presence {
		return false
	}
	if this.ActualLrpInternalRoutes == nil {
		if that1.ActualLrpInternalRoutes != nil {
			return false
		}
	} else if len(this.ActualLrpInternalRoutes) != len(that1.ActualLrpInternalRoutes) {
		return false
	}
	for i := range this.ActualLrpInternalRoutes {
		if !this.ActualLrpInternalRoutes[i].Equal(that1.ActualLrpInternalRoutes[i]) {
			return false
		}
	}
	if this.MetricTags == nil {
		if that1.MetricTags != nil {
			return false
		}
	} else if len(this.MetricTags) != len(that1.MetricTags) {
		return false
	}
	for i := range this.MetricTags {
		if this.MetricTags[i] != that1.MetricTags[i] {
			return false
		}
	}
	if this.Routable == nil {
		if that1.Routable != nil {
			return false
		}
	} else if *this.Routable != *that1.Routable {
		return false
	}
	if this.AvailabilityZone != that1.AvailabilityZone {
		return false
	}
	return true
}
func (m *ActualLRP) SetActualLrpKey(value ActualLRPKey) {
	if m != nil {
		m.ActualLrpKey = value
	}
}
func (m *ActualLRP) SetActualLrpInstanceKey(value ActualLRPInstanceKey) {
	if m != nil {
		m.ActualLrpInstanceKey = value
	}
}
func (m *ActualLRP) SetActualLrpNetInfo(value ActualLRPNetInfo) {
	if m != nil {
		m.ActualLrpNetInfo = value
	}
}
func (m *ActualLRP) GetCrashCount() int32 {
	if m != nil {
		return m.CrashCount
	}
	var defaultValue int32
	defaultValue = 0
	return defaultValue
}
func (m *ActualLRP) SetCrashCount(value int32) {
	if m != nil {
		m.CrashCount = value
	}
}
func (m *ActualLRP) GetCrashReason() string {
	if m != nil {
		return m.CrashReason
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *ActualLRP) SetCrashReason(value string) {
	if m != nil {
		m.CrashReason = value
	}
}
func (m *ActualLRP) GetState() string {
	if m != nil {
		return m.State
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *ActualLRP) SetState(value string) {
	if m != nil {
		m.State = value
	}
}
func (m *ActualLRP) GetPlacementError() string {
	if m != nil {
		return m.PlacementError
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *ActualLRP) SetPlacementError(value string) {
	if m != nil {
		m.PlacementError = value
	}
}
func (m *ActualLRP) GetSince() int64 {
	if m != nil {
		return m.Since
	}
	var defaultValue int64
	defaultValue = 0
	return defaultValue
}
func (m *ActualLRP) SetSince(value int64) {
	if m != nil {
		m.Since = value
	}
}
func (m *ActualLRP) SetModificationTag(value ModificationTag) {
	if m != nil {
		m.ModificationTag = value
	}
}
func (m *ActualLRP) GetPresence() ActualLRP_Presence {
	if m != nil {
		return m.Presence
	}
	var defaultValue ActualLRP_Presence
	defaultValue = 0
	return defaultValue
}
func (m *ActualLRP) SetPresence(value ActualLRP_Presence) {
	if m != nil {
		m.Presence = value
	}
}
func (m *ActualLRP) GetActualLrpInternalRoutes() []*ActualLRPInternalRoute {
	if m != nil {
		return m.ActualLrpInternalRoutes
	}
	return nil
}
func (m *ActualLRP) SetActualLrpInternalRoutes(value []*ActualLRPInternalRoute) {
	if m != nil {
		m.ActualLrpInternalRoutes = value
	}
}
func (m *ActualLRP) GetMetricTags() map[string]string {
	if m != nil {
		return m.MetricTags
	}
	return nil
}
func (m *ActualLRP) SetMetricTags(value map[string]string) {
	if m != nil {
		m.MetricTags = value
	}
}
func (m *ActualLRP) RoutableExists() bool {
	return m != nil && m.Routable != nil
}
func (m *ActualLRP) GetRoutable() *bool {
	if m != nil && m.Routable != nil {
		return m.Routable
	}
	var defaultValue bool
	defaultValue = false
	return &defaultValue
}
func (m *ActualLRP) SetRoutable(value *bool) {
	if m != nil {
		m.Routable = value
	}
}
func (m *ActualLRP) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	var defaultValue string
	defaultValue = ""
	return defaultValue
}
func (m *ActualLRP) SetAvailabilityZone(value string) {
	if m != nil {
		m.AvailabilityZone = value
	}
}
func (x *ActualLRP) ToProto() *ProtoActualLRP {
	if x == nil {
		return nil
	}

	proto := &ProtoActualLRP{
		ActualLrpKey:            x.ActualLrpKey.ToProto(),
		ActualLrpInstanceKey:    x.ActualLrpInstanceKey.ToProto(),
		ActualLrpNetInfo:        x.ActualLrpNetInfo.ToProto(),
		CrashCount:              x.CrashCount,
		CrashReason:             x.CrashReason,
		State:                   x.State,
		PlacementError:          x.PlacementError,
		Since:                   x.Since,
		ModificationTag:         x.ModificationTag.ToProto(),
		Presence:                ProtoActualLRP_Presence(x.Presence),
		ActualLrpInternalRoutes: ActualLRPInternalRouteToProtoSlice(x.ActualLrpInternalRoutes),
		MetricTags:              x.MetricTags,
		Routable:                x.Routable,
		AvailabilityZone:        x.AvailabilityZone,
	}
	return proto
}

func (x *ProtoActualLRP) FromProto() *ActualLRP {
	if x == nil {
		return nil
	}

	copysafe := &ActualLRP{
		ActualLrpKey:            *x.ActualLrpKey.FromProto(),
		ActualLrpInstanceKey:    *x.ActualLrpInstanceKey.FromProto(),
		ActualLrpNetInfo:        *x.ActualLrpNetInfo.FromProto(),
		CrashCount:              x.CrashCount,
		CrashReason:             x.CrashReason,
		State:                   x.State,
		PlacementError:          x.PlacementError,
		Since:                   x.Since,
		ModificationTag:         *x.ModificationTag.FromProto(),
		Presence:                ActualLRP_Presence(x.Presence),
		ActualLrpInternalRoutes: ActualLRPInternalRouteFromProtoSlice(x.ActualLrpInternalRoutes),
		MetricTags:              x.MetricTags,
		Routable:                x.Routable,
		AvailabilityZone:        x.AvailabilityZone,
	}
	return copysafe
}

func ActualLRPToProtoSlice(values []*ActualLRP) []*ProtoActualLRP {
	if values == nil {
		return nil
	}
	result := make([]*ProtoActualLRP, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

func ActualLRPFromProtoSlice(values []*ProtoActualLRP) []*ActualLRP {
	if values == nil {
		return nil
	}
	result := make([]*ActualLRP, len(values))
	for i, val := range values {
		result[i] = val.FromProto()
	}
	return result
}
