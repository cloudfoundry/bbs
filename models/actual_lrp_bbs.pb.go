// Code generated by protoc-gen-go-bbs. DO NOT EDIT.
// versions:
// - protoc-gen-go-bbs v0.0.1
// - protoc            v5.27.0--rc1
// source: actual_lrp.proto

package models

import (
	strconv "strconv"
)

// Prevent copylock errors when using ProtoActualLRPGroup directly
type ActualLRPGroup struct {
	Instance   *ActualLRP
	Evacuating *ActualLRP
}

func (this *ActualLRPGroup) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPGroup)
	if !ok {
		that2, ok := that.(ActualLRPGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.Instance.Equal(that1.Instance) {
		return false
	}
	if !this.Evacuating.Equal(that1.Evacuating) {
		return false
	}
	return true
}
func (m *ActualLRPGroup) GetInstance() *ActualLRP {
	if m != nil {
		return m.Instance
	}
	return nil
}
func (m *ActualLRPGroup) SetInstance(value *ActualLRP) {
	if m != nil {
		m.Instance = value
	}
}
func (m *ActualLRPGroup) GetEvacuating() *ActualLRP {
	if m != nil {
		return m.Evacuating
	}
	return nil
}
func (m *ActualLRPGroup) SetEvacuating(value *ActualLRP) {
	if m != nil {
		m.Evacuating = value
	}
}
func (x *ActualLRPGroup) ToProto() *ProtoActualLRPGroup {
	proto := &ProtoActualLRPGroup{
		Instance:   x.Instance.ToProto(),
		Evacuating: x.Evacuating.ToProto(),
	}
	return proto
}

func ActualLRPGroupProtoMap(values []*ActualLRPGroup) []*ProtoActualLRPGroup {
	result := make([]*ProtoActualLRPGroup, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoPortMapping directly
type PortMapping struct {
	ContainerPort         uint32
	HostPort              uint32
	ContainerTlsProxyPort uint32
	HostTlsProxyPort      uint32
}

func (this *PortMapping) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PortMapping)
	if !ok {
		that2, ok := that.(PortMapping)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.ContainerPort != that1.ContainerPort {
		return false
	}
	if this.HostPort != that1.HostPort {
		return false
	}
	if this.ContainerTlsProxyPort != that1.ContainerTlsProxyPort {
		return false
	}
	if this.HostTlsProxyPort != that1.HostTlsProxyPort {
		return false
	}
	return true
}
func (m *PortMapping) GetContainerPort() uint32 {
	if m != nil {
		return m.ContainerPort
	}
	return 0
}
func (m *PortMapping) SetContainerPort(value uint32) {
	if m != nil {
		m.ContainerPort = value
	}
}
func (m *PortMapping) GetHostPort() uint32 {
	if m != nil {
		return m.HostPort
	}
	return 0
}
func (m *PortMapping) SetHostPort(value uint32) {
	if m != nil {
		m.HostPort = value
	}
}
func (m *PortMapping) GetContainerTlsProxyPort() uint32 {
	if m != nil {
		return m.ContainerTlsProxyPort
	}
	return 0
}
func (m *PortMapping) SetContainerTlsProxyPort(value uint32) {
	if m != nil {
		m.ContainerTlsProxyPort = value
	}
}
func (m *PortMapping) GetHostTlsProxyPort() uint32 {
	if m != nil {
		return m.HostTlsProxyPort
	}
	return 0
}
func (m *PortMapping) SetHostTlsProxyPort(value uint32) {
	if m != nil {
		m.HostTlsProxyPort = value
	}
}
func (x *PortMapping) ToProto() *ProtoPortMapping {
	proto := &ProtoPortMapping{
		ContainerPort:         x.ContainerPort,
		HostPort:              x.HostPort,
		ContainerTlsProxyPort: x.ContainerTlsProxyPort,
		HostTlsProxyPort:      x.HostTlsProxyPort,
	}
	return proto
}

func PortMappingProtoMap(values []*PortMapping) []*ProtoPortMapping {
	result := make([]*ProtoPortMapping, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPKey directly
type ActualLRPKey struct {
	ProcessGuid string
	Index       int32
	Domain      string
}

func (this *ActualLRPKey) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPKey)
	if !ok {
		that2, ok := that.(ActualLRPKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.ProcessGuid != that1.ProcessGuid {
		return false
	}
	if this.Index != that1.Index {
		return false
	}
	if this.Domain != that1.Domain {
		return false
	}
	return true
}
func (m *ActualLRPKey) GetProcessGuid() string {
	if m != nil {
		return m.ProcessGuid
	}
	return ""
}
func (m *ActualLRPKey) SetProcessGuid(value string) {
	if m != nil {
		m.ProcessGuid = value
	}
}
func (m *ActualLRPKey) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}
func (m *ActualLRPKey) SetIndex(value int32) {
	if m != nil {
		m.Index = value
	}
}
func (m *ActualLRPKey) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}
func (m *ActualLRPKey) SetDomain(value string) {
	if m != nil {
		m.Domain = value
	}
}
func (x *ActualLRPKey) ToProto() *ProtoActualLRPKey {
	proto := &ProtoActualLRPKey{
		ProcessGuid: x.ProcessGuid,
		Index:       x.Index,
		Domain:      x.Domain,
	}
	return proto
}

func ActualLRPKeyProtoMap(values []*ActualLRPKey) []*ProtoActualLRPKey {
	result := make([]*ProtoActualLRPKey, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPInstanceKey directly
type ActualLRPInstanceKey struct {
	InstanceGuid string
	CellId       string
}

func (this *ActualLRPInstanceKey) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPInstanceKey)
	if !ok {
		that2, ok := that.(ActualLRPInstanceKey)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.InstanceGuid != that1.InstanceGuid {
		return false
	}
	if this.CellId != that1.CellId {
		return false
	}
	return true
}
func (m *ActualLRPInstanceKey) GetInstanceGuid() string {
	if m != nil {
		return m.InstanceGuid
	}
	return ""
}
func (m *ActualLRPInstanceKey) SetInstanceGuid(value string) {
	if m != nil {
		m.InstanceGuid = value
	}
}
func (m *ActualLRPInstanceKey) GetCellId() string {
	if m != nil {
		return m.CellId
	}
	return ""
}
func (m *ActualLRPInstanceKey) SetCellId(value string) {
	if m != nil {
		m.CellId = value
	}
}
func (x *ActualLRPInstanceKey) ToProto() *ProtoActualLRPInstanceKey {
	proto := &ProtoActualLRPInstanceKey{
		InstanceGuid: x.InstanceGuid,
		CellId:       x.CellId,
	}
	return proto
}

func ActualLRPInstanceKeyProtoMap(values []*ActualLRPInstanceKey) []*ProtoActualLRPInstanceKey {
	result := make([]*ProtoActualLRPInstanceKey, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

type ActualLRPNetInfo_PreferredAddress int32

const (
	ActualLRPNetInfo_PreferredAddressUnknown  ActualLRPNetInfo_PreferredAddress = 0
	ActualLRPNetInfo_PreferredAddressInstance ActualLRPNetInfo_PreferredAddress = 1
	ActualLRPNetInfo_PreferredAddressHost     ActualLRPNetInfo_PreferredAddress = 2
)

// Enum value maps for ActualLRPNetInfo_PreferredAddress
var (
	ActualLRPNetInfo_PreferredAddress_name = map[int32]string{
		0: "UNKNOWN",
		1: "INSTANCE",
		2: "HOST",
	}
	ActualLRPNetInfo_PreferredAddress_value = map[string]int32{
		"UNKNOWN":  0,
		"INSTANCE": 1,
		"HOST":     2,
	}
)

func (m ActualLRPNetInfo_PreferredAddress) String() string {
	s, ok := ActualLRPNetInfo_PreferredAddress_name[int32(m)]
	if ok {
		return s
	}
	return strconv.Itoa(int(m))
}

// Prevent copylock errors when using ProtoActualLRPNetInfo directly
type ActualLRPNetInfo struct {
	Address          string
	Ports            []*PortMapping
	InstanceAddress  string
	PreferredAddress ActualLRPNetInfo_PreferredAddress
}

func (this *ActualLRPNetInfo) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPNetInfo)
	if !ok {
		that2, ok := that.(ActualLRPNetInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Address != that1.Address {
		return false
	}
	if len(this.Ports) != len(that1.Ports) {
		return false
	}
	for i := range this.Ports {
		if !this.Ports[i].Equal(that1.Ports[i]) {
			return false
		}
	}
	if this.InstanceAddress != that1.InstanceAddress {
		return false
	}
	if this.PreferredAddress != that1.PreferredAddress {
		return false
	}
	return true
}
func (m *ActualLRPNetInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}
func (m *ActualLRPNetInfo) SetAddress(value string) {
	if m != nil {
		m.Address = value
	}
}
func (m *ActualLRPNetInfo) GetPorts() []*PortMapping {
	if m != nil {
		return m.Ports
	}
	return nil
}
func (m *ActualLRPNetInfo) SetPorts(value []*PortMapping) {
	if m != nil {
		m.Ports = value
	}
}
func (m *ActualLRPNetInfo) GetInstanceAddress() string {
	if m != nil {
		return m.InstanceAddress
	}
	return ""
}
func (m *ActualLRPNetInfo) SetInstanceAddress(value string) {
	if m != nil {
		m.InstanceAddress = value
	}
}
func (m *ActualLRPNetInfo) GetPreferredAddress() ActualLRPNetInfo_PreferredAddress {
	if m != nil {
		return m.PreferredAddress
	}
	return 0
}
func (m *ActualLRPNetInfo) SetPreferredAddress(value ActualLRPNetInfo_PreferredAddress) {
	if m != nil {
		m.PreferredAddress = value
	}
}
func (x *ActualLRPNetInfo) ToProto() *ProtoActualLRPNetInfo {
	proto := &ProtoActualLRPNetInfo{
		Address:          x.Address,
		Ports:            PortMappingProtoMap(x.Ports),
		InstanceAddress:  x.InstanceAddress,
		PreferredAddress: ProtoActualLRPNetInfo_PreferredAddress(x.PreferredAddress),
	}
	return proto
}

func ActualLRPNetInfoProtoMap(values []*ActualLRPNetInfo) []*ProtoActualLRPNetInfo {
	result := make([]*ProtoActualLRPNetInfo, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPInternalRoute directly
type ActualLRPInternalRoute struct {
	Hostname string
}

func (this *ActualLRPInternalRoute) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRPInternalRoute)
	if !ok {
		that2, ok := that.(ActualLRPInternalRoute)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if this.Hostname != that1.Hostname {
		return false
	}
	return true
}
func (m *ActualLRPInternalRoute) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}
func (m *ActualLRPInternalRoute) SetHostname(value string) {
	if m != nil {
		m.Hostname = value
	}
}
func (x *ActualLRPInternalRoute) ToProto() *ProtoActualLRPInternalRoute {
	proto := &ProtoActualLRPInternalRoute{
		Hostname: x.Hostname,
	}
	return proto
}

func ActualLRPInternalRouteProtoMap(values []*ActualLRPInternalRoute) []*ProtoActualLRPInternalRoute {
	result := make([]*ProtoActualLRPInternalRoute, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

type ActualLRP_Presence int32

const (
	ActualLRP_Ordinary   ActualLRP_Presence = 0
	ActualLRP_Evacuating ActualLRP_Presence = 1
	ActualLRP_Suspect    ActualLRP_Presence = 2
)

// Enum value maps for ActualLRP_Presence
var (
	ActualLRP_Presence_name = map[int32]string{
		0: "ORDINARY",
		1: "EVACUATING",
		2: "SUSPECT",
	}
	ActualLRP_Presence_value = map[string]int32{
		"ORDINARY":   0,
		"EVACUATING": 1,
		"SUSPECT":    2,
	}
)

func (m ActualLRP_Presence) String() string {
	s, ok := ActualLRP_Presence_name[int32(m)]
	if ok {
		return s
	}
	return strconv.Itoa(int(m))
}

// Prevent copylock errors when using ProtoActualLRP directly
type ActualLRP struct {
	ActualLrpKey            *ActualLRPKey
	ActualLrpInstanceKey    *ActualLRPInstanceKey
	ActualLrpNetInfo        *ActualLRPNetInfo
	CrashCount              int32
	CrashReason             string
	State                   string
	PlacementError          string
	Since                   int64
	ModificationTag         *ModificationTag
	Presence                ActualLRP_Presence
	ActualLrpInternalRoutes []*ActualLRPInternalRoute
	MetricTags              map[string]string
	Routable                *bool
	AvailabilityZone        string
}

func (this *ActualLRP) Equal(that interface{}) bool {

	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ActualLRP)
	if !ok {
		that2, ok := that.(ActualLRP)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}

	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}

	if !this.ActualLrpKey.Equal(that1.ActualLrpKey) {
		return false
	}
	if !this.ActualLrpInstanceKey.Equal(that1.ActualLrpInstanceKey) {
		return false
	}
	if !this.ActualLrpNetInfo.Equal(that1.ActualLrpNetInfo) {
		return false
	}
	if this.CrashCount != that1.CrashCount {
		return false
	}
	if this.CrashReason != that1.CrashReason {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.PlacementError != that1.PlacementError {
		return false
	}
	if this.Since != that1.Since {
		return false
	}
	if !this.ModificationTag.Equal(that1.ModificationTag) {
		return false
	}
	if this.Presence != that1.Presence {
		return false
	}
	if len(this.ActualLrpInternalRoutes) != len(that1.ActualLrpInternalRoutes) {
		return false
	}
	for i := range this.ActualLrpInternalRoutes {
		if !this.ActualLrpInternalRoutes[i].Equal(that1.ActualLrpInternalRoutes[i]) {
			return false
		}
	}
	if len(this.MetricTags) != len(that1.MetricTags) {
		return false
	}
	for i := range this.MetricTags {
		if this.MetricTags[i] != that1.MetricTags[i] {
			return false
		}
	}
	if this.Routable != that1.Routable {
		return false
	}
	if this.AvailabilityZone != that1.AvailabilityZone {
		return false
	}
	return true
}
func (m *ActualLRP) GetActualLrpKey() *ActualLRPKey {
	if m != nil {
		return m.ActualLrpKey
	}
	return nil
}
func (m *ActualLRP) SetActualLrpKey(value *ActualLRPKey) {
	if m != nil {
		m.ActualLrpKey = value
	}
}
func (m *ActualLRP) GetActualLrpInstanceKey() *ActualLRPInstanceKey {
	if m != nil {
		return m.ActualLrpInstanceKey
	}
	return nil
}
func (m *ActualLRP) SetActualLrpInstanceKey(value *ActualLRPInstanceKey) {
	if m != nil {
		m.ActualLrpInstanceKey = value
	}
}
func (m *ActualLRP) GetActualLrpNetInfo() *ActualLRPNetInfo {
	if m != nil {
		return m.ActualLrpNetInfo
	}
	return nil
}
func (m *ActualLRP) SetActualLrpNetInfo(value *ActualLRPNetInfo) {
	if m != nil {
		m.ActualLrpNetInfo = value
	}
}
func (m *ActualLRP) GetCrashCount() int32 {
	if m != nil {
		return m.CrashCount
	}
	return 0
}
func (m *ActualLRP) SetCrashCount(value int32) {
	if m != nil {
		m.CrashCount = value
	}
}
func (m *ActualLRP) GetCrashReason() string {
	if m != nil {
		return m.CrashReason
	}
	return ""
}
func (m *ActualLRP) SetCrashReason(value string) {
	if m != nil {
		m.CrashReason = value
	}
}
func (m *ActualLRP) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}
func (m *ActualLRP) SetState(value string) {
	if m != nil {
		m.State = value
	}
}
func (m *ActualLRP) GetPlacementError() string {
	if m != nil {
		return m.PlacementError
	}
	return ""
}
func (m *ActualLRP) SetPlacementError(value string) {
	if m != nil {
		m.PlacementError = value
	}
}
func (m *ActualLRP) GetSince() int64 {
	if m != nil {
		return m.Since
	}
	return 0
}
func (m *ActualLRP) SetSince(value int64) {
	if m != nil {
		m.Since = value
	}
}
func (m *ActualLRP) GetModificationTag() *ModificationTag {
	if m != nil {
		return m.ModificationTag
	}
	return nil
}
func (m *ActualLRP) SetModificationTag(value *ModificationTag) {
	if m != nil {
		m.ModificationTag = value
	}
}
func (m *ActualLRP) GetPresence() ActualLRP_Presence {
	if m != nil {
		return m.Presence
	}
	return 0
}
func (m *ActualLRP) SetPresence(value ActualLRP_Presence) {
	if m != nil {
		m.Presence = value
	}
}
func (m *ActualLRP) GetActualLrpInternalRoutes() []*ActualLRPInternalRoute {
	if m != nil {
		return m.ActualLrpInternalRoutes
	}
	return nil
}
func (m *ActualLRP) SetActualLrpInternalRoutes(value []*ActualLRPInternalRoute) {
	if m != nil {
		m.ActualLrpInternalRoutes = value
	}
}
func (m *ActualLRP) GetMetricTags() map[string]string {
	if m != nil {
		return m.MetricTags
	}
	return nil
}
func (m *ActualLRP) SetMetricTags(value map[string]string) {
	if m != nil {
		m.MetricTags = value
	}
}
func (m *ActualLRP) RoutableExists() bool {
	return m != nil && m.Routable != nil
}
func (m *ActualLRP) GetRoutable() *bool {
	if m != nil && m.Routable != nil {
		return m.Routable
	}
	return nil
}
func (m *ActualLRP) SetRoutable(value *bool) {
	if m != nil {
		m.Routable = value
	}
}
func (m *ActualLRP) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}
func (m *ActualLRP) SetAvailabilityZone(value string) {
	if m != nil {
		m.AvailabilityZone = value
	}
}
func (x *ActualLRP) ToProto() *ProtoActualLRP {
	proto := &ProtoActualLRP{
		ActualLrpKey:            x.ActualLrpKey.ToProto(),
		ActualLrpInstanceKey:    x.ActualLrpInstanceKey.ToProto(),
		ActualLrpNetInfo:        x.ActualLrpNetInfo.ToProto(),
		CrashCount:              x.CrashCount,
		CrashReason:             x.CrashReason,
		State:                   x.State,
		PlacementError:          x.PlacementError,
		Since:                   x.Since,
		ModificationTag:         x.ModificationTag.ToProto(),
		Presence:                ProtoActualLRP_Presence(x.Presence),
		ActualLrpInternalRoutes: ActualLRPInternalRouteProtoMap(x.ActualLrpInternalRoutes),
		MetricTags:              x.MetricTags,
		Routable:                x.Routable,
		AvailabilityZone:        x.AvailabilityZone,
	}
	return proto
}

func ActualLRPProtoMap(values []*ActualLRP) []*ProtoActualLRP {
	result := make([]*ProtoActualLRP, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}
