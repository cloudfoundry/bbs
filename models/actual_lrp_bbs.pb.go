// Code generated by protoc-gen-go-bbs. DO NOT EDIT.
// versions:
// - protoc-gen-go-bbs v0.0.1
// - protoc            v5.27.0--rc1
// source: actual_lrp.proto

package models

// Prevent copylock errors when using ProtoActualLRPGroup directly
type ActualLRPGroup struct {
	Instance   *ActualLRP
	Evacuating *ActualLRP
}

func (x *ActualLRPGroup) ToProto() *ProtoActualLRPGroup {
	proto := &ProtoActualLRPGroup{
		Instance:   x.Instance.ToProto(),
		Evacuating: x.Evacuating.ToProto(),
	}
	return proto
}

func ActualLRPGroupProtoMap(values []*ActualLRPGroup) []*ProtoActualLRPGroup {
	result := make([]*ProtoActualLRPGroup, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoPortMapping directly
type PortMapping struct {
	ContainerPort         uint32
	HostPort              uint32
	ContainerTlsProxyPort uint32
	HostTlsProxyPort      uint32
}

func (x *PortMapping) ToProto() *ProtoPortMapping {
	proto := &ProtoPortMapping{
		ContainerPort:         x.ContainerPort,
		HostPort:              x.HostPort,
		ContainerTlsProxyPort: x.ContainerTlsProxyPort,
		HostTlsProxyPort:      x.HostTlsProxyPort,
	}
	return proto
}

func PortMappingProtoMap(values []*PortMapping) []*ProtoPortMapping {
	result := make([]*ProtoPortMapping, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPKey directly
type ActualLRPKey struct {
	ProcessGuid string
	Index       int32
	Domain      string
}

func (x *ActualLRPKey) ToProto() *ProtoActualLRPKey {
	proto := &ProtoActualLRPKey{
		ProcessGuid: x.ProcessGuid,
		Index:       x.Index,
		Domain:      x.Domain,
	}
	return proto
}

func ActualLRPKeyProtoMap(values []*ActualLRPKey) []*ProtoActualLRPKey {
	result := make([]*ProtoActualLRPKey, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPInstanceKey directly
type ActualLRPInstanceKey struct {
	InstanceGuid string
	CellId       string
}

func (x *ActualLRPInstanceKey) ToProto() *ProtoActualLRPInstanceKey {
	proto := &ProtoActualLRPInstanceKey{
		InstanceGuid: x.InstanceGuid,
		CellId:       x.CellId,
	}
	return proto
}

func ActualLRPInstanceKeyProtoMap(values []*ActualLRPInstanceKey) []*ProtoActualLRPInstanceKey {
	result := make([]*ProtoActualLRPInstanceKey, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

type ActualLRPNetInfo_PreferredAddress int32

const (
	ActualLRPNetInfo_PreferredAddressUnknown  ActualLRPNetInfo_PreferredAddress = 0
	ActualLRPNetInfo_PreferredAddressInstance ActualLRPNetInfo_PreferredAddress = 1
	ActualLRPNetInfo_PreferredAddressHost     ActualLRPNetInfo_PreferredAddress = 2
)

// Prevent copylock errors when using ProtoActualLRPNetInfo directly
type ActualLRPNetInfo struct {
	Address          string
	Ports            []*PortMapping
	InstanceAddress  string
	PreferredAddress ActualLRPNetInfo_PreferredAddress
}

func (x *ActualLRPNetInfo) ToProto() *ProtoActualLRPNetInfo {
	proto := &ProtoActualLRPNetInfo{
		Address:          x.Address,
		Ports:            PortMappingProtoMap(x.Ports),
		InstanceAddress:  x.InstanceAddress,
		PreferredAddress: ProtoActualLRPNetInfo_PreferredAddress(x.PreferredAddress),
	}
	return proto
}

func ActualLRPNetInfoProtoMap(values []*ActualLRPNetInfo) []*ProtoActualLRPNetInfo {
	result := make([]*ProtoActualLRPNetInfo, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

// Prevent copylock errors when using ProtoActualLRPInternalRoute directly
type ActualLRPInternalRoute struct {
	Hostname string
}

func (x *ActualLRPInternalRoute) ToProto() *ProtoActualLRPInternalRoute {
	proto := &ProtoActualLRPInternalRoute{
		Hostname: x.Hostname,
	}
	return proto
}

func ActualLRPInternalRouteProtoMap(values []*ActualLRPInternalRoute) []*ProtoActualLRPInternalRoute {
	result := make([]*ProtoActualLRPInternalRoute, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}

type ActualLRP_Presence int32

const (
	ActualLRP_Ordinary   ActualLRP_Presence = 0
	ActualLRP_Evacuating ActualLRP_Presence = 1
	ActualLRP_Suspect    ActualLRP_Presence = 2
)

// Prevent copylock errors when using ProtoActualLRP directly
type ActualLRP struct {
	ActualLrpKey            *ActualLRPKey
	ActualLrpInstanceKey    *ActualLRPInstanceKey
	ActualLrpNetInfo        *ActualLRPNetInfo
	CrashCount              int32
	CrashReason             string
	State                   string
	PlacementError          string
	Since                   int64
	ModificationTag         *ModificationTag
	Presence                ActualLRP_Presence
	ActualLrpInternalRoutes []*ActualLRPInternalRoute
	MetricTags              map[string]string
	Routable                bool
	AvailabilityZone        string
}

func (x *ActualLRP) ToProto() *ProtoActualLRP {
	proto := &ProtoActualLRP{
		ActualLrpKey:            x.ActualLrpKey.ToProto(),
		ActualLrpInstanceKey:    x.ActualLrpInstanceKey.ToProto(),
		ActualLrpNetInfo:        x.ActualLrpNetInfo.ToProto(),
		CrashCount:              x.CrashCount,
		CrashReason:             x.CrashReason,
		State:                   x.State,
		PlacementError:          x.PlacementError,
		Since:                   x.Since,
		ModificationTag:         x.ModificationTag.ToProto(),
		Presence:                ProtoActualLRP_Presence(x.Presence),
		ActualLrpInternalRoutes: ActualLRPInternalRouteProtoMap(x.ActualLrpInternalRoutes),
		MetricTags:              x.MetricTags,
		Routable:                &x.Routable,
		AvailabilityZone:        x.AvailabilityZone,
	}
	return proto
}

func ActualLRPProtoMap(values []*ActualLRP) []*ProtoActualLRP {
	result := make([]*ProtoActualLRP, len(values))
	for i, val := range values {
		result[i] = val.ToProto()
	}
	return result
}
